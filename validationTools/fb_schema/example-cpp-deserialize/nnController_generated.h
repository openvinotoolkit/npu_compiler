// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_NNCONTROLLER_MVCNN_H_
#define FLATBUFFERS_GENERATED_NNCONTROLLER_MVCNN_H_

#include "flatbuffers/flatbuffers.h"

#include "memoryManagement_generated.h"
#include "structure_generated.h"

namespace MVCNN {

struct TimerTask;

struct MemoryTask;

struct BarrierConfigurationTask;

struct ControllerTask;

enum ControllerSubTask {
  ControllerSubTask_NONE = 0,
  ControllerSubTask_TimerTask = 1,
  ControllerSubTask_MemoryTask = 2,
  ControllerSubTask_BarrierConfigurationTask = 3,
  ControllerSubTask_MIN = ControllerSubTask_NONE,
  ControllerSubTask_MAX = ControllerSubTask_BarrierConfigurationTask
};

inline const ControllerSubTask (&EnumValuesControllerSubTask())[4] {
  static const ControllerSubTask values[] = {
    ControllerSubTask_NONE,
    ControllerSubTask_TimerTask,
    ControllerSubTask_MemoryTask,
    ControllerSubTask_BarrierConfigurationTask
  };
  return values;
}

inline const char * const *EnumNamesControllerSubTask() {
  static const char * const names[] = {
    "NONE",
    "TimerTask",
    "MemoryTask",
    "BarrierConfigurationTask",
    nullptr
  };
  return names;
}

inline const char *EnumNameControllerSubTask(ControllerSubTask e) {
  if (e < ControllerSubTask_NONE || e > ControllerSubTask_BarrierConfigurationTask) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesControllerSubTask()[index];
}

template<typename T> struct ControllerSubTaskTraits {
  static const ControllerSubTask enum_value = ControllerSubTask_NONE;
};

template<> struct ControllerSubTaskTraits<TimerTask> {
  static const ControllerSubTask enum_value = ControllerSubTask_TimerTask;
};

template<> struct ControllerSubTaskTraits<MemoryTask> {
  static const ControllerSubTask enum_value = ControllerSubTask_MemoryTask;
};

template<> struct ControllerSubTaskTraits<BarrierConfigurationTask> {
  static const ControllerSubTask enum_value = ControllerSubTask_BarrierConfigurationTask;
};

bool VerifyControllerSubTask(flatbuffers::Verifier &verifier, const void *obj, ControllerSubTask type);
bool VerifyControllerSubTaskVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct TimerTask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_WRITE_LOCATION = 6
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  const TensorReference *write_location() const {
    return GetPointer<const TensorReference *>(VT_WRITE_LOCATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_WRITE_LOCATION) &&
           verifier.VerifyTable(write_location()) &&
           verifier.EndTable();
  }
};

struct TimerTaskBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(TimerTask::VT_ID, id, 0);
  }
  void add_write_location(flatbuffers::Offset<TensorReference> write_location) {
    fbb_.AddOffset(TimerTask::VT_WRITE_LOCATION, write_location);
  }
  explicit TimerTaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TimerTaskBuilder &operator=(const TimerTaskBuilder &);
  flatbuffers::Offset<TimerTask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TimerTask>(end);
    return o;
  }
};

inline flatbuffers::Offset<TimerTask> CreateTimerTask(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    flatbuffers::Offset<TensorReference> write_location = 0) {
  TimerTaskBuilder builder_(_fbb);
  builder_.add_write_location(write_location);
  builder_.add_id(id);
  return builder_.Finish();
}

struct MemoryTask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
};

struct MemoryTaskBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(MemoryTask::VT_ID, id, 0);
  }
  explicit MemoryTaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MemoryTaskBuilder &operator=(const MemoryTaskBuilder &);
  flatbuffers::Offset<MemoryTask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MemoryTask>(end);
    return o;
  }
};

inline flatbuffers::Offset<MemoryTask> CreateMemoryTask(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0) {
  MemoryTaskBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct BarrierConfigurationTask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TARGET = 4
  };
  const Barrier *target() const {
    return GetPointer<const Barrier *>(VT_TARGET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TARGET) &&
           verifier.VerifyTable(target()) &&
           verifier.EndTable();
  }
};

struct BarrierConfigurationTaskBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_target(flatbuffers::Offset<Barrier> target) {
    fbb_.AddOffset(BarrierConfigurationTask::VT_TARGET, target);
  }
  explicit BarrierConfigurationTaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BarrierConfigurationTaskBuilder &operator=(const BarrierConfigurationTaskBuilder &);
  flatbuffers::Offset<BarrierConfigurationTask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BarrierConfigurationTask>(end);
    return o;
  }
};

inline flatbuffers::Offset<BarrierConfigurationTask> CreateBarrierConfigurationTask(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Barrier> target = 0) {
  BarrierConfigurationTaskBuilder builder_(_fbb);
  builder_.add_target(target);
  return builder_.Finish();
}

struct ControllerTask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TASK_TYPE = 4,
    VT_TASK = 6
  };
  ControllerSubTask task_type() const {
    return static_cast<ControllerSubTask>(GetField<uint8_t>(VT_TASK_TYPE, 0));
  }
  const void *task() const {
    return GetPointer<const void *>(VT_TASK);
  }
  template<typename T> const T *task_as() const;
  const TimerTask *task_as_TimerTask() const {
    return task_type() == ControllerSubTask_TimerTask ? static_cast<const TimerTask *>(task()) : nullptr;
  }
  const MemoryTask *task_as_MemoryTask() const {
    return task_type() == ControllerSubTask_MemoryTask ? static_cast<const MemoryTask *>(task()) : nullptr;
  }
  const BarrierConfigurationTask *task_as_BarrierConfigurationTask() const {
    return task_type() == ControllerSubTask_BarrierConfigurationTask ? static_cast<const BarrierConfigurationTask *>(task()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TASK_TYPE) &&
           VerifyOffset(verifier, VT_TASK) &&
           VerifyControllerSubTask(verifier, task(), task_type()) &&
           verifier.EndTable();
  }
};

template<> inline const TimerTask *ControllerTask::task_as<TimerTask>() const {
  return task_as_TimerTask();
}

template<> inline const MemoryTask *ControllerTask::task_as<MemoryTask>() const {
  return task_as_MemoryTask();
}

template<> inline const BarrierConfigurationTask *ControllerTask::task_as<BarrierConfigurationTask>() const {
  return task_as_BarrierConfigurationTask();
}

struct ControllerTaskBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_task_type(ControllerSubTask task_type) {
    fbb_.AddElement<uint8_t>(ControllerTask::VT_TASK_TYPE, static_cast<uint8_t>(task_type), 0);
  }
  void add_task(flatbuffers::Offset<void> task) {
    fbb_.AddOffset(ControllerTask::VT_TASK, task);
  }
  explicit ControllerTaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ControllerTaskBuilder &operator=(const ControllerTaskBuilder &);
  flatbuffers::Offset<ControllerTask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ControllerTask>(end);
    return o;
  }
};

inline flatbuffers::Offset<ControllerTask> CreateControllerTask(
    flatbuffers::FlatBufferBuilder &_fbb,
    ControllerSubTask task_type = ControllerSubTask_NONE,
    flatbuffers::Offset<void> task = 0) {
  ControllerTaskBuilder builder_(_fbb);
  builder_.add_task(task);
  builder_.add_task_type(task_type);
  return builder_.Finish();
}

inline bool VerifyControllerSubTask(flatbuffers::Verifier &verifier, const void *obj, ControllerSubTask type) {
  switch (type) {
    case ControllerSubTask_NONE: {
      return true;
    }
    case ControllerSubTask_TimerTask: {
      auto ptr = reinterpret_cast<const TimerTask *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ControllerSubTask_MemoryTask: {
      auto ptr = reinterpret_cast<const MemoryTask *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ControllerSubTask_BarrierConfigurationTask: {
      auto ptr = reinterpret_cast<const BarrierConfigurationTask *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyControllerSubTaskVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyControllerSubTask(
        verifier,  values->Get(i), types->GetEnum<ControllerSubTask>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace MVCNN

#endif  // FLATBUFFERS_GENERATED_NNCONTROLLER_MVCNN_H_
