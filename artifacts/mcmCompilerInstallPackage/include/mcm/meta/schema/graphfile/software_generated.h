// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SOFTWARE_MVCNN_H_
#define FLATBUFFERS_GENERATED_SOFTWARE_MVCNN_H_

#include "flatbuffers/flatbuffers.h"

#include "memoryManagement_generated.h"

namespace MVCNN {

struct order3;

struct QuantizeParams;
struct QuantizeParamsT;

struct DummyParams;
struct DummyParamsT;

struct DetectionOutputParams;
struct DetectionOutputParamsT;

struct DeconvolutionParams;
struct DeconvolutionParamsT;

struct FlattenParams;
struct FlattenParamsT;

struct InterpParams;
struct InterpParamsT;

struct NormalizeParams;
struct NormalizeParamsT;

struct PermuteParams;
struct PermuteParamsT;

struct PriorboxParams;
struct PriorboxParamsT;

struct ROIPoolingParams;
struct ROIPoolingParamsT;

struct PSROIPoolingParams;
struct PSROIPoolingParamsT;

struct ProposalParams;
struct ProposalParamsT;

struct RegionYOLOParams;
struct RegionYOLOParamsT;

struct ReorgYOLOParams;
struct ReorgYOLOParamsT;

struct ReshapeParams;
struct ReshapeParamsT;

struct SoftmaxParams;
struct SoftmaxParamsT;

struct CustomLayerParams;
struct CustomLayerParamsT;

struct EdslParams;
struct EdslParamsT;

struct PassthroughParams;
struct PassthroughParamsT;

struct LayerRecordParams;
struct LayerRecordParamsT;

struct ArgMaxParams;
struct ArgMaxParamsT;

struct NormParams;
struct NormParamsT;

struct EltwiseParams;
struct EltwiseParamsT;

struct ResampleParams;
struct ResampleParamsT;

struct CorrelationParams;
struct CorrelationParamsT;

struct MVNParams;
struct MVNParamsT;

struct GRNParams;
struct GRNParamsT;

struct CTCDecoderParams;
struct CTCDecoderParamsT;

struct SpatialTransformParams;
struct SpatialTransformParamsT;

struct FakeQuantizeParams;
struct FakeQuantizeParamsT;

struct PoolingParams;
struct PoolingParamsT;

struct TileParams;
struct TileParamsT;

struct LeakyReluParams;
struct LeakyReluParamsT;

struct SigmoidParams;
struct SigmoidParamsT;

struct UnaryOpParams;
struct UnaryOpParamsT;

struct UPALayerTask;
struct UPALayerTaskT;

struct SNNLayerTask;
struct SNNLayerTaskT;

struct Tensor;
struct TensorT;

struct Conv2D;
struct Conv2DT;

struct Pooling;
struct PoolingT;

struct ReLU;
struct ReLUT;

struct Passthrough;
struct PassthroughT;

struct Custom;
struct CustomT;

struct MvTensorTask;
struct MvTensorTaskT;

struct PPEConfigure;
struct PPEConfigureT;

struct PPEAssist;
struct PPEAssistT;

struct NNTensorTask;
struct NNTensorTaskT;

enum PSROIPoolingMode {
  PSROIPoolingMode_AVERAGE = 0,
  PSROIPoolingMode_BILINEAR = 1,
  PSROIPoolingMode_BILINEAR_DEFORMABLE = 2,
  PSROIPoolingMode_MIN = PSROIPoolingMode_AVERAGE,
  PSROIPoolingMode_MAX = PSROIPoolingMode_BILINEAR_DEFORMABLE
};

inline const PSROIPoolingMode (&EnumValuesPSROIPoolingMode())[3] {
  static const PSROIPoolingMode values[] = {
    PSROIPoolingMode_AVERAGE,
    PSROIPoolingMode_BILINEAR,
    PSROIPoolingMode_BILINEAR_DEFORMABLE
  };
  return values;
}

inline const char * const *EnumNamesPSROIPoolingMode() {
  static const char * const names[] = {
    "AVERAGE",
    "BILINEAR",
    "BILINEAR_DEFORMABLE",
    nullptr
  };
  return names;
}

inline const char *EnumNamePSROIPoolingMode(PSROIPoolingMode e) {
  if (e < PSROIPoolingMode_AVERAGE || e > PSROIPoolingMode_BILINEAR_DEFORMABLE) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPSROIPoolingMode()[index];
}

enum InterpolationMethod {
  InterpolationMethod_NEAREST = 0,
  InterpolationMethod_BILINEAR = 1,
  InterpolationMethod_BICUBIC = 2,
  InterpolationMethod_MIN = InterpolationMethod_NEAREST,
  InterpolationMethod_MAX = InterpolationMethod_BICUBIC
};

inline const InterpolationMethod (&EnumValuesInterpolationMethod())[3] {
  static const InterpolationMethod values[] = {
    InterpolationMethod_NEAREST,
    InterpolationMethod_BILINEAR,
    InterpolationMethod_BICUBIC
  };
  return values;
}

inline const char * const *EnumNamesInterpolationMethod() {
  static const char * const names[] = {
    "NEAREST",
    "BILINEAR",
    "BICUBIC",
    nullptr
  };
  return names;
}

inline const char *EnumNameInterpolationMethod(InterpolationMethod e) {
  if (e < InterpolationMethod_NEAREST || e > InterpolationMethod_BICUBIC) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesInterpolationMethod()[index];
}

enum UnaryOpNestedParams {
  UnaryOpNestedParams_NONE = 0,
  UnaryOpNestedParams_LeakyReluParams = 1,
  UnaryOpNestedParams_SigmoidParams = 2,
  UnaryOpNestedParams_MIN = UnaryOpNestedParams_NONE,
  UnaryOpNestedParams_MAX = UnaryOpNestedParams_SigmoidParams
};

inline const UnaryOpNestedParams (&EnumValuesUnaryOpNestedParams())[3] {
  static const UnaryOpNestedParams values[] = {
    UnaryOpNestedParams_NONE,
    UnaryOpNestedParams_LeakyReluParams,
    UnaryOpNestedParams_SigmoidParams
  };
  return values;
}

inline const char * const *EnumNamesUnaryOpNestedParams() {
  static const char * const names[] = {
    "NONE",
    "LeakyReluParams",
    "SigmoidParams",
    nullptr
  };
  return names;
}

inline const char *EnumNameUnaryOpNestedParams(UnaryOpNestedParams e) {
  if (e < UnaryOpNestedParams_NONE || e > UnaryOpNestedParams_SigmoidParams) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesUnaryOpNestedParams()[index];
}

template<typename T> struct UnaryOpNestedParamsTraits {
  static const UnaryOpNestedParams enum_value = UnaryOpNestedParams_NONE;
};

template<> struct UnaryOpNestedParamsTraits<LeakyReluParams> {
  static const UnaryOpNestedParams enum_value = UnaryOpNestedParams_LeakyReluParams;
};

template<> struct UnaryOpNestedParamsTraits<SigmoidParams> {
  static const UnaryOpNestedParams enum_value = UnaryOpNestedParams_SigmoidParams;
};

struct UnaryOpNestedParamsUnion {
  UnaryOpNestedParams type;
  void *value;

  UnaryOpNestedParamsUnion() : type(UnaryOpNestedParams_NONE), value(nullptr) {}
  UnaryOpNestedParamsUnion(UnaryOpNestedParamsUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(UnaryOpNestedParams_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  UnaryOpNestedParamsUnion(const UnaryOpNestedParamsUnion &) FLATBUFFERS_NOEXCEPT;
  UnaryOpNestedParamsUnion &operator=(const UnaryOpNestedParamsUnion &u) FLATBUFFERS_NOEXCEPT
    { UnaryOpNestedParamsUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  UnaryOpNestedParamsUnion &operator=(UnaryOpNestedParamsUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~UnaryOpNestedParamsUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = UnaryOpNestedParamsTraits<typename RT::TableType>::enum_value;
    if (type != UnaryOpNestedParams_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, UnaryOpNestedParams type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  LeakyReluParamsT *AsLeakyReluParams() {
    return type == UnaryOpNestedParams_LeakyReluParams ?
      reinterpret_cast<LeakyReluParamsT *>(value) : nullptr;
  }
  const LeakyReluParamsT *AsLeakyReluParams() const {
    return type == UnaryOpNestedParams_LeakyReluParams ?
      reinterpret_cast<const LeakyReluParamsT *>(value) : nullptr;
  }
  SigmoidParamsT *AsSigmoidParams() {
    return type == UnaryOpNestedParams_SigmoidParams ?
      reinterpret_cast<SigmoidParamsT *>(value) : nullptr;
  }
  const SigmoidParamsT *AsSigmoidParams() const {
    return type == UnaryOpNestedParams_SigmoidParams ?
      reinterpret_cast<const SigmoidParamsT *>(value) : nullptr;
  }
};

bool VerifyUnaryOpNestedParams(flatbuffers::Verifier &verifier, const void *obj, UnaryOpNestedParams type);
bool VerifyUnaryOpNestedParamsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum SoftwareLayerParams {
  SoftwareLayerParams_NONE = 0,
  SoftwareLayerParams_DummyParams = 1,
  SoftwareLayerParams_DetectionOutputParams = 2,
  SoftwareLayerParams_FlattenParams = 3,
  SoftwareLayerParams_InterpParams = 4,
  SoftwareLayerParams_NormalizeParams = 5,
  SoftwareLayerParams_PermuteParams = 6,
  SoftwareLayerParams_PriorboxParams = 7,
  SoftwareLayerParams_ProposalParams = 8,
  SoftwareLayerParams_RegionYOLOParams = 9,
  SoftwareLayerParams_ReorgYOLOParams = 10,
  SoftwareLayerParams_ReshapeParams = 11,
  SoftwareLayerParams_SoftmaxParams = 12,
  SoftwareLayerParams_CustomLayerParams = 13,
  SoftwareLayerParams_PassthroughParams = 14,
  SoftwareLayerParams_LayerRecordParams = 15,
  SoftwareLayerParams_ROIPoolingParams = 16,
  SoftwareLayerParams_QuantizeParams = 17,
  SoftwareLayerParams_ArgMaxParams = 18,
  SoftwareLayerParams_NormParams = 19,
  SoftwareLayerParams_EltwiseParams = 20,
  SoftwareLayerParams_ResampleParams = 21,
  SoftwareLayerParams_CorrelationParams = 22,
  SoftwareLayerParams_MVNParams = 23,
  SoftwareLayerParams_GRNParams = 24,
  SoftwareLayerParams_CTCDecoderParams = 25,
  SoftwareLayerParams_SpatialTransformParams = 26,
  SoftwareLayerParams_FakeQuantizeParams = 27,
  SoftwareLayerParams_PoolingParams = 28,
  SoftwareLayerParams_EdslParams = 29,
  SoftwareLayerParams_TileParams = 30,
  SoftwareLayerParams_PSROIPoolingParams = 31,
  SoftwareLayerParams_DeconvolutionParams = 32,
  SoftwareLayerParams_UnaryOpParams = 33,
  SoftwareLayerParams_MIN = SoftwareLayerParams_NONE,
  SoftwareLayerParams_MAX = SoftwareLayerParams_UnaryOpParams
};

inline const SoftwareLayerParams (&EnumValuesSoftwareLayerParams())[34] {
  static const SoftwareLayerParams values[] = {
    SoftwareLayerParams_NONE,
    SoftwareLayerParams_DummyParams,
    SoftwareLayerParams_DetectionOutputParams,
    SoftwareLayerParams_FlattenParams,
    SoftwareLayerParams_InterpParams,
    SoftwareLayerParams_NormalizeParams,
    SoftwareLayerParams_PermuteParams,
    SoftwareLayerParams_PriorboxParams,
    SoftwareLayerParams_ProposalParams,
    SoftwareLayerParams_RegionYOLOParams,
    SoftwareLayerParams_ReorgYOLOParams,
    SoftwareLayerParams_ReshapeParams,
    SoftwareLayerParams_SoftmaxParams,
    SoftwareLayerParams_CustomLayerParams,
    SoftwareLayerParams_PassthroughParams,
    SoftwareLayerParams_LayerRecordParams,
    SoftwareLayerParams_ROIPoolingParams,
    SoftwareLayerParams_QuantizeParams,
    SoftwareLayerParams_ArgMaxParams,
    SoftwareLayerParams_NormParams,
    SoftwareLayerParams_EltwiseParams,
    SoftwareLayerParams_ResampleParams,
    SoftwareLayerParams_CorrelationParams,
    SoftwareLayerParams_MVNParams,
    SoftwareLayerParams_GRNParams,
    SoftwareLayerParams_CTCDecoderParams,
    SoftwareLayerParams_SpatialTransformParams,
    SoftwareLayerParams_FakeQuantizeParams,
    SoftwareLayerParams_PoolingParams,
    SoftwareLayerParams_EdslParams,
    SoftwareLayerParams_TileParams,
    SoftwareLayerParams_PSROIPoolingParams,
    SoftwareLayerParams_DeconvolutionParams,
    SoftwareLayerParams_UnaryOpParams
  };
  return values;
}

inline const char * const *EnumNamesSoftwareLayerParams() {
  static const char * const names[] = {
    "NONE",
    "DummyParams",
    "DetectionOutputParams",
    "FlattenParams",
    "InterpParams",
    "NormalizeParams",
    "PermuteParams",
    "PriorboxParams",
    "ProposalParams",
    "RegionYOLOParams",
    "ReorgYOLOParams",
    "ReshapeParams",
    "SoftmaxParams",
    "CustomLayerParams",
    "PassthroughParams",
    "LayerRecordParams",
    "ROIPoolingParams",
    "QuantizeParams",
    "ArgMaxParams",
    "NormParams",
    "EltwiseParams",
    "ResampleParams",
    "CorrelationParams",
    "MVNParams",
    "GRNParams",
    "CTCDecoderParams",
    "SpatialTransformParams",
    "FakeQuantizeParams",
    "PoolingParams",
    "EdslParams",
    "TileParams",
    "PSROIPoolingParams",
    "DeconvolutionParams",
    "UnaryOpParams",
    nullptr
  };
  return names;
}

inline const char *EnumNameSoftwareLayerParams(SoftwareLayerParams e) {
  if (e < SoftwareLayerParams_NONE || e > SoftwareLayerParams_UnaryOpParams) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSoftwareLayerParams()[index];
}

template<typename T> struct SoftwareLayerParamsTraits {
  static const SoftwareLayerParams enum_value = SoftwareLayerParams_NONE;
};

template<> struct SoftwareLayerParamsTraits<DummyParams> {
  static const SoftwareLayerParams enum_value = SoftwareLayerParams_DummyParams;
};

template<> struct SoftwareLayerParamsTraits<DetectionOutputParams> {
  static const SoftwareLayerParams enum_value = SoftwareLayerParams_DetectionOutputParams;
};

template<> struct SoftwareLayerParamsTraits<FlattenParams> {
  static const SoftwareLayerParams enum_value = SoftwareLayerParams_FlattenParams;
};

template<> struct SoftwareLayerParamsTraits<InterpParams> {
  static const SoftwareLayerParams enum_value = SoftwareLayerParams_InterpParams;
};

template<> struct SoftwareLayerParamsTraits<NormalizeParams> {
  static const SoftwareLayerParams enum_value = SoftwareLayerParams_NormalizeParams;
};

template<> struct SoftwareLayerParamsTraits<PermuteParams> {
  static const SoftwareLayerParams enum_value = SoftwareLayerParams_PermuteParams;
};

template<> struct SoftwareLayerParamsTraits<PriorboxParams> {
  static const SoftwareLayerParams enum_value = SoftwareLayerParams_PriorboxParams;
};

template<> struct SoftwareLayerParamsTraits<ProposalParams> {
  static const SoftwareLayerParams enum_value = SoftwareLayerParams_ProposalParams;
};

template<> struct SoftwareLayerParamsTraits<RegionYOLOParams> {
  static const SoftwareLayerParams enum_value = SoftwareLayerParams_RegionYOLOParams;
};

template<> struct SoftwareLayerParamsTraits<ReorgYOLOParams> {
  static const SoftwareLayerParams enum_value = SoftwareLayerParams_ReorgYOLOParams;
};

template<> struct SoftwareLayerParamsTraits<ReshapeParams> {
  static const SoftwareLayerParams enum_value = SoftwareLayerParams_ReshapeParams;
};

template<> struct SoftwareLayerParamsTraits<SoftmaxParams> {
  static const SoftwareLayerParams enum_value = SoftwareLayerParams_SoftmaxParams;
};

template<> struct SoftwareLayerParamsTraits<CustomLayerParams> {
  static const SoftwareLayerParams enum_value = SoftwareLayerParams_CustomLayerParams;
};

template<> struct SoftwareLayerParamsTraits<PassthroughParams> {
  static const SoftwareLayerParams enum_value = SoftwareLayerParams_PassthroughParams;
};

template<> struct SoftwareLayerParamsTraits<LayerRecordParams> {
  static const SoftwareLayerParams enum_value = SoftwareLayerParams_LayerRecordParams;
};

template<> struct SoftwareLayerParamsTraits<ROIPoolingParams> {
  static const SoftwareLayerParams enum_value = SoftwareLayerParams_ROIPoolingParams;
};

template<> struct SoftwareLayerParamsTraits<QuantizeParams> {
  static const SoftwareLayerParams enum_value = SoftwareLayerParams_QuantizeParams;
};

template<> struct SoftwareLayerParamsTraits<ArgMaxParams> {
  static const SoftwareLayerParams enum_value = SoftwareLayerParams_ArgMaxParams;
};

template<> struct SoftwareLayerParamsTraits<NormParams> {
  static const SoftwareLayerParams enum_value = SoftwareLayerParams_NormParams;
};

template<> struct SoftwareLayerParamsTraits<EltwiseParams> {
  static const SoftwareLayerParams enum_value = SoftwareLayerParams_EltwiseParams;
};

template<> struct SoftwareLayerParamsTraits<ResampleParams> {
  static const SoftwareLayerParams enum_value = SoftwareLayerParams_ResampleParams;
};

template<> struct SoftwareLayerParamsTraits<CorrelationParams> {
  static const SoftwareLayerParams enum_value = SoftwareLayerParams_CorrelationParams;
};

template<> struct SoftwareLayerParamsTraits<MVNParams> {
  static const SoftwareLayerParams enum_value = SoftwareLayerParams_MVNParams;
};

template<> struct SoftwareLayerParamsTraits<GRNParams> {
  static const SoftwareLayerParams enum_value = SoftwareLayerParams_GRNParams;
};

template<> struct SoftwareLayerParamsTraits<CTCDecoderParams> {
  static const SoftwareLayerParams enum_value = SoftwareLayerParams_CTCDecoderParams;
};

template<> struct SoftwareLayerParamsTraits<SpatialTransformParams> {
  static const SoftwareLayerParams enum_value = SoftwareLayerParams_SpatialTransformParams;
};

template<> struct SoftwareLayerParamsTraits<FakeQuantizeParams> {
  static const SoftwareLayerParams enum_value = SoftwareLayerParams_FakeQuantizeParams;
};

template<> struct SoftwareLayerParamsTraits<PoolingParams> {
  static const SoftwareLayerParams enum_value = SoftwareLayerParams_PoolingParams;
};

template<> struct SoftwareLayerParamsTraits<EdslParams> {
  static const SoftwareLayerParams enum_value = SoftwareLayerParams_EdslParams;
};

template<> struct SoftwareLayerParamsTraits<TileParams> {
  static const SoftwareLayerParams enum_value = SoftwareLayerParams_TileParams;
};

template<> struct SoftwareLayerParamsTraits<PSROIPoolingParams> {
  static const SoftwareLayerParams enum_value = SoftwareLayerParams_PSROIPoolingParams;
};

template<> struct SoftwareLayerParamsTraits<DeconvolutionParams> {
  static const SoftwareLayerParams enum_value = SoftwareLayerParams_DeconvolutionParams;
};

template<> struct SoftwareLayerParamsTraits<UnaryOpParams> {
  static const SoftwareLayerParams enum_value = SoftwareLayerParams_UnaryOpParams;
};

struct SoftwareLayerParamsUnion {
  SoftwareLayerParams type;
  void *value;

  SoftwareLayerParamsUnion() : type(SoftwareLayerParams_NONE), value(nullptr) {}
  SoftwareLayerParamsUnion(SoftwareLayerParamsUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(SoftwareLayerParams_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  SoftwareLayerParamsUnion(const SoftwareLayerParamsUnion &) FLATBUFFERS_NOEXCEPT;
  SoftwareLayerParamsUnion &operator=(const SoftwareLayerParamsUnion &u) FLATBUFFERS_NOEXCEPT
    { SoftwareLayerParamsUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  SoftwareLayerParamsUnion &operator=(SoftwareLayerParamsUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~SoftwareLayerParamsUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = SoftwareLayerParamsTraits<typename RT::TableType>::enum_value;
    if (type != SoftwareLayerParams_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, SoftwareLayerParams type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  DummyParamsT *AsDummyParams() {
    return type == SoftwareLayerParams_DummyParams ?
      reinterpret_cast<DummyParamsT *>(value) : nullptr;
  }
  const DummyParamsT *AsDummyParams() const {
    return type == SoftwareLayerParams_DummyParams ?
      reinterpret_cast<const DummyParamsT *>(value) : nullptr;
  }
  DetectionOutputParamsT *AsDetectionOutputParams() {
    return type == SoftwareLayerParams_DetectionOutputParams ?
      reinterpret_cast<DetectionOutputParamsT *>(value) : nullptr;
  }
  const DetectionOutputParamsT *AsDetectionOutputParams() const {
    return type == SoftwareLayerParams_DetectionOutputParams ?
      reinterpret_cast<const DetectionOutputParamsT *>(value) : nullptr;
  }
  FlattenParamsT *AsFlattenParams() {
    return type == SoftwareLayerParams_FlattenParams ?
      reinterpret_cast<FlattenParamsT *>(value) : nullptr;
  }
  const FlattenParamsT *AsFlattenParams() const {
    return type == SoftwareLayerParams_FlattenParams ?
      reinterpret_cast<const FlattenParamsT *>(value) : nullptr;
  }
  InterpParamsT *AsInterpParams() {
    return type == SoftwareLayerParams_InterpParams ?
      reinterpret_cast<InterpParamsT *>(value) : nullptr;
  }
  const InterpParamsT *AsInterpParams() const {
    return type == SoftwareLayerParams_InterpParams ?
      reinterpret_cast<const InterpParamsT *>(value) : nullptr;
  }
  NormalizeParamsT *AsNormalizeParams() {
    return type == SoftwareLayerParams_NormalizeParams ?
      reinterpret_cast<NormalizeParamsT *>(value) : nullptr;
  }
  const NormalizeParamsT *AsNormalizeParams() const {
    return type == SoftwareLayerParams_NormalizeParams ?
      reinterpret_cast<const NormalizeParamsT *>(value) : nullptr;
  }
  PermuteParamsT *AsPermuteParams() {
    return type == SoftwareLayerParams_PermuteParams ?
      reinterpret_cast<PermuteParamsT *>(value) : nullptr;
  }
  const PermuteParamsT *AsPermuteParams() const {
    return type == SoftwareLayerParams_PermuteParams ?
      reinterpret_cast<const PermuteParamsT *>(value) : nullptr;
  }
  PriorboxParamsT *AsPriorboxParams() {
    return type == SoftwareLayerParams_PriorboxParams ?
      reinterpret_cast<PriorboxParamsT *>(value) : nullptr;
  }
  const PriorboxParamsT *AsPriorboxParams() const {
    return type == SoftwareLayerParams_PriorboxParams ?
      reinterpret_cast<const PriorboxParamsT *>(value) : nullptr;
  }
  ProposalParamsT *AsProposalParams() {
    return type == SoftwareLayerParams_ProposalParams ?
      reinterpret_cast<ProposalParamsT *>(value) : nullptr;
  }
  const ProposalParamsT *AsProposalParams() const {
    return type == SoftwareLayerParams_ProposalParams ?
      reinterpret_cast<const ProposalParamsT *>(value) : nullptr;
  }
  RegionYOLOParamsT *AsRegionYOLOParams() {
    return type == SoftwareLayerParams_RegionYOLOParams ?
      reinterpret_cast<RegionYOLOParamsT *>(value) : nullptr;
  }
  const RegionYOLOParamsT *AsRegionYOLOParams() const {
    return type == SoftwareLayerParams_RegionYOLOParams ?
      reinterpret_cast<const RegionYOLOParamsT *>(value) : nullptr;
  }
  ReorgYOLOParamsT *AsReorgYOLOParams() {
    return type == SoftwareLayerParams_ReorgYOLOParams ?
      reinterpret_cast<ReorgYOLOParamsT *>(value) : nullptr;
  }
  const ReorgYOLOParamsT *AsReorgYOLOParams() const {
    return type == SoftwareLayerParams_ReorgYOLOParams ?
      reinterpret_cast<const ReorgYOLOParamsT *>(value) : nullptr;
  }
  ReshapeParamsT *AsReshapeParams() {
    return type == SoftwareLayerParams_ReshapeParams ?
      reinterpret_cast<ReshapeParamsT *>(value) : nullptr;
  }
  const ReshapeParamsT *AsReshapeParams() const {
    return type == SoftwareLayerParams_ReshapeParams ?
      reinterpret_cast<const ReshapeParamsT *>(value) : nullptr;
  }
  SoftmaxParamsT *AsSoftmaxParams() {
    return type == SoftwareLayerParams_SoftmaxParams ?
      reinterpret_cast<SoftmaxParamsT *>(value) : nullptr;
  }
  const SoftmaxParamsT *AsSoftmaxParams() const {
    return type == SoftwareLayerParams_SoftmaxParams ?
      reinterpret_cast<const SoftmaxParamsT *>(value) : nullptr;
  }
  CustomLayerParamsT *AsCustomLayerParams() {
    return type == SoftwareLayerParams_CustomLayerParams ?
      reinterpret_cast<CustomLayerParamsT *>(value) : nullptr;
  }
  const CustomLayerParamsT *AsCustomLayerParams() const {
    return type == SoftwareLayerParams_CustomLayerParams ?
      reinterpret_cast<const CustomLayerParamsT *>(value) : nullptr;
  }
  PassthroughParamsT *AsPassthroughParams() {
    return type == SoftwareLayerParams_PassthroughParams ?
      reinterpret_cast<PassthroughParamsT *>(value) : nullptr;
  }
  const PassthroughParamsT *AsPassthroughParams() const {
    return type == SoftwareLayerParams_PassthroughParams ?
      reinterpret_cast<const PassthroughParamsT *>(value) : nullptr;
  }
  LayerRecordParamsT *AsLayerRecordParams() {
    return type == SoftwareLayerParams_LayerRecordParams ?
      reinterpret_cast<LayerRecordParamsT *>(value) : nullptr;
  }
  const LayerRecordParamsT *AsLayerRecordParams() const {
    return type == SoftwareLayerParams_LayerRecordParams ?
      reinterpret_cast<const LayerRecordParamsT *>(value) : nullptr;
  }
  ROIPoolingParamsT *AsROIPoolingParams() {
    return type == SoftwareLayerParams_ROIPoolingParams ?
      reinterpret_cast<ROIPoolingParamsT *>(value) : nullptr;
  }
  const ROIPoolingParamsT *AsROIPoolingParams() const {
    return type == SoftwareLayerParams_ROIPoolingParams ?
      reinterpret_cast<const ROIPoolingParamsT *>(value) : nullptr;
  }
  QuantizeParamsT *AsQuantizeParams() {
    return type == SoftwareLayerParams_QuantizeParams ?
      reinterpret_cast<QuantizeParamsT *>(value) : nullptr;
  }
  const QuantizeParamsT *AsQuantizeParams() const {
    return type == SoftwareLayerParams_QuantizeParams ?
      reinterpret_cast<const QuantizeParamsT *>(value) : nullptr;
  }
  ArgMaxParamsT *AsArgMaxParams() {
    return type == SoftwareLayerParams_ArgMaxParams ?
      reinterpret_cast<ArgMaxParamsT *>(value) : nullptr;
  }
  const ArgMaxParamsT *AsArgMaxParams() const {
    return type == SoftwareLayerParams_ArgMaxParams ?
      reinterpret_cast<const ArgMaxParamsT *>(value) : nullptr;
  }
  NormParamsT *AsNormParams() {
    return type == SoftwareLayerParams_NormParams ?
      reinterpret_cast<NormParamsT *>(value) : nullptr;
  }
  const NormParamsT *AsNormParams() const {
    return type == SoftwareLayerParams_NormParams ?
      reinterpret_cast<const NormParamsT *>(value) : nullptr;
  }
  EltwiseParamsT *AsEltwiseParams() {
    return type == SoftwareLayerParams_EltwiseParams ?
      reinterpret_cast<EltwiseParamsT *>(value) : nullptr;
  }
  const EltwiseParamsT *AsEltwiseParams() const {
    return type == SoftwareLayerParams_EltwiseParams ?
      reinterpret_cast<const EltwiseParamsT *>(value) : nullptr;
  }
  ResampleParamsT *AsResampleParams() {
    return type == SoftwareLayerParams_ResampleParams ?
      reinterpret_cast<ResampleParamsT *>(value) : nullptr;
  }
  const ResampleParamsT *AsResampleParams() const {
    return type == SoftwareLayerParams_ResampleParams ?
      reinterpret_cast<const ResampleParamsT *>(value) : nullptr;
  }
  CorrelationParamsT *AsCorrelationParams() {
    return type == SoftwareLayerParams_CorrelationParams ?
      reinterpret_cast<CorrelationParamsT *>(value) : nullptr;
  }
  const CorrelationParamsT *AsCorrelationParams() const {
    return type == SoftwareLayerParams_CorrelationParams ?
      reinterpret_cast<const CorrelationParamsT *>(value) : nullptr;
  }
  MVNParamsT *AsMVNParams() {
    return type == SoftwareLayerParams_MVNParams ?
      reinterpret_cast<MVNParamsT *>(value) : nullptr;
  }
  const MVNParamsT *AsMVNParams() const {
    return type == SoftwareLayerParams_MVNParams ?
      reinterpret_cast<const MVNParamsT *>(value) : nullptr;
  }
  GRNParamsT *AsGRNParams() {
    return type == SoftwareLayerParams_GRNParams ?
      reinterpret_cast<GRNParamsT *>(value) : nullptr;
  }
  const GRNParamsT *AsGRNParams() const {
    return type == SoftwareLayerParams_GRNParams ?
      reinterpret_cast<const GRNParamsT *>(value) : nullptr;
  }
  CTCDecoderParamsT *AsCTCDecoderParams() {
    return type == SoftwareLayerParams_CTCDecoderParams ?
      reinterpret_cast<CTCDecoderParamsT *>(value) : nullptr;
  }
  const CTCDecoderParamsT *AsCTCDecoderParams() const {
    return type == SoftwareLayerParams_CTCDecoderParams ?
      reinterpret_cast<const CTCDecoderParamsT *>(value) : nullptr;
  }
  SpatialTransformParamsT *AsSpatialTransformParams() {
    return type == SoftwareLayerParams_SpatialTransformParams ?
      reinterpret_cast<SpatialTransformParamsT *>(value) : nullptr;
  }
  const SpatialTransformParamsT *AsSpatialTransformParams() const {
    return type == SoftwareLayerParams_SpatialTransformParams ?
      reinterpret_cast<const SpatialTransformParamsT *>(value) : nullptr;
  }
  FakeQuantizeParamsT *AsFakeQuantizeParams() {
    return type == SoftwareLayerParams_FakeQuantizeParams ?
      reinterpret_cast<FakeQuantizeParamsT *>(value) : nullptr;
  }
  const FakeQuantizeParamsT *AsFakeQuantizeParams() const {
    return type == SoftwareLayerParams_FakeQuantizeParams ?
      reinterpret_cast<const FakeQuantizeParamsT *>(value) : nullptr;
  }
  PoolingParamsT *AsPoolingParams() {
    return type == SoftwareLayerParams_PoolingParams ?
      reinterpret_cast<PoolingParamsT *>(value) : nullptr;
  }
  const PoolingParamsT *AsPoolingParams() const {
    return type == SoftwareLayerParams_PoolingParams ?
      reinterpret_cast<const PoolingParamsT *>(value) : nullptr;
  }
  EdslParamsT *AsEdslParams() {
    return type == SoftwareLayerParams_EdslParams ?
      reinterpret_cast<EdslParamsT *>(value) : nullptr;
  }
  const EdslParamsT *AsEdslParams() const {
    return type == SoftwareLayerParams_EdslParams ?
      reinterpret_cast<const EdslParamsT *>(value) : nullptr;
  }
  TileParamsT *AsTileParams() {
    return type == SoftwareLayerParams_TileParams ?
      reinterpret_cast<TileParamsT *>(value) : nullptr;
  }
  const TileParamsT *AsTileParams() const {
    return type == SoftwareLayerParams_TileParams ?
      reinterpret_cast<const TileParamsT *>(value) : nullptr;
  }
  PSROIPoolingParamsT *AsPSROIPoolingParams() {
    return type == SoftwareLayerParams_PSROIPoolingParams ?
      reinterpret_cast<PSROIPoolingParamsT *>(value) : nullptr;
  }
  const PSROIPoolingParamsT *AsPSROIPoolingParams() const {
    return type == SoftwareLayerParams_PSROIPoolingParams ?
      reinterpret_cast<const PSROIPoolingParamsT *>(value) : nullptr;
  }
  DeconvolutionParamsT *AsDeconvolutionParams() {
    return type == SoftwareLayerParams_DeconvolutionParams ?
      reinterpret_cast<DeconvolutionParamsT *>(value) : nullptr;
  }
  const DeconvolutionParamsT *AsDeconvolutionParams() const {
    return type == SoftwareLayerParams_DeconvolutionParams ?
      reinterpret_cast<const DeconvolutionParamsT *>(value) : nullptr;
  }
  UnaryOpParamsT *AsUnaryOpParams() {
    return type == SoftwareLayerParams_UnaryOpParams ?
      reinterpret_cast<UnaryOpParamsT *>(value) : nullptr;
  }
  const UnaryOpParamsT *AsUnaryOpParams() const {
    return type == SoftwareLayerParams_UnaryOpParams ?
      reinterpret_cast<const UnaryOpParamsT *>(value) : nullptr;
  }
};

bool VerifySoftwareLayerParams(flatbuffers::Verifier &verifier, const void *obj, SoftwareLayerParams type);
bool VerifySoftwareLayerParamsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum SoftwareLayer {
  SoftwareLayer_NONE = 0,
  SoftwareLayer_Conv2D = 1,
  SoftwareLayer_Pooling = 2,
  SoftwareLayer_ReLU = 3,
  SoftwareLayer_Passthrough = 4,
  SoftwareLayer_Custom = 5,
  SoftwareLayer_MIN = SoftwareLayer_NONE,
  SoftwareLayer_MAX = SoftwareLayer_Custom
};

inline const SoftwareLayer (&EnumValuesSoftwareLayer())[6] {
  static const SoftwareLayer values[] = {
    SoftwareLayer_NONE,
    SoftwareLayer_Conv2D,
    SoftwareLayer_Pooling,
    SoftwareLayer_ReLU,
    SoftwareLayer_Passthrough,
    SoftwareLayer_Custom
  };
  return values;
}

inline const char * const *EnumNamesSoftwareLayer() {
  static const char * const names[] = {
    "NONE",
    "Conv2D",
    "Pooling",
    "ReLU",
    "Passthrough",
    "Custom",
    nullptr
  };
  return names;
}

inline const char *EnumNameSoftwareLayer(SoftwareLayer e) {
  if (e < SoftwareLayer_NONE || e > SoftwareLayer_Custom) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSoftwareLayer()[index];
}

template<typename T> struct SoftwareLayerTraits {
  static const SoftwareLayer enum_value = SoftwareLayer_NONE;
};

template<> struct SoftwareLayerTraits<Conv2D> {
  static const SoftwareLayer enum_value = SoftwareLayer_Conv2D;
};

template<> struct SoftwareLayerTraits<Pooling> {
  static const SoftwareLayer enum_value = SoftwareLayer_Pooling;
};

template<> struct SoftwareLayerTraits<ReLU> {
  static const SoftwareLayer enum_value = SoftwareLayer_ReLU;
};

template<> struct SoftwareLayerTraits<Passthrough> {
  static const SoftwareLayer enum_value = SoftwareLayer_Passthrough;
};

template<> struct SoftwareLayerTraits<Custom> {
  static const SoftwareLayer enum_value = SoftwareLayer_Custom;
};

struct SoftwareLayerUnion {
  SoftwareLayer type;
  void *value;

  SoftwareLayerUnion() : type(SoftwareLayer_NONE), value(nullptr) {}
  SoftwareLayerUnion(SoftwareLayerUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(SoftwareLayer_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  SoftwareLayerUnion(const SoftwareLayerUnion &) FLATBUFFERS_NOEXCEPT;
  SoftwareLayerUnion &operator=(const SoftwareLayerUnion &u) FLATBUFFERS_NOEXCEPT
    { SoftwareLayerUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  SoftwareLayerUnion &operator=(SoftwareLayerUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~SoftwareLayerUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = SoftwareLayerTraits<typename RT::TableType>::enum_value;
    if (type != SoftwareLayer_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, SoftwareLayer type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  Conv2DT *AsConv2D() {
    return type == SoftwareLayer_Conv2D ?
      reinterpret_cast<Conv2DT *>(value) : nullptr;
  }
  const Conv2DT *AsConv2D() const {
    return type == SoftwareLayer_Conv2D ?
      reinterpret_cast<const Conv2DT *>(value) : nullptr;
  }
  PoolingT *AsPooling() {
    return type == SoftwareLayer_Pooling ?
      reinterpret_cast<PoolingT *>(value) : nullptr;
  }
  const PoolingT *AsPooling() const {
    return type == SoftwareLayer_Pooling ?
      reinterpret_cast<const PoolingT *>(value) : nullptr;
  }
  ReLUT *AsReLU() {
    return type == SoftwareLayer_ReLU ?
      reinterpret_cast<ReLUT *>(value) : nullptr;
  }
  const ReLUT *AsReLU() const {
    return type == SoftwareLayer_ReLU ?
      reinterpret_cast<const ReLUT *>(value) : nullptr;
  }
  PassthroughT *AsPassthrough() {
    return type == SoftwareLayer_Passthrough ?
      reinterpret_cast<PassthroughT *>(value) : nullptr;
  }
  const PassthroughT *AsPassthrough() const {
    return type == SoftwareLayer_Passthrough ?
      reinterpret_cast<const PassthroughT *>(value) : nullptr;
  }
  CustomT *AsCustom() {
    return type == SoftwareLayer_Custom ?
      reinterpret_cast<CustomT *>(value) : nullptr;
  }
  const CustomT *AsCustom() const {
    return type == SoftwareLayer_Custom ?
      reinterpret_cast<const CustomT *>(value) : nullptr;
  }
};

bool VerifySoftwareLayer(flatbuffers::Verifier &verifier, const void *obj, SoftwareLayer type);
bool VerifySoftwareLayerVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum NNHelper {
  NNHelper_NONE = 0,
  NNHelper_PPEConfigure = 1,
  NNHelper_PPEAssist = 2,
  NNHelper_MIN = NNHelper_NONE,
  NNHelper_MAX = NNHelper_PPEAssist
};

inline const NNHelper (&EnumValuesNNHelper())[3] {
  static const NNHelper values[] = {
    NNHelper_NONE,
    NNHelper_PPEConfigure,
    NNHelper_PPEAssist
  };
  return values;
}

inline const char * const *EnumNamesNNHelper() {
  static const char * const names[] = {
    "NONE",
    "PPEConfigure",
    "PPEAssist",
    nullptr
  };
  return names;
}

inline const char *EnumNameNNHelper(NNHelper e) {
  if (e < NNHelper_NONE || e > NNHelper_PPEAssist) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNNHelper()[index];
}

template<typename T> struct NNHelperTraits {
  static const NNHelper enum_value = NNHelper_NONE;
};

template<> struct NNHelperTraits<PPEConfigure> {
  static const NNHelper enum_value = NNHelper_PPEConfigure;
};

template<> struct NNHelperTraits<PPEAssist> {
  static const NNHelper enum_value = NNHelper_PPEAssist;
};

struct NNHelperUnion {
  NNHelper type;
  void *value;

  NNHelperUnion() : type(NNHelper_NONE), value(nullptr) {}
  NNHelperUnion(NNHelperUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(NNHelper_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  NNHelperUnion(const NNHelperUnion &) FLATBUFFERS_NOEXCEPT;
  NNHelperUnion &operator=(const NNHelperUnion &u) FLATBUFFERS_NOEXCEPT
    { NNHelperUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  NNHelperUnion &operator=(NNHelperUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~NNHelperUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = NNHelperTraits<typename RT::TableType>::enum_value;
    if (type != NNHelper_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, NNHelper type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  PPEConfigureT *AsPPEConfigure() {
    return type == NNHelper_PPEConfigure ?
      reinterpret_cast<PPEConfigureT *>(value) : nullptr;
  }
  const PPEConfigureT *AsPPEConfigure() const {
    return type == NNHelper_PPEConfigure ?
      reinterpret_cast<const PPEConfigureT *>(value) : nullptr;
  }
  PPEAssistT *AsPPEAssist() {
    return type == NNHelper_PPEAssist ?
      reinterpret_cast<PPEAssistT *>(value) : nullptr;
  }
  const PPEAssistT *AsPPEAssist() const {
    return type == NNHelper_PPEAssist ?
      reinterpret_cast<const PPEAssistT *>(value) : nullptr;
  }
};

bool VerifyNNHelper(flatbuffers::Verifier &verifier, const void *obj, NNHelper type);
bool VerifyNNHelperVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

/// Generally modeled around v2 infrastructure for software layers.
FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) order3 FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t x_;
  uint8_t y_;
  uint8_t z_;

 public:
  order3() {
    memset(static_cast<void *>(this), 0, sizeof(order3));
  }
  order3(uint8_t _x, uint8_t _y, uint8_t _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  uint8_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  uint8_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
  uint8_t z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(order3, 3);

struct QuantizeParamsT : public flatbuffers::NativeTable {
  typedef QuantizeParams TableType;
  std::vector<uint16_t> scale;
  std::vector<uint16_t> zero;
  QuantizeParamsT() {
  }
};

struct QuantizeParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QuantizeParamsT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCALE = 4,
    VT_ZERO = 6
  };
  const flatbuffers::Vector<uint16_t> *scale() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_SCALE);
  }
  const flatbuffers::Vector<uint16_t> *zero() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_ZERO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SCALE) &&
           verifier.VerifyVector(scale()) &&
           VerifyOffset(verifier, VT_ZERO) &&
           verifier.VerifyVector(zero()) &&
           verifier.EndTable();
  }
  QuantizeParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(QuantizeParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<QuantizeParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantizeParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct QuantizeParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scale(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> scale) {
    fbb_.AddOffset(QuantizeParams::VT_SCALE, scale);
  }
  void add_zero(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> zero) {
    fbb_.AddOffset(QuantizeParams::VT_ZERO, zero);
  }
  explicit QuantizeParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuantizeParamsBuilder &operator=(const QuantizeParamsBuilder &);
  flatbuffers::Offset<QuantizeParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuantizeParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuantizeParams> CreateQuantizeParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> scale = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> zero = 0) {
  QuantizeParamsBuilder builder_(_fbb);
  builder_.add_zero(zero);
  builder_.add_scale(scale);
  return builder_.Finish();
}

inline flatbuffers::Offset<QuantizeParams> CreateQuantizeParamsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint16_t> *scale = nullptr,
    const std::vector<uint16_t> *zero = nullptr) {
  auto scale__ = scale ? _fbb.CreateVector<uint16_t>(*scale) : 0;
  auto zero__ = zero ? _fbb.CreateVector<uint16_t>(*zero) : 0;
  return MVCNN::CreateQuantizeParams(
      _fbb,
      scale__,
      zero__);
}

flatbuffers::Offset<QuantizeParams> CreateQuantizeParams(flatbuffers::FlatBufferBuilder &_fbb, const QuantizeParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DummyParamsT : public flatbuffers::NativeTable {
  typedef DummyParams TableType;
  std::string message;
  bool executeShaveKernel;
  DummyParamsT()
      : executeShaveKernel(false) {
  }
};

struct DummyParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DummyParamsT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE = 4,
    VT_EXECUTESHAVEKERNEL = 6
  };
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  bool executeShaveKernel() const {
    return GetField<uint8_t>(VT_EXECUTESHAVEKERNEL, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           VerifyField<uint8_t>(verifier, VT_EXECUTESHAVEKERNEL) &&
           verifier.EndTable();
  }
  DummyParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DummyParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DummyParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DummyParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DummyParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(DummyParams::VT_MESSAGE, message);
  }
  void add_executeShaveKernel(bool executeShaveKernel) {
    fbb_.AddElement<uint8_t>(DummyParams::VT_EXECUTESHAVEKERNEL, static_cast<uint8_t>(executeShaveKernel), 0);
  }
  explicit DummyParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DummyParamsBuilder &operator=(const DummyParamsBuilder &);
  flatbuffers::Offset<DummyParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DummyParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<DummyParams> CreateDummyParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> message = 0,
    bool executeShaveKernel = false) {
  DummyParamsBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_executeShaveKernel(executeShaveKernel);
  return builder_.Finish();
}

inline flatbuffers::Offset<DummyParams> CreateDummyParamsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *message = nullptr,
    bool executeShaveKernel = false) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return MVCNN::CreateDummyParams(
      _fbb,
      message__,
      executeShaveKernel);
}

flatbuffers::Offset<DummyParams> CreateDummyParams(flatbuffers::FlatBufferBuilder &_fbb, const DummyParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DetectionOutputParamsT : public flatbuffers::NativeTable {
  typedef DetectionOutputParams TableType;
  int32_t num_classes;
  int32_t keep_top_k;
  float nms_threshold;
  int32_t background_label_id;
  int32_t top_k;
  bool variance_encoded_in_target;
  std::string code_type;
  bool share_location;
  float confidence_threshold;
  bool clip_before_nms;
  bool clip_after_nms;
  int32_t decrease_label_id;
  bool normalized;
  int32_t input_height;
  int32_t input_width;
  float objectness_score;
  DetectionOutputParamsT()
      : num_classes(0),
        keep_top_k(-1),
        nms_threshold(0.0f),
        background_label_id(0),
        top_k(-1),
        variance_encoded_in_target(false),
        share_location(true),
        confidence_threshold(-65504.0f),
        clip_before_nms(false),
        clip_after_nms(false),
        decrease_label_id(0),
        normalized(false),
        input_height(1),
        input_width(1),
        objectness_score(0.0f) {
  }
};

struct DetectionOutputParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DetectionOutputParamsT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM_CLASSES = 4,
    VT_KEEP_TOP_K = 6,
    VT_NMS_THRESHOLD = 8,
    VT_BACKGROUND_LABEL_ID = 10,
    VT_TOP_K = 12,
    VT_VARIANCE_ENCODED_IN_TARGET = 14,
    VT_CODE_TYPE = 16,
    VT_SHARE_LOCATION = 18,
    VT_CONFIDENCE_THRESHOLD = 20,
    VT_CLIP_BEFORE_NMS = 22,
    VT_CLIP_AFTER_NMS = 24,
    VT_DECREASE_LABEL_ID = 26,
    VT_NORMALIZED = 28,
    VT_INPUT_HEIGHT = 30,
    VT_INPUT_WIDTH = 32,
    VT_OBJECTNESS_SCORE = 34
  };
  int32_t num_classes() const {
    return GetField<int32_t>(VT_NUM_CLASSES, 0);
  }
  int32_t keep_top_k() const {
    return GetField<int32_t>(VT_KEEP_TOP_K, -1);
  }
  float nms_threshold() const {
    return GetField<float>(VT_NMS_THRESHOLD, 0.0f);
  }
  int32_t background_label_id() const {
    return GetField<int32_t>(VT_BACKGROUND_LABEL_ID, 0);
  }
  int32_t top_k() const {
    return GetField<int32_t>(VT_TOP_K, -1);
  }
  bool variance_encoded_in_target() const {
    return GetField<uint8_t>(VT_VARIANCE_ENCODED_IN_TARGET, 0) != 0;
  }
  const flatbuffers::String *code_type() const {
    return GetPointer<const flatbuffers::String *>(VT_CODE_TYPE);
  }
  bool share_location() const {
    return GetField<uint8_t>(VT_SHARE_LOCATION, 1) != 0;
  }
  float confidence_threshold() const {
    return GetField<float>(VT_CONFIDENCE_THRESHOLD, -65504.0f);
  }
  bool clip_before_nms() const {
    return GetField<uint8_t>(VT_CLIP_BEFORE_NMS, 0) != 0;
  }
  bool clip_after_nms() const {
    return GetField<uint8_t>(VT_CLIP_AFTER_NMS, 0) != 0;
  }
  int32_t decrease_label_id() const {
    return GetField<int32_t>(VT_DECREASE_LABEL_ID, 0);
  }
  bool normalized() const {
    return GetField<uint8_t>(VT_NORMALIZED, 0) != 0;
  }
  int32_t input_height() const {
    return GetField<int32_t>(VT_INPUT_HEIGHT, 1);
  }
  int32_t input_width() const {
    return GetField<int32_t>(VT_INPUT_WIDTH, 1);
  }
  float objectness_score() const {
    return GetField<float>(VT_OBJECTNESS_SCORE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM_CLASSES) &&
           VerifyField<int32_t>(verifier, VT_KEEP_TOP_K) &&
           VerifyField<float>(verifier, VT_NMS_THRESHOLD) &&
           VerifyField<int32_t>(verifier, VT_BACKGROUND_LABEL_ID) &&
           VerifyField<int32_t>(verifier, VT_TOP_K) &&
           VerifyField<uint8_t>(verifier, VT_VARIANCE_ENCODED_IN_TARGET) &&
           VerifyOffset(verifier, VT_CODE_TYPE) &&
           verifier.VerifyString(code_type()) &&
           VerifyField<uint8_t>(verifier, VT_SHARE_LOCATION) &&
           VerifyField<float>(verifier, VT_CONFIDENCE_THRESHOLD) &&
           VerifyField<uint8_t>(verifier, VT_CLIP_BEFORE_NMS) &&
           VerifyField<uint8_t>(verifier, VT_CLIP_AFTER_NMS) &&
           VerifyField<int32_t>(verifier, VT_DECREASE_LABEL_ID) &&
           VerifyField<uint8_t>(verifier, VT_NORMALIZED) &&
           VerifyField<int32_t>(verifier, VT_INPUT_HEIGHT) &&
           VerifyField<int32_t>(verifier, VT_INPUT_WIDTH) &&
           VerifyField<float>(verifier, VT_OBJECTNESS_SCORE) &&
           verifier.EndTable();
  }
  DetectionOutputParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DetectionOutputParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DetectionOutputParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DetectionOutputParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DetectionOutputParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_classes(int32_t num_classes) {
    fbb_.AddElement<int32_t>(DetectionOutputParams::VT_NUM_CLASSES, num_classes, 0);
  }
  void add_keep_top_k(int32_t keep_top_k) {
    fbb_.AddElement<int32_t>(DetectionOutputParams::VT_KEEP_TOP_K, keep_top_k, -1);
  }
  void add_nms_threshold(float nms_threshold) {
    fbb_.AddElement<float>(DetectionOutputParams::VT_NMS_THRESHOLD, nms_threshold, 0.0f);
  }
  void add_background_label_id(int32_t background_label_id) {
    fbb_.AddElement<int32_t>(DetectionOutputParams::VT_BACKGROUND_LABEL_ID, background_label_id, 0);
  }
  void add_top_k(int32_t top_k) {
    fbb_.AddElement<int32_t>(DetectionOutputParams::VT_TOP_K, top_k, -1);
  }
  void add_variance_encoded_in_target(bool variance_encoded_in_target) {
    fbb_.AddElement<uint8_t>(DetectionOutputParams::VT_VARIANCE_ENCODED_IN_TARGET, static_cast<uint8_t>(variance_encoded_in_target), 0);
  }
  void add_code_type(flatbuffers::Offset<flatbuffers::String> code_type) {
    fbb_.AddOffset(DetectionOutputParams::VT_CODE_TYPE, code_type);
  }
  void add_share_location(bool share_location) {
    fbb_.AddElement<uint8_t>(DetectionOutputParams::VT_SHARE_LOCATION, static_cast<uint8_t>(share_location), 1);
  }
  void add_confidence_threshold(float confidence_threshold) {
    fbb_.AddElement<float>(DetectionOutputParams::VT_CONFIDENCE_THRESHOLD, confidence_threshold, -65504.0f);
  }
  void add_clip_before_nms(bool clip_before_nms) {
    fbb_.AddElement<uint8_t>(DetectionOutputParams::VT_CLIP_BEFORE_NMS, static_cast<uint8_t>(clip_before_nms), 0);
  }
  void add_clip_after_nms(bool clip_after_nms) {
    fbb_.AddElement<uint8_t>(DetectionOutputParams::VT_CLIP_AFTER_NMS, static_cast<uint8_t>(clip_after_nms), 0);
  }
  void add_decrease_label_id(int32_t decrease_label_id) {
    fbb_.AddElement<int32_t>(DetectionOutputParams::VT_DECREASE_LABEL_ID, decrease_label_id, 0);
  }
  void add_normalized(bool normalized) {
    fbb_.AddElement<uint8_t>(DetectionOutputParams::VT_NORMALIZED, static_cast<uint8_t>(normalized), 0);
  }
  void add_input_height(int32_t input_height) {
    fbb_.AddElement<int32_t>(DetectionOutputParams::VT_INPUT_HEIGHT, input_height, 1);
  }
  void add_input_width(int32_t input_width) {
    fbb_.AddElement<int32_t>(DetectionOutputParams::VT_INPUT_WIDTH, input_width, 1);
  }
  void add_objectness_score(float objectness_score) {
    fbb_.AddElement<float>(DetectionOutputParams::VT_OBJECTNESS_SCORE, objectness_score, 0.0f);
  }
  explicit DetectionOutputParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DetectionOutputParamsBuilder &operator=(const DetectionOutputParamsBuilder &);
  flatbuffers::Offset<DetectionOutputParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DetectionOutputParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<DetectionOutputParams> CreateDetectionOutputParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_classes = 0,
    int32_t keep_top_k = -1,
    float nms_threshold = 0.0f,
    int32_t background_label_id = 0,
    int32_t top_k = -1,
    bool variance_encoded_in_target = false,
    flatbuffers::Offset<flatbuffers::String> code_type = 0,
    bool share_location = true,
    float confidence_threshold = -65504.0f,
    bool clip_before_nms = false,
    bool clip_after_nms = false,
    int32_t decrease_label_id = 0,
    bool normalized = false,
    int32_t input_height = 1,
    int32_t input_width = 1,
    float objectness_score = 0.0f) {
  DetectionOutputParamsBuilder builder_(_fbb);
  builder_.add_objectness_score(objectness_score);
  builder_.add_input_width(input_width);
  builder_.add_input_height(input_height);
  builder_.add_decrease_label_id(decrease_label_id);
  builder_.add_confidence_threshold(confidence_threshold);
  builder_.add_code_type(code_type);
  builder_.add_top_k(top_k);
  builder_.add_background_label_id(background_label_id);
  builder_.add_nms_threshold(nms_threshold);
  builder_.add_keep_top_k(keep_top_k);
  builder_.add_num_classes(num_classes);
  builder_.add_normalized(normalized);
  builder_.add_clip_after_nms(clip_after_nms);
  builder_.add_clip_before_nms(clip_before_nms);
  builder_.add_share_location(share_location);
  builder_.add_variance_encoded_in_target(variance_encoded_in_target);
  return builder_.Finish();
}

inline flatbuffers::Offset<DetectionOutputParams> CreateDetectionOutputParamsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_classes = 0,
    int32_t keep_top_k = -1,
    float nms_threshold = 0.0f,
    int32_t background_label_id = 0,
    int32_t top_k = -1,
    bool variance_encoded_in_target = false,
    const char *code_type = nullptr,
    bool share_location = true,
    float confidence_threshold = -65504.0f,
    bool clip_before_nms = false,
    bool clip_after_nms = false,
    int32_t decrease_label_id = 0,
    bool normalized = false,
    int32_t input_height = 1,
    int32_t input_width = 1,
    float objectness_score = 0.0f) {
  auto code_type__ = code_type ? _fbb.CreateString(code_type) : 0;
  return MVCNN::CreateDetectionOutputParams(
      _fbb,
      num_classes,
      keep_top_k,
      nms_threshold,
      background_label_id,
      top_k,
      variance_encoded_in_target,
      code_type__,
      share_location,
      confidence_threshold,
      clip_before_nms,
      clip_after_nms,
      decrease_label_id,
      normalized,
      input_height,
      input_width,
      objectness_score);
}

flatbuffers::Offset<DetectionOutputParams> CreateDetectionOutputParams(flatbuffers::FlatBufferBuilder &_fbb, const DetectionOutputParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DeconvolutionParamsT : public flatbuffers::NativeTable {
  typedef DeconvolutionParams TableType;
  std::unique_ptr<order3> kernel;
  std::unique_ptr<order3> strides;
  std::unique_ptr<order3> dilations;
  std::unique_ptr<order3> pads_begin;
  std::unique_ptr<order3> pads_end;
  std::unique_ptr<order3> output_padding;
  bool is_depthwise;
  DeconvolutionParamsT()
      : is_depthwise(false) {
  }
};

struct DeconvolutionParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeconvolutionParamsT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KERNEL = 4,
    VT_STRIDES = 6,
    VT_DILATIONS = 8,
    VT_PADS_BEGIN = 10,
    VT_PADS_END = 12,
    VT_OUTPUT_PADDING = 14,
    VT_IS_DEPTHWISE = 16
  };
  const order3 *kernel() const {
    return GetStruct<const order3 *>(VT_KERNEL);
  }
  const order3 *strides() const {
    return GetStruct<const order3 *>(VT_STRIDES);
  }
  const order3 *dilations() const {
    return GetStruct<const order3 *>(VT_DILATIONS);
  }
  const order3 *pads_begin() const {
    return GetStruct<const order3 *>(VT_PADS_BEGIN);
  }
  const order3 *pads_end() const {
    return GetStruct<const order3 *>(VT_PADS_END);
  }
  const order3 *output_padding() const {
    return GetStruct<const order3 *>(VT_OUTPUT_PADDING);
  }
  bool is_depthwise() const {
    return GetField<uint8_t>(VT_IS_DEPTHWISE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<order3>(verifier, VT_KERNEL) &&
           VerifyField<order3>(verifier, VT_STRIDES) &&
           VerifyField<order3>(verifier, VT_DILATIONS) &&
           VerifyField<order3>(verifier, VT_PADS_BEGIN) &&
           VerifyField<order3>(verifier, VT_PADS_END) &&
           VerifyField<order3>(verifier, VT_OUTPUT_PADDING) &&
           VerifyField<uint8_t>(verifier, VT_IS_DEPTHWISE) &&
           verifier.EndTable();
  }
  DeconvolutionParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DeconvolutionParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DeconvolutionParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DeconvolutionParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DeconvolutionParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kernel(const order3 *kernel) {
    fbb_.AddStruct(DeconvolutionParams::VT_KERNEL, kernel);
  }
  void add_strides(const order3 *strides) {
    fbb_.AddStruct(DeconvolutionParams::VT_STRIDES, strides);
  }
  void add_dilations(const order3 *dilations) {
    fbb_.AddStruct(DeconvolutionParams::VT_DILATIONS, dilations);
  }
  void add_pads_begin(const order3 *pads_begin) {
    fbb_.AddStruct(DeconvolutionParams::VT_PADS_BEGIN, pads_begin);
  }
  void add_pads_end(const order3 *pads_end) {
    fbb_.AddStruct(DeconvolutionParams::VT_PADS_END, pads_end);
  }
  void add_output_padding(const order3 *output_padding) {
    fbb_.AddStruct(DeconvolutionParams::VT_OUTPUT_PADDING, output_padding);
  }
  void add_is_depthwise(bool is_depthwise) {
    fbb_.AddElement<uint8_t>(DeconvolutionParams::VT_IS_DEPTHWISE, static_cast<uint8_t>(is_depthwise), 0);
  }
  explicit DeconvolutionParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeconvolutionParamsBuilder &operator=(const DeconvolutionParamsBuilder &);
  flatbuffers::Offset<DeconvolutionParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeconvolutionParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeconvolutionParams> CreateDeconvolutionParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    const order3 *kernel = 0,
    const order3 *strides = 0,
    const order3 *dilations = 0,
    const order3 *pads_begin = 0,
    const order3 *pads_end = 0,
    const order3 *output_padding = 0,
    bool is_depthwise = false) {
  DeconvolutionParamsBuilder builder_(_fbb);
  builder_.add_output_padding(output_padding);
  builder_.add_pads_end(pads_end);
  builder_.add_pads_begin(pads_begin);
  builder_.add_dilations(dilations);
  builder_.add_strides(strides);
  builder_.add_kernel(kernel);
  builder_.add_is_depthwise(is_depthwise);
  return builder_.Finish();
}

flatbuffers::Offset<DeconvolutionParams> CreateDeconvolutionParams(flatbuffers::FlatBufferBuilder &_fbb, const DeconvolutionParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlattenParamsT : public flatbuffers::NativeTable {
  typedef FlattenParams TableType;
  FlattenParamsT() {
  }
};

struct FlattenParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FlattenParamsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  FlattenParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlattenParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FlattenParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlattenParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FlattenParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FlattenParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FlattenParamsBuilder &operator=(const FlattenParamsBuilder &);
  flatbuffers::Offset<FlattenParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FlattenParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<FlattenParams> CreateFlattenParams(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FlattenParamsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<FlattenParams> CreateFlattenParams(flatbuffers::FlatBufferBuilder &_fbb, const FlattenParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InterpParamsT : public flatbuffers::NativeTable {
  typedef InterpParams TableType;
  uint32_t pad_beg;
  uint32_t pad_end;
  bool align_corners;
  InterpParamsT()
      : pad_beg(0),
        pad_end(0),
        align_corners(true) {
  }
};

struct InterpParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InterpParamsT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAD_BEG = 4,
    VT_PAD_END = 6,
    VT_ALIGN_CORNERS = 8
  };
  uint32_t pad_beg() const {
    return GetField<uint32_t>(VT_PAD_BEG, 0);
  }
  uint32_t pad_end() const {
    return GetField<uint32_t>(VT_PAD_END, 0);
  }
  bool align_corners() const {
    return GetField<uint8_t>(VT_ALIGN_CORNERS, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PAD_BEG) &&
           VerifyField<uint32_t>(verifier, VT_PAD_END) &&
           VerifyField<uint8_t>(verifier, VT_ALIGN_CORNERS) &&
           verifier.EndTable();
  }
  InterpParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InterpParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InterpParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InterpParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InterpParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pad_beg(uint32_t pad_beg) {
    fbb_.AddElement<uint32_t>(InterpParams::VT_PAD_BEG, pad_beg, 0);
  }
  void add_pad_end(uint32_t pad_end) {
    fbb_.AddElement<uint32_t>(InterpParams::VT_PAD_END, pad_end, 0);
  }
  void add_align_corners(bool align_corners) {
    fbb_.AddElement<uint8_t>(InterpParams::VT_ALIGN_CORNERS, static_cast<uint8_t>(align_corners), 1);
  }
  explicit InterpParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InterpParamsBuilder &operator=(const InterpParamsBuilder &);
  flatbuffers::Offset<InterpParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InterpParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<InterpParams> CreateInterpParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t pad_beg = 0,
    uint32_t pad_end = 0,
    bool align_corners = true) {
  InterpParamsBuilder builder_(_fbb);
  builder_.add_pad_end(pad_end);
  builder_.add_pad_beg(pad_beg);
  builder_.add_align_corners(align_corners);
  return builder_.Finish();
}

flatbuffers::Offset<InterpParams> CreateInterpParams(flatbuffers::FlatBufferBuilder &_fbb, const InterpParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NormalizeParamsT : public flatbuffers::NativeTable {
  typedef NormalizeParams TableType;
  float eps;
  int32_t across_spatial;
  int32_t channel_shared;
  NormalizeParamsT()
      : eps(0.0f),
        across_spatial(0),
        channel_shared(0) {
  }
};

struct NormalizeParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NormalizeParamsT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EPS = 4,
    VT_ACROSS_SPATIAL = 6,
    VT_CHANNEL_SHARED = 8
  };
  float eps() const {
    return GetField<float>(VT_EPS, 0.0f);
  }
  int32_t across_spatial() const {
    return GetField<int32_t>(VT_ACROSS_SPATIAL, 0);
  }
  int32_t channel_shared() const {
    return GetField<int32_t>(VT_CHANNEL_SHARED, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_EPS) &&
           VerifyField<int32_t>(verifier, VT_ACROSS_SPATIAL) &&
           VerifyField<int32_t>(verifier, VT_CHANNEL_SHARED) &&
           verifier.EndTable();
  }
  NormalizeParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NormalizeParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NormalizeParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NormalizeParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NormalizeParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eps(float eps) {
    fbb_.AddElement<float>(NormalizeParams::VT_EPS, eps, 0.0f);
  }
  void add_across_spatial(int32_t across_spatial) {
    fbb_.AddElement<int32_t>(NormalizeParams::VT_ACROSS_SPATIAL, across_spatial, 0);
  }
  void add_channel_shared(int32_t channel_shared) {
    fbb_.AddElement<int32_t>(NormalizeParams::VT_CHANNEL_SHARED, channel_shared, 0);
  }
  explicit NormalizeParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NormalizeParamsBuilder &operator=(const NormalizeParamsBuilder &);
  flatbuffers::Offset<NormalizeParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NormalizeParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<NormalizeParams> CreateNormalizeParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    float eps = 0.0f,
    int32_t across_spatial = 0,
    int32_t channel_shared = 0) {
  NormalizeParamsBuilder builder_(_fbb);
  builder_.add_channel_shared(channel_shared);
  builder_.add_across_spatial(across_spatial);
  builder_.add_eps(eps);
  return builder_.Finish();
}

flatbuffers::Offset<NormalizeParams> CreateNormalizeParams(flatbuffers::FlatBufferBuilder &_fbb, const NormalizeParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PermuteParamsT : public flatbuffers::NativeTable {
  typedef PermuteParams TableType;
  std::unique_ptr<order3> permute_order;
  PermuteParamsT() {
  }
};

struct PermuteParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PermuteParamsT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PERMUTE_ORDER = 4
  };
  const order3 *permute_order() const {
    return GetStruct<const order3 *>(VT_PERMUTE_ORDER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<order3>(verifier, VT_PERMUTE_ORDER) &&
           verifier.EndTable();
  }
  PermuteParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PermuteParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PermuteParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PermuteParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PermuteParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_permute_order(const order3 *permute_order) {
    fbb_.AddStruct(PermuteParams::VT_PERMUTE_ORDER, permute_order);
  }
  explicit PermuteParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PermuteParamsBuilder &operator=(const PermuteParamsBuilder &);
  flatbuffers::Offset<PermuteParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PermuteParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<PermuteParams> CreatePermuteParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    const order3 *permute_order = 0) {
  PermuteParamsBuilder builder_(_fbb);
  builder_.add_permute_order(permute_order);
  return builder_.Finish();
}

flatbuffers::Offset<PermuteParams> CreatePermuteParams(flatbuffers::FlatBufferBuilder &_fbb, const PermuteParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PriorboxParamsT : public flatbuffers::NativeTable {
  typedef PriorboxParams TableType;
  std::vector<float> min_sizes;
  std::vector<float> max_sizes;
  std::vector<float> aspect_ratios;
  std::vector<float> variances;
  uint32_t flip;
  uint32_t clip;
  float step_w;
  float step_h;
  float offset;
  PriorboxParamsT()
      : flip(0),
        clip(0),
        step_w(0.0f),
        step_h(0.0f),
        offset(0.0f) {
  }
};

struct PriorboxParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PriorboxParamsT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN_SIZES = 4,
    VT_MAX_SIZES = 6,
    VT_ASPECT_RATIOS = 8,
    VT_VARIANCES = 10,
    VT_FLIP = 12,
    VT_CLIP = 14,
    VT_STEP_W = 16,
    VT_STEP_H = 18,
    VT_OFFSET = 20
  };
  const flatbuffers::Vector<float> *min_sizes() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_MIN_SIZES);
  }
  const flatbuffers::Vector<float> *max_sizes() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_MAX_SIZES);
  }
  const flatbuffers::Vector<float> *aspect_ratios() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_ASPECT_RATIOS);
  }
  const flatbuffers::Vector<float> *variances() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_VARIANCES);
  }
  uint32_t flip() const {
    return GetField<uint32_t>(VT_FLIP, 0);
  }
  uint32_t clip() const {
    return GetField<uint32_t>(VT_CLIP, 0);
  }
  float step_w() const {
    return GetField<float>(VT_STEP_W, 0.0f);
  }
  float step_h() const {
    return GetField<float>(VT_STEP_H, 0.0f);
  }
  float offset() const {
    return GetField<float>(VT_OFFSET, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MIN_SIZES) &&
           verifier.VerifyVector(min_sizes()) &&
           VerifyOffset(verifier, VT_MAX_SIZES) &&
           verifier.VerifyVector(max_sizes()) &&
           VerifyOffset(verifier, VT_ASPECT_RATIOS) &&
           verifier.VerifyVector(aspect_ratios()) &&
           VerifyOffset(verifier, VT_VARIANCES) &&
           verifier.VerifyVector(variances()) &&
           VerifyField<uint32_t>(verifier, VT_FLIP) &&
           VerifyField<uint32_t>(verifier, VT_CLIP) &&
           VerifyField<float>(verifier, VT_STEP_W) &&
           VerifyField<float>(verifier, VT_STEP_H) &&
           VerifyField<float>(verifier, VT_OFFSET) &&
           verifier.EndTable();
  }
  PriorboxParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PriorboxParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PriorboxParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PriorboxParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PriorboxParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_min_sizes(flatbuffers::Offset<flatbuffers::Vector<float>> min_sizes) {
    fbb_.AddOffset(PriorboxParams::VT_MIN_SIZES, min_sizes);
  }
  void add_max_sizes(flatbuffers::Offset<flatbuffers::Vector<float>> max_sizes) {
    fbb_.AddOffset(PriorboxParams::VT_MAX_SIZES, max_sizes);
  }
  void add_aspect_ratios(flatbuffers::Offset<flatbuffers::Vector<float>> aspect_ratios) {
    fbb_.AddOffset(PriorboxParams::VT_ASPECT_RATIOS, aspect_ratios);
  }
  void add_variances(flatbuffers::Offset<flatbuffers::Vector<float>> variances) {
    fbb_.AddOffset(PriorboxParams::VT_VARIANCES, variances);
  }
  void add_flip(uint32_t flip) {
    fbb_.AddElement<uint32_t>(PriorboxParams::VT_FLIP, flip, 0);
  }
  void add_clip(uint32_t clip) {
    fbb_.AddElement<uint32_t>(PriorboxParams::VT_CLIP, clip, 0);
  }
  void add_step_w(float step_w) {
    fbb_.AddElement<float>(PriorboxParams::VT_STEP_W, step_w, 0.0f);
  }
  void add_step_h(float step_h) {
    fbb_.AddElement<float>(PriorboxParams::VT_STEP_H, step_h, 0.0f);
  }
  void add_offset(float offset) {
    fbb_.AddElement<float>(PriorboxParams::VT_OFFSET, offset, 0.0f);
  }
  explicit PriorboxParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PriorboxParamsBuilder &operator=(const PriorboxParamsBuilder &);
  flatbuffers::Offset<PriorboxParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PriorboxParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<PriorboxParams> CreatePriorboxParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> min_sizes = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> max_sizes = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> aspect_ratios = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> variances = 0,
    uint32_t flip = 0,
    uint32_t clip = 0,
    float step_w = 0.0f,
    float step_h = 0.0f,
    float offset = 0.0f) {
  PriorboxParamsBuilder builder_(_fbb);
  builder_.add_offset(offset);
  builder_.add_step_h(step_h);
  builder_.add_step_w(step_w);
  builder_.add_clip(clip);
  builder_.add_flip(flip);
  builder_.add_variances(variances);
  builder_.add_aspect_ratios(aspect_ratios);
  builder_.add_max_sizes(max_sizes);
  builder_.add_min_sizes(min_sizes);
  return builder_.Finish();
}

inline flatbuffers::Offset<PriorboxParams> CreatePriorboxParamsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *min_sizes = nullptr,
    const std::vector<float> *max_sizes = nullptr,
    const std::vector<float> *aspect_ratios = nullptr,
    const std::vector<float> *variances = nullptr,
    uint32_t flip = 0,
    uint32_t clip = 0,
    float step_w = 0.0f,
    float step_h = 0.0f,
    float offset = 0.0f) {
  auto min_sizes__ = min_sizes ? _fbb.CreateVector<float>(*min_sizes) : 0;
  auto max_sizes__ = max_sizes ? _fbb.CreateVector<float>(*max_sizes) : 0;
  auto aspect_ratios__ = aspect_ratios ? _fbb.CreateVector<float>(*aspect_ratios) : 0;
  auto variances__ = variances ? _fbb.CreateVector<float>(*variances) : 0;
  return MVCNN::CreatePriorboxParams(
      _fbb,
      min_sizes__,
      max_sizes__,
      aspect_ratios__,
      variances__,
      flip,
      clip,
      step_w,
      step_h,
      offset);
}

flatbuffers::Offset<PriorboxParams> CreatePriorboxParams(flatbuffers::FlatBufferBuilder &_fbb, const PriorboxParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ROIPoolingParamsT : public flatbuffers::NativeTable {
  typedef ROIPoolingParams TableType;
  uint32_t pooled_w;
  uint32_t pooled_h;
  float spatial_scale;
  uint32_t roi_pooling_method;
  uint32_t num_rois;
  ROIPoolingParamsT()
      : pooled_w(0),
        pooled_h(0),
        spatial_scale(0.0f),
        roi_pooling_method(0),
        num_rois(0) {
  }
};

struct ROIPoolingParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ROIPoolingParamsT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POOLED_W = 4,
    VT_POOLED_H = 6,
    VT_SPATIAL_SCALE = 8,
    VT_ROI_POOLING_METHOD = 10,
    VT_NUM_ROIS = 12
  };
  uint32_t pooled_w() const {
    return GetField<uint32_t>(VT_POOLED_W, 0);
  }
  uint32_t pooled_h() const {
    return GetField<uint32_t>(VT_POOLED_H, 0);
  }
  float spatial_scale() const {
    return GetField<float>(VT_SPATIAL_SCALE, 0.0f);
  }
  uint32_t roi_pooling_method() const {
    return GetField<uint32_t>(VT_ROI_POOLING_METHOD, 0);
  }
  uint32_t num_rois() const {
    return GetField<uint32_t>(VT_NUM_ROIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_POOLED_W) &&
           VerifyField<uint32_t>(verifier, VT_POOLED_H) &&
           VerifyField<float>(verifier, VT_SPATIAL_SCALE) &&
           VerifyField<uint32_t>(verifier, VT_ROI_POOLING_METHOD) &&
           VerifyField<uint32_t>(verifier, VT_NUM_ROIS) &&
           verifier.EndTable();
  }
  ROIPoolingParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ROIPoolingParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ROIPoolingParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ROIPoolingParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ROIPoolingParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pooled_w(uint32_t pooled_w) {
    fbb_.AddElement<uint32_t>(ROIPoolingParams::VT_POOLED_W, pooled_w, 0);
  }
  void add_pooled_h(uint32_t pooled_h) {
    fbb_.AddElement<uint32_t>(ROIPoolingParams::VT_POOLED_H, pooled_h, 0);
  }
  void add_spatial_scale(float spatial_scale) {
    fbb_.AddElement<float>(ROIPoolingParams::VT_SPATIAL_SCALE, spatial_scale, 0.0f);
  }
  void add_roi_pooling_method(uint32_t roi_pooling_method) {
    fbb_.AddElement<uint32_t>(ROIPoolingParams::VT_ROI_POOLING_METHOD, roi_pooling_method, 0);
  }
  void add_num_rois(uint32_t num_rois) {
    fbb_.AddElement<uint32_t>(ROIPoolingParams::VT_NUM_ROIS, num_rois, 0);
  }
  explicit ROIPoolingParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ROIPoolingParamsBuilder &operator=(const ROIPoolingParamsBuilder &);
  flatbuffers::Offset<ROIPoolingParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ROIPoolingParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<ROIPoolingParams> CreateROIPoolingParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t pooled_w = 0,
    uint32_t pooled_h = 0,
    float spatial_scale = 0.0f,
    uint32_t roi_pooling_method = 0,
    uint32_t num_rois = 0) {
  ROIPoolingParamsBuilder builder_(_fbb);
  builder_.add_num_rois(num_rois);
  builder_.add_roi_pooling_method(roi_pooling_method);
  builder_.add_spatial_scale(spatial_scale);
  builder_.add_pooled_h(pooled_h);
  builder_.add_pooled_w(pooled_w);
  return builder_.Finish();
}

flatbuffers::Offset<ROIPoolingParams> CreateROIPoolingParams(flatbuffers::FlatBufferBuilder &_fbb, const ROIPoolingParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PSROIPoolingParamsT : public flatbuffers::NativeTable {
  typedef PSROIPoolingParams TableType;
  uint32_t output_dim;
  uint32_t group_size;
  float spatial_scale;
  uint32_t pooled_w;
  uint32_t pooled_h;
  uint32_t spatial_bin_x;
  uint32_t spatial_bin_y;
  PSROIPoolingMode mode;
  PSROIPoolingParamsT()
      : output_dim(0),
        group_size(0),
        spatial_scale(0.0f),
        pooled_w(0),
        pooled_h(0),
        spatial_bin_x(0),
        spatial_bin_y(0),
        mode(PSROIPoolingMode_AVERAGE) {
  }
};

struct PSROIPoolingParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PSROIPoolingParamsT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTPUT_DIM = 4,
    VT_GROUP_SIZE = 6,
    VT_SPATIAL_SCALE = 8,
    VT_POOLED_W = 10,
    VT_POOLED_H = 12,
    VT_SPATIAL_BIN_X = 14,
    VT_SPATIAL_BIN_Y = 16,
    VT_MODE = 18
  };
  uint32_t output_dim() const {
    return GetField<uint32_t>(VT_OUTPUT_DIM, 0);
  }
  uint32_t group_size() const {
    return GetField<uint32_t>(VT_GROUP_SIZE, 0);
  }
  float spatial_scale() const {
    return GetField<float>(VT_SPATIAL_SCALE, 0.0f);
  }
  uint32_t pooled_w() const {
    return GetField<uint32_t>(VT_POOLED_W, 0);
  }
  uint32_t pooled_h() const {
    return GetField<uint32_t>(VT_POOLED_H, 0);
  }
  uint32_t spatial_bin_x() const {
    return GetField<uint32_t>(VT_SPATIAL_BIN_X, 0);
  }
  uint32_t spatial_bin_y() const {
    return GetField<uint32_t>(VT_SPATIAL_BIN_Y, 0);
  }
  PSROIPoolingMode mode() const {
    return static_cast<PSROIPoolingMode>(GetField<int8_t>(VT_MODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_OUTPUT_DIM) &&
           VerifyField<uint32_t>(verifier, VT_GROUP_SIZE) &&
           VerifyField<float>(verifier, VT_SPATIAL_SCALE) &&
           VerifyField<uint32_t>(verifier, VT_POOLED_W) &&
           VerifyField<uint32_t>(verifier, VT_POOLED_H) &&
           VerifyField<uint32_t>(verifier, VT_SPATIAL_BIN_X) &&
           VerifyField<uint32_t>(verifier, VT_SPATIAL_BIN_Y) &&
           VerifyField<int8_t>(verifier, VT_MODE) &&
           verifier.EndTable();
  }
  PSROIPoolingParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PSROIPoolingParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PSROIPoolingParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PSROIPoolingParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PSROIPoolingParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_output_dim(uint32_t output_dim) {
    fbb_.AddElement<uint32_t>(PSROIPoolingParams::VT_OUTPUT_DIM, output_dim, 0);
  }
  void add_group_size(uint32_t group_size) {
    fbb_.AddElement<uint32_t>(PSROIPoolingParams::VT_GROUP_SIZE, group_size, 0);
  }
  void add_spatial_scale(float spatial_scale) {
    fbb_.AddElement<float>(PSROIPoolingParams::VT_SPATIAL_SCALE, spatial_scale, 0.0f);
  }
  void add_pooled_w(uint32_t pooled_w) {
    fbb_.AddElement<uint32_t>(PSROIPoolingParams::VT_POOLED_W, pooled_w, 0);
  }
  void add_pooled_h(uint32_t pooled_h) {
    fbb_.AddElement<uint32_t>(PSROIPoolingParams::VT_POOLED_H, pooled_h, 0);
  }
  void add_spatial_bin_x(uint32_t spatial_bin_x) {
    fbb_.AddElement<uint32_t>(PSROIPoolingParams::VT_SPATIAL_BIN_X, spatial_bin_x, 0);
  }
  void add_spatial_bin_y(uint32_t spatial_bin_y) {
    fbb_.AddElement<uint32_t>(PSROIPoolingParams::VT_SPATIAL_BIN_Y, spatial_bin_y, 0);
  }
  void add_mode(PSROIPoolingMode mode) {
    fbb_.AddElement<int8_t>(PSROIPoolingParams::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  explicit PSROIPoolingParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PSROIPoolingParamsBuilder &operator=(const PSROIPoolingParamsBuilder &);
  flatbuffers::Offset<PSROIPoolingParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PSROIPoolingParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<PSROIPoolingParams> CreatePSROIPoolingParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t output_dim = 0,
    uint32_t group_size = 0,
    float spatial_scale = 0.0f,
    uint32_t pooled_w = 0,
    uint32_t pooled_h = 0,
    uint32_t spatial_bin_x = 0,
    uint32_t spatial_bin_y = 0,
    PSROIPoolingMode mode = PSROIPoolingMode_AVERAGE) {
  PSROIPoolingParamsBuilder builder_(_fbb);
  builder_.add_spatial_bin_y(spatial_bin_y);
  builder_.add_spatial_bin_x(spatial_bin_x);
  builder_.add_pooled_h(pooled_h);
  builder_.add_pooled_w(pooled_w);
  builder_.add_spatial_scale(spatial_scale);
  builder_.add_group_size(group_size);
  builder_.add_output_dim(output_dim);
  builder_.add_mode(mode);
  return builder_.Finish();
}

flatbuffers::Offset<PSROIPoolingParams> CreatePSROIPoolingParams(flatbuffers::FlatBufferBuilder &_fbb, const PSROIPoolingParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ProposalParamsT : public flatbuffers::NativeTable {
  typedef ProposalParams TableType;
  uint32_t base_size;
  uint32_t pre_nms_topn;
  uint32_t post_nms_topn;
  float nms_thresh;
  uint32_t feat_stride;
  uint32_t min_size;
  std::vector<float> ratio;
  std::vector<float> scale;
  float pre_nms_thresh;
  bool clip_before_nms;
  bool clip_after_nms;
  bool normalize;
  float box_size_scale;
  float box_coordinate_scale;
  std::string framework;
  bool for_deformable;
  ProposalParamsT()
      : base_size(0),
        pre_nms_topn(0),
        post_nms_topn(0),
        nms_thresh(0.0f),
        feat_stride(0),
        min_size(0),
        pre_nms_thresh(0.0f),
        clip_before_nms(true),
        clip_after_nms(false),
        normalize(false),
        box_size_scale(1.0f),
        box_coordinate_scale(1.0f),
        for_deformable(false) {
  }
};

struct ProposalParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProposalParamsT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE_SIZE = 4,
    VT_PRE_NMS_TOPN = 6,
    VT_POST_NMS_TOPN = 8,
    VT_NMS_THRESH = 10,
    VT_FEAT_STRIDE = 12,
    VT_MIN_SIZE = 14,
    VT_RATIO = 16,
    VT_SCALE = 18,
    VT_PRE_NMS_THRESH = 22,
    VT_CLIP_BEFORE_NMS = 24,
    VT_CLIP_AFTER_NMS = 26,
    VT_NORMALIZE = 28,
    VT_BOX_SIZE_SCALE = 30,
    VT_BOX_COORDINATE_SCALE = 32,
    VT_FRAMEWORK = 34,
    VT_FOR_DEFORMABLE = 36
  };
  uint32_t base_size() const {
    return GetField<uint32_t>(VT_BASE_SIZE, 0);
  }
  uint32_t pre_nms_topn() const {
    return GetField<uint32_t>(VT_PRE_NMS_TOPN, 0);
  }
  uint32_t post_nms_topn() const {
    return GetField<uint32_t>(VT_POST_NMS_TOPN, 0);
  }
  float nms_thresh() const {
    return GetField<float>(VT_NMS_THRESH, 0.0f);
  }
  uint32_t feat_stride() const {
    return GetField<uint32_t>(VT_FEAT_STRIDE, 0);
  }
  uint32_t min_size() const {
    return GetField<uint32_t>(VT_MIN_SIZE, 0);
  }
  const flatbuffers::Vector<float> *ratio() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_RATIO);
  }
  const flatbuffers::Vector<float> *scale() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALE);
  }
  float pre_nms_thresh() const {
    return GetField<float>(VT_PRE_NMS_THRESH, 0.0f);
  }
  bool clip_before_nms() const {
    return GetField<uint8_t>(VT_CLIP_BEFORE_NMS, 1) != 0;
  }
  bool clip_after_nms() const {
    return GetField<uint8_t>(VT_CLIP_AFTER_NMS, 0) != 0;
  }
  bool normalize() const {
    return GetField<uint8_t>(VT_NORMALIZE, 0) != 0;
  }
  float box_size_scale() const {
    return GetField<float>(VT_BOX_SIZE_SCALE, 1.0f);
  }
  float box_coordinate_scale() const {
    return GetField<float>(VT_BOX_COORDINATE_SCALE, 1.0f);
  }
  const flatbuffers::String *framework() const {
    return GetPointer<const flatbuffers::String *>(VT_FRAMEWORK);
  }
  bool for_deformable() const {
    return GetField<uint8_t>(VT_FOR_DEFORMABLE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_BASE_SIZE) &&
           VerifyField<uint32_t>(verifier, VT_PRE_NMS_TOPN) &&
           VerifyField<uint32_t>(verifier, VT_POST_NMS_TOPN) &&
           VerifyField<float>(verifier, VT_NMS_THRESH) &&
           VerifyField<uint32_t>(verifier, VT_FEAT_STRIDE) &&
           VerifyField<uint32_t>(verifier, VT_MIN_SIZE) &&
           VerifyOffset(verifier, VT_RATIO) &&
           verifier.VerifyVector(ratio()) &&
           VerifyOffset(verifier, VT_SCALE) &&
           verifier.VerifyVector(scale()) &&
           VerifyField<float>(verifier, VT_PRE_NMS_THRESH) &&
           VerifyField<uint8_t>(verifier, VT_CLIP_BEFORE_NMS) &&
           VerifyField<uint8_t>(verifier, VT_CLIP_AFTER_NMS) &&
           VerifyField<uint8_t>(verifier, VT_NORMALIZE) &&
           VerifyField<float>(verifier, VT_BOX_SIZE_SCALE) &&
           VerifyField<float>(verifier, VT_BOX_COORDINATE_SCALE) &&
           VerifyOffset(verifier, VT_FRAMEWORK) &&
           verifier.VerifyString(framework()) &&
           VerifyField<uint8_t>(verifier, VT_FOR_DEFORMABLE) &&
           verifier.EndTable();
  }
  ProposalParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ProposalParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ProposalParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProposalParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ProposalParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base_size(uint32_t base_size) {
    fbb_.AddElement<uint32_t>(ProposalParams::VT_BASE_SIZE, base_size, 0);
  }
  void add_pre_nms_topn(uint32_t pre_nms_topn) {
    fbb_.AddElement<uint32_t>(ProposalParams::VT_PRE_NMS_TOPN, pre_nms_topn, 0);
  }
  void add_post_nms_topn(uint32_t post_nms_topn) {
    fbb_.AddElement<uint32_t>(ProposalParams::VT_POST_NMS_TOPN, post_nms_topn, 0);
  }
  void add_nms_thresh(float nms_thresh) {
    fbb_.AddElement<float>(ProposalParams::VT_NMS_THRESH, nms_thresh, 0.0f);
  }
  void add_feat_stride(uint32_t feat_stride) {
    fbb_.AddElement<uint32_t>(ProposalParams::VT_FEAT_STRIDE, feat_stride, 0);
  }
  void add_min_size(uint32_t min_size) {
    fbb_.AddElement<uint32_t>(ProposalParams::VT_MIN_SIZE, min_size, 0);
  }
  void add_ratio(flatbuffers::Offset<flatbuffers::Vector<float>> ratio) {
    fbb_.AddOffset(ProposalParams::VT_RATIO, ratio);
  }
  void add_scale(flatbuffers::Offset<flatbuffers::Vector<float>> scale) {
    fbb_.AddOffset(ProposalParams::VT_SCALE, scale);
  }
  void add_pre_nms_thresh(float pre_nms_thresh) {
    fbb_.AddElement<float>(ProposalParams::VT_PRE_NMS_THRESH, pre_nms_thresh, 0.0f);
  }
  void add_clip_before_nms(bool clip_before_nms) {
    fbb_.AddElement<uint8_t>(ProposalParams::VT_CLIP_BEFORE_NMS, static_cast<uint8_t>(clip_before_nms), 1);
  }
  void add_clip_after_nms(bool clip_after_nms) {
    fbb_.AddElement<uint8_t>(ProposalParams::VT_CLIP_AFTER_NMS, static_cast<uint8_t>(clip_after_nms), 0);
  }
  void add_normalize(bool normalize) {
    fbb_.AddElement<uint8_t>(ProposalParams::VT_NORMALIZE, static_cast<uint8_t>(normalize), 0);
  }
  void add_box_size_scale(float box_size_scale) {
    fbb_.AddElement<float>(ProposalParams::VT_BOX_SIZE_SCALE, box_size_scale, 1.0f);
  }
  void add_box_coordinate_scale(float box_coordinate_scale) {
    fbb_.AddElement<float>(ProposalParams::VT_BOX_COORDINATE_SCALE, box_coordinate_scale, 1.0f);
  }
  void add_framework(flatbuffers::Offset<flatbuffers::String> framework) {
    fbb_.AddOffset(ProposalParams::VT_FRAMEWORK, framework);
  }
  void add_for_deformable(bool for_deformable) {
    fbb_.AddElement<uint8_t>(ProposalParams::VT_FOR_DEFORMABLE, static_cast<uint8_t>(for_deformable), 0);
  }
  explicit ProposalParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProposalParamsBuilder &operator=(const ProposalParamsBuilder &);
  flatbuffers::Offset<ProposalParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProposalParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProposalParams> CreateProposalParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t base_size = 0,
    uint32_t pre_nms_topn = 0,
    uint32_t post_nms_topn = 0,
    float nms_thresh = 0.0f,
    uint32_t feat_stride = 0,
    uint32_t min_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> ratio = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> scale = 0,
    float pre_nms_thresh = 0.0f,
    bool clip_before_nms = true,
    bool clip_after_nms = false,
    bool normalize = false,
    float box_size_scale = 1.0f,
    float box_coordinate_scale = 1.0f,
    flatbuffers::Offset<flatbuffers::String> framework = 0,
    bool for_deformable = false) {
  ProposalParamsBuilder builder_(_fbb);
  builder_.add_framework(framework);
  builder_.add_box_coordinate_scale(box_coordinate_scale);
  builder_.add_box_size_scale(box_size_scale);
  builder_.add_pre_nms_thresh(pre_nms_thresh);
  builder_.add_scale(scale);
  builder_.add_ratio(ratio);
  builder_.add_min_size(min_size);
  builder_.add_feat_stride(feat_stride);
  builder_.add_nms_thresh(nms_thresh);
  builder_.add_post_nms_topn(post_nms_topn);
  builder_.add_pre_nms_topn(pre_nms_topn);
  builder_.add_base_size(base_size);
  builder_.add_for_deformable(for_deformable);
  builder_.add_normalize(normalize);
  builder_.add_clip_after_nms(clip_after_nms);
  builder_.add_clip_before_nms(clip_before_nms);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProposalParams> CreateProposalParamsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t base_size = 0,
    uint32_t pre_nms_topn = 0,
    uint32_t post_nms_topn = 0,
    float nms_thresh = 0.0f,
    uint32_t feat_stride = 0,
    uint32_t min_size = 0,
    const std::vector<float> *ratio = nullptr,
    const std::vector<float> *scale = nullptr,
    float pre_nms_thresh = 0.0f,
    bool clip_before_nms = true,
    bool clip_after_nms = false,
    bool normalize = false,
    float box_size_scale = 1.0f,
    float box_coordinate_scale = 1.0f,
    const char *framework = nullptr,
    bool for_deformable = false) {
  auto ratio__ = ratio ? _fbb.CreateVector<float>(*ratio) : 0;
  auto scale__ = scale ? _fbb.CreateVector<float>(*scale) : 0;
  auto framework__ = framework ? _fbb.CreateString(framework) : 0;
  return MVCNN::CreateProposalParams(
      _fbb,
      base_size,
      pre_nms_topn,
      post_nms_topn,
      nms_thresh,
      feat_stride,
      min_size,
      ratio__,
      scale__,
      pre_nms_thresh,
      clip_before_nms,
      clip_after_nms,
      normalize,
      box_size_scale,
      box_coordinate_scale,
      framework__,
      for_deformable);
}

flatbuffers::Offset<ProposalParams> CreateProposalParams(flatbuffers::FlatBufferBuilder &_fbb, const ProposalParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RegionYOLOParamsT : public flatbuffers::NativeTable {
  typedef RegionYOLOParams TableType;
  int32_t coords;
  int32_t classes;
  int32_t num;
  bool do_softmax;
  std::vector<int32_t> mask;
  RegionYOLOParamsT()
      : coords(0),
        classes(0),
        num(0),
        do_softmax(true) {
  }
};

struct RegionYOLOParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RegionYOLOParamsT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COORDS = 4,
    VT_CLASSES = 6,
    VT_NUM = 8,
    VT_DO_SOFTMAX = 10,
    VT_MASK = 12
  };
  int32_t coords() const {
    return GetField<int32_t>(VT_COORDS, 0);
  }
  int32_t classes() const {
    return GetField<int32_t>(VT_CLASSES, 0);
  }
  int32_t num() const {
    return GetField<int32_t>(VT_NUM, 0);
  }
  bool do_softmax() const {
    return GetField<uint8_t>(VT_DO_SOFTMAX, 1) != 0;
  }
  const flatbuffers::Vector<int32_t> *mask() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_MASK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_COORDS) &&
           VerifyField<int32_t>(verifier, VT_CLASSES) &&
           VerifyField<int32_t>(verifier, VT_NUM) &&
           VerifyField<uint8_t>(verifier, VT_DO_SOFTMAX) &&
           VerifyOffset(verifier, VT_MASK) &&
           verifier.VerifyVector(mask()) &&
           verifier.EndTable();
  }
  RegionYOLOParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RegionYOLOParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RegionYOLOParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RegionYOLOParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RegionYOLOParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_coords(int32_t coords) {
    fbb_.AddElement<int32_t>(RegionYOLOParams::VT_COORDS, coords, 0);
  }
  void add_classes(int32_t classes) {
    fbb_.AddElement<int32_t>(RegionYOLOParams::VT_CLASSES, classes, 0);
  }
  void add_num(int32_t num) {
    fbb_.AddElement<int32_t>(RegionYOLOParams::VT_NUM, num, 0);
  }
  void add_do_softmax(bool do_softmax) {
    fbb_.AddElement<uint8_t>(RegionYOLOParams::VT_DO_SOFTMAX, static_cast<uint8_t>(do_softmax), 1);
  }
  void add_mask(flatbuffers::Offset<flatbuffers::Vector<int32_t>> mask) {
    fbb_.AddOffset(RegionYOLOParams::VT_MASK, mask);
  }
  explicit RegionYOLOParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RegionYOLOParamsBuilder &operator=(const RegionYOLOParamsBuilder &);
  flatbuffers::Offset<RegionYOLOParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RegionYOLOParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<RegionYOLOParams> CreateRegionYOLOParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t coords = 0,
    int32_t classes = 0,
    int32_t num = 0,
    bool do_softmax = true,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> mask = 0) {
  RegionYOLOParamsBuilder builder_(_fbb);
  builder_.add_mask(mask);
  builder_.add_num(num);
  builder_.add_classes(classes);
  builder_.add_coords(coords);
  builder_.add_do_softmax(do_softmax);
  return builder_.Finish();
}

inline flatbuffers::Offset<RegionYOLOParams> CreateRegionYOLOParamsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t coords = 0,
    int32_t classes = 0,
    int32_t num = 0,
    bool do_softmax = true,
    const std::vector<int32_t> *mask = nullptr) {
  auto mask__ = mask ? _fbb.CreateVector<int32_t>(*mask) : 0;
  return MVCNN::CreateRegionYOLOParams(
      _fbb,
      coords,
      classes,
      num,
      do_softmax,
      mask__);
}

flatbuffers::Offset<RegionYOLOParams> CreateRegionYOLOParams(flatbuffers::FlatBufferBuilder &_fbb, const RegionYOLOParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReorgYOLOParamsT : public flatbuffers::NativeTable {
  typedef ReorgYOLOParams TableType;
  int32_t stride;
  ReorgYOLOParamsT()
      : stride(0) {
  }
};

struct ReorgYOLOParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReorgYOLOParamsT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STRIDE = 4
  };
  int32_t stride() const {
    return GetField<int32_t>(VT_STRIDE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STRIDE) &&
           verifier.EndTable();
  }
  ReorgYOLOParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReorgYOLOParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReorgYOLOParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReorgYOLOParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReorgYOLOParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stride(int32_t stride) {
    fbb_.AddElement<int32_t>(ReorgYOLOParams::VT_STRIDE, stride, 0);
  }
  explicit ReorgYOLOParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReorgYOLOParamsBuilder &operator=(const ReorgYOLOParamsBuilder &);
  flatbuffers::Offset<ReorgYOLOParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReorgYOLOParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReorgYOLOParams> CreateReorgYOLOParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t stride = 0) {
  ReorgYOLOParamsBuilder builder_(_fbb);
  builder_.add_stride(stride);
  return builder_.Finish();
}

flatbuffers::Offset<ReorgYOLOParams> CreateReorgYOLOParams(flatbuffers::FlatBufferBuilder &_fbb, const ReorgYOLOParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReshapeParamsT : public flatbuffers::NativeTable {
  typedef ReshapeParams TableType;
  ReshapeParamsT() {
  }
};

struct ReshapeParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReshapeParamsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ReshapeParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReshapeParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReshapeParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReshapeParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ReshapeParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReshapeParamsBuilder &operator=(const ReshapeParamsBuilder &);
  flatbuffers::Offset<ReshapeParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReshapeParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReshapeParams> CreateReshapeParams(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ReshapeParamsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ReshapeParams> CreateReshapeParams(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SoftmaxParamsT : public flatbuffers::NativeTable {
  typedef SoftmaxParams TableType;
  uint32_t axis;
  SoftmaxParamsT()
      : axis(0) {
  }
};

struct SoftmaxParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SoftmaxParamsT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  uint32_t axis() const {
    return GetField<uint32_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
  SoftmaxParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SoftmaxParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SoftmaxParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SoftmaxParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(uint32_t axis) {
    fbb_.AddElement<uint32_t>(SoftmaxParams::VT_AXIS, axis, 0);
  }
  explicit SoftmaxParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SoftmaxParamsBuilder &operator=(const SoftmaxParamsBuilder &);
  flatbuffers::Offset<SoftmaxParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SoftmaxParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<SoftmaxParams> CreateSoftmaxParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t axis = 0) {
  SoftmaxParamsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

flatbuffers::Offset<SoftmaxParams> CreateSoftmaxParams(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CustomLayerParamsT : public flatbuffers::NativeTable {
  typedef CustomLayerParams TableType;
  uint32_t leonPreambleID;
  std::unique_ptr<BinaryDataT> kernelData;
  std::unique_ptr<BinaryDataT> paramData;
  CustomLayerParamsT()
      : leonPreambleID(0) {
  }
};

struct CustomLayerParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CustomLayerParamsT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEONPREAMBLEID = 4,
    VT_KERNELDATA = 6,
    VT_PARAMDATA = 8
  };
  uint32_t leonPreambleID() const {
    return GetField<uint32_t>(VT_LEONPREAMBLEID, 0);
  }
  const BinaryData *kernelData() const {
    return GetPointer<const BinaryData *>(VT_KERNELDATA);
  }
  const BinaryData *paramData() const {
    return GetPointer<const BinaryData *>(VT_PARAMDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_LEONPREAMBLEID) &&
           VerifyOffset(verifier, VT_KERNELDATA) &&
           verifier.VerifyTable(kernelData()) &&
           VerifyOffset(verifier, VT_PARAMDATA) &&
           verifier.VerifyTable(paramData()) &&
           verifier.EndTable();
  }
  CustomLayerParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CustomLayerParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CustomLayerParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomLayerParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CustomLayerParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_leonPreambleID(uint32_t leonPreambleID) {
    fbb_.AddElement<uint32_t>(CustomLayerParams::VT_LEONPREAMBLEID, leonPreambleID, 0);
  }
  void add_kernelData(flatbuffers::Offset<BinaryData> kernelData) {
    fbb_.AddOffset(CustomLayerParams::VT_KERNELDATA, kernelData);
  }
  void add_paramData(flatbuffers::Offset<BinaryData> paramData) {
    fbb_.AddOffset(CustomLayerParams::VT_PARAMDATA, paramData);
  }
  explicit CustomLayerParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CustomLayerParamsBuilder &operator=(const CustomLayerParamsBuilder &);
  flatbuffers::Offset<CustomLayerParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CustomLayerParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<CustomLayerParams> CreateCustomLayerParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t leonPreambleID = 0,
    flatbuffers::Offset<BinaryData> kernelData = 0,
    flatbuffers::Offset<BinaryData> paramData = 0) {
  CustomLayerParamsBuilder builder_(_fbb);
  builder_.add_paramData(paramData);
  builder_.add_kernelData(kernelData);
  builder_.add_leonPreambleID(leonPreambleID);
  return builder_.Finish();
}

flatbuffers::Offset<CustomLayerParams> CreateCustomLayerParams(flatbuffers::FlatBufferBuilder &_fbb, const CustomLayerParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EdslParamsT : public flatbuffers::NativeTable {
  typedef EdslParams TableType;
  uint32_t leonPreambleID;
  std::unique_ptr<BinaryDataT> kernelData;
  std::unique_ptr<BinaryDataT> paramData;
  EdslParamsT()
      : leonPreambleID(0) {
  }
};

struct EdslParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EdslParamsT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEONPREAMBLEID = 4,
    VT_KERNELDATA = 6,
    VT_PARAMDATA = 8
  };
  uint32_t leonPreambleID() const {
    return GetField<uint32_t>(VT_LEONPREAMBLEID, 0);
  }
  const BinaryData *kernelData() const {
    return GetPointer<const BinaryData *>(VT_KERNELDATA);
  }
  const BinaryData *paramData() const {
    return GetPointer<const BinaryData *>(VT_PARAMDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_LEONPREAMBLEID) &&
           VerifyOffset(verifier, VT_KERNELDATA) &&
           verifier.VerifyTable(kernelData()) &&
           VerifyOffset(verifier, VT_PARAMDATA) &&
           verifier.VerifyTable(paramData()) &&
           verifier.EndTable();
  }
  EdslParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EdslParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EdslParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EdslParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EdslParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_leonPreambleID(uint32_t leonPreambleID) {
    fbb_.AddElement<uint32_t>(EdslParams::VT_LEONPREAMBLEID, leonPreambleID, 0);
  }
  void add_kernelData(flatbuffers::Offset<BinaryData> kernelData) {
    fbb_.AddOffset(EdslParams::VT_KERNELDATA, kernelData);
  }
  void add_paramData(flatbuffers::Offset<BinaryData> paramData) {
    fbb_.AddOffset(EdslParams::VT_PARAMDATA, paramData);
  }
  explicit EdslParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EdslParamsBuilder &operator=(const EdslParamsBuilder &);
  flatbuffers::Offset<EdslParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EdslParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<EdslParams> CreateEdslParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t leonPreambleID = 0,
    flatbuffers::Offset<BinaryData> kernelData = 0,
    flatbuffers::Offset<BinaryData> paramData = 0) {
  EdslParamsBuilder builder_(_fbb);
  builder_.add_paramData(paramData);
  builder_.add_kernelData(kernelData);
  builder_.add_leonPreambleID(leonPreambleID);
  return builder_.Finish();
}

flatbuffers::Offset<EdslParams> CreateEdslParams(flatbuffers::FlatBufferBuilder &_fbb, const EdslParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PassthroughParamsT : public flatbuffers::NativeTable {
  typedef PassthroughParams TableType;
  uint32_t min_delay_us;
  PassthroughParamsT()
      : min_delay_us(0) {
  }
};

struct PassthroughParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PassthroughParamsT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN_DELAY_US = 4
  };
  uint32_t min_delay_us() const {
    return GetField<uint32_t>(VT_MIN_DELAY_US, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_MIN_DELAY_US) &&
           verifier.EndTable();
  }
  PassthroughParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PassthroughParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PassthroughParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PassthroughParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PassthroughParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_min_delay_us(uint32_t min_delay_us) {
    fbb_.AddElement<uint32_t>(PassthroughParams::VT_MIN_DELAY_US, min_delay_us, 0);
  }
  explicit PassthroughParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PassthroughParamsBuilder &operator=(const PassthroughParamsBuilder &);
  flatbuffers::Offset<PassthroughParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PassthroughParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<PassthroughParams> CreatePassthroughParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t min_delay_us = 0) {
  PassthroughParamsBuilder builder_(_fbb);
  builder_.add_min_delay_us(min_delay_us);
  return builder_.Finish();
}

flatbuffers::Offset<PassthroughParams> CreatePassthroughParams(flatbuffers::FlatBufferBuilder &_fbb, const PassthroughParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LayerRecordParamsT : public flatbuffers::NativeTable {
  typedef LayerRecordParams TableType;
  LayerRecordParamsT() {
  }
};

struct LayerRecordParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LayerRecordParamsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LayerRecordParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LayerRecordParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LayerRecordParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LayerRecordParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LayerRecordParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LayerRecordParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LayerRecordParamsBuilder &operator=(const LayerRecordParamsBuilder &);
  flatbuffers::Offset<LayerRecordParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LayerRecordParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<LayerRecordParams> CreateLayerRecordParams(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LayerRecordParamsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LayerRecordParams> CreateLayerRecordParams(flatbuffers::FlatBufferBuilder &_fbb, const LayerRecordParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ArgMaxParamsT : public flatbuffers::NativeTable {
  typedef ArgMaxParams TableType;
  bool out_max_val;
  uint32_t top_k;
  int32_t axis;
  ArgMaxParamsT()
      : out_max_val(false),
        top_k(1),
        axis(99) {
  }
};

struct ArgMaxParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArgMaxParamsT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUT_MAX_VAL = 4,
    VT_TOP_K = 6,
    VT_AXIS = 8
  };
  bool out_max_val() const {
    return GetField<uint8_t>(VT_OUT_MAX_VAL, 0) != 0;
  }
  uint32_t top_k() const {
    return GetField<uint32_t>(VT_TOP_K, 1);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 99);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OUT_MAX_VAL) &&
           VerifyField<uint32_t>(verifier, VT_TOP_K) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
  ArgMaxParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ArgMaxParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ArgMaxParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ArgMaxParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_out_max_val(bool out_max_val) {
    fbb_.AddElement<uint8_t>(ArgMaxParams::VT_OUT_MAX_VAL, static_cast<uint8_t>(out_max_val), 0);
  }
  void add_top_k(uint32_t top_k) {
    fbb_.AddElement<uint32_t>(ArgMaxParams::VT_TOP_K, top_k, 1);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(ArgMaxParams::VT_AXIS, axis, 99);
  }
  explicit ArgMaxParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArgMaxParamsBuilder &operator=(const ArgMaxParamsBuilder &);
  flatbuffers::Offset<ArgMaxParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArgMaxParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArgMaxParams> CreateArgMaxParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool out_max_val = false,
    uint32_t top_k = 1,
    int32_t axis = 99) {
  ArgMaxParamsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_top_k(top_k);
  builder_.add_out_max_val(out_max_val);
  return builder_.Finish();
}

flatbuffers::Offset<ArgMaxParams> CreateArgMaxParams(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NormParamsT : public flatbuffers::NativeTable {
  typedef NormParams TableType;
  float alpha;
  float beta;
  std::string region;
  int32_t local_size;
  NormParamsT()
      : alpha(0.0f),
        beta(0.0f),
        local_size(0) {
  }
};

struct NormParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NormParamsT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALPHA = 4,
    VT_BETA = 6,
    VT_REGION = 8,
    VT_LOCAL_SIZE = 10
  };
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  const flatbuffers::String *region() const {
    return GetPointer<const flatbuffers::String *>(VT_REGION);
  }
  int32_t local_size() const {
    return GetField<int32_t>(VT_LOCAL_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           VerifyField<float>(verifier, VT_BETA) &&
           VerifyOffset(verifier, VT_REGION) &&
           verifier.VerifyString(region()) &&
           VerifyField<int32_t>(verifier, VT_LOCAL_SIZE) &&
           verifier.EndTable();
  }
  NormParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NormParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NormParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NormParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NormParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(NormParams::VT_ALPHA, alpha, 0.0f);
  }
  void add_beta(float beta) {
    fbb_.AddElement<float>(NormParams::VT_BETA, beta, 0.0f);
  }
  void add_region(flatbuffers::Offset<flatbuffers::String> region) {
    fbb_.AddOffset(NormParams::VT_REGION, region);
  }
  void add_local_size(int32_t local_size) {
    fbb_.AddElement<int32_t>(NormParams::VT_LOCAL_SIZE, local_size, 0);
  }
  explicit NormParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NormParamsBuilder &operator=(const NormParamsBuilder &);
  flatbuffers::Offset<NormParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NormParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<NormParams> CreateNormParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    float alpha = 0.0f,
    float beta = 0.0f,
    flatbuffers::Offset<flatbuffers::String> region = 0,
    int32_t local_size = 0) {
  NormParamsBuilder builder_(_fbb);
  builder_.add_local_size(local_size);
  builder_.add_region(region);
  builder_.add_beta(beta);
  builder_.add_alpha(alpha);
  return builder_.Finish();
}

inline flatbuffers::Offset<NormParams> CreateNormParamsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float alpha = 0.0f,
    float beta = 0.0f,
    const char *region = nullptr,
    int32_t local_size = 0) {
  auto region__ = region ? _fbb.CreateString(region) : 0;
  return MVCNN::CreateNormParams(
      _fbb,
      alpha,
      beta,
      region__,
      local_size);
}

flatbuffers::Offset<NormParams> CreateNormParams(flatbuffers::FlatBufferBuilder &_fbb, const NormParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EltwiseParamsT : public flatbuffers::NativeTable {
  typedef EltwiseParams TableType;
  std::string operation;
  EltwiseParamsT() {
  }
};

struct EltwiseParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EltwiseParamsT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPERATION = 4
  };
  const flatbuffers::String *operation() const {
    return GetPointer<const flatbuffers::String *>(VT_OPERATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OPERATION) &&
           verifier.VerifyString(operation()) &&
           verifier.EndTable();
  }
  EltwiseParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EltwiseParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EltwiseParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EltwiseParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_operation(flatbuffers::Offset<flatbuffers::String> operation) {
    fbb_.AddOffset(EltwiseParams::VT_OPERATION, operation);
  }
  explicit EltwiseParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EltwiseParamsBuilder &operator=(const EltwiseParamsBuilder &);
  flatbuffers::Offset<EltwiseParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EltwiseParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<EltwiseParams> CreateEltwiseParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> operation = 0) {
  EltwiseParamsBuilder builder_(_fbb);
  builder_.add_operation(operation);
  return builder_.Finish();
}

inline flatbuffers::Offset<EltwiseParams> CreateEltwiseParamsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *operation = nullptr) {
  auto operation__ = operation ? _fbb.CreateString(operation) : 0;
  return MVCNN::CreateEltwiseParams(
      _fbb,
      operation__);
}

flatbuffers::Offset<EltwiseParams> CreateEltwiseParams(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ResampleParamsT : public flatbuffers::NativeTable {
  typedef ResampleParams TableType;
  InterpolationMethod interpolation;
  bool antialias;
  ResampleParamsT()
      : interpolation(InterpolationMethod_NEAREST),
        antialias(false) {
  }
};

struct ResampleParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResampleParamsT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INTERPOLATION = 4,
    VT_ANTIALIAS = 6
  };
  InterpolationMethod interpolation() const {
    return static_cast<InterpolationMethod>(GetField<int8_t>(VT_INTERPOLATION, 0));
  }
  bool antialias() const {
    return GetField<uint8_t>(VT_ANTIALIAS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_INTERPOLATION) &&
           VerifyField<uint8_t>(verifier, VT_ANTIALIAS) &&
           verifier.EndTable();
  }
  ResampleParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ResampleParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ResampleParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResampleParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ResampleParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_interpolation(InterpolationMethod interpolation) {
    fbb_.AddElement<int8_t>(ResampleParams::VT_INTERPOLATION, static_cast<int8_t>(interpolation), 0);
  }
  void add_antialias(bool antialias) {
    fbb_.AddElement<uint8_t>(ResampleParams::VT_ANTIALIAS, static_cast<uint8_t>(antialias), 0);
  }
  explicit ResampleParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResampleParamsBuilder &operator=(const ResampleParamsBuilder &);
  flatbuffers::Offset<ResampleParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResampleParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResampleParams> CreateResampleParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    InterpolationMethod interpolation = InterpolationMethod_NEAREST,
    bool antialias = false) {
  ResampleParamsBuilder builder_(_fbb);
  builder_.add_antialias(antialias);
  builder_.add_interpolation(interpolation);
  return builder_.Finish();
}

flatbuffers::Offset<ResampleParams> CreateResampleParams(flatbuffers::FlatBufferBuilder &_fbb, const ResampleParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CorrelationParamsT : public flatbuffers::NativeTable {
  typedef CorrelationParams TableType;
  int32_t kernel_size;
  int32_t max_displacement;
  int32_t pad_size;
  int32_t stride1;
  int32_t stride2;
  uint32_t correlation_type;
  CorrelationParamsT()
      : kernel_size(0),
        max_displacement(0),
        pad_size(0),
        stride1(0),
        stride2(0),
        correlation_type(0) {
  }
};

struct CorrelationParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CorrelationParamsT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KERNEL_SIZE = 4,
    VT_MAX_DISPLACEMENT = 6,
    VT_PAD_SIZE = 8,
    VT_STRIDE1 = 10,
    VT_STRIDE2 = 12,
    VT_CORRELATION_TYPE = 14
  };
  int32_t kernel_size() const {
    return GetField<int32_t>(VT_KERNEL_SIZE, 0);
  }
  int32_t max_displacement() const {
    return GetField<int32_t>(VT_MAX_DISPLACEMENT, 0);
  }
  int32_t pad_size() const {
    return GetField<int32_t>(VT_PAD_SIZE, 0);
  }
  int32_t stride1() const {
    return GetField<int32_t>(VT_STRIDE1, 0);
  }
  int32_t stride2() const {
    return GetField<int32_t>(VT_STRIDE2, 0);
  }
  uint32_t correlation_type() const {
    return GetField<uint32_t>(VT_CORRELATION_TYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KERNEL_SIZE) &&
           VerifyField<int32_t>(verifier, VT_MAX_DISPLACEMENT) &&
           VerifyField<int32_t>(verifier, VT_PAD_SIZE) &&
           VerifyField<int32_t>(verifier, VT_STRIDE1) &&
           VerifyField<int32_t>(verifier, VT_STRIDE2) &&
           VerifyField<uint32_t>(verifier, VT_CORRELATION_TYPE) &&
           verifier.EndTable();
  }
  CorrelationParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CorrelationParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CorrelationParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CorrelationParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CorrelationParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kernel_size(int32_t kernel_size) {
    fbb_.AddElement<int32_t>(CorrelationParams::VT_KERNEL_SIZE, kernel_size, 0);
  }
  void add_max_displacement(int32_t max_displacement) {
    fbb_.AddElement<int32_t>(CorrelationParams::VT_MAX_DISPLACEMENT, max_displacement, 0);
  }
  void add_pad_size(int32_t pad_size) {
    fbb_.AddElement<int32_t>(CorrelationParams::VT_PAD_SIZE, pad_size, 0);
  }
  void add_stride1(int32_t stride1) {
    fbb_.AddElement<int32_t>(CorrelationParams::VT_STRIDE1, stride1, 0);
  }
  void add_stride2(int32_t stride2) {
    fbb_.AddElement<int32_t>(CorrelationParams::VT_STRIDE2, stride2, 0);
  }
  void add_correlation_type(uint32_t correlation_type) {
    fbb_.AddElement<uint32_t>(CorrelationParams::VT_CORRELATION_TYPE, correlation_type, 0);
  }
  explicit CorrelationParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CorrelationParamsBuilder &operator=(const CorrelationParamsBuilder &);
  flatbuffers::Offset<CorrelationParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CorrelationParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<CorrelationParams> CreateCorrelationParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kernel_size = 0,
    int32_t max_displacement = 0,
    int32_t pad_size = 0,
    int32_t stride1 = 0,
    int32_t stride2 = 0,
    uint32_t correlation_type = 0) {
  CorrelationParamsBuilder builder_(_fbb);
  builder_.add_correlation_type(correlation_type);
  builder_.add_stride2(stride2);
  builder_.add_stride1(stride1);
  builder_.add_pad_size(pad_size);
  builder_.add_max_displacement(max_displacement);
  builder_.add_kernel_size(kernel_size);
  return builder_.Finish();
}

flatbuffers::Offset<CorrelationParams> CreateCorrelationParams(flatbuffers::FlatBufferBuilder &_fbb, const CorrelationParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MVNParamsT : public flatbuffers::NativeTable {
  typedef MVNParams TableType;
  float eps;
  bool across_channels;
  bool normalize_variance;
  MVNParamsT()
      : eps(1e-8f),
        across_channels(false),
        normalize_variance(false) {
  }
};

struct MVNParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MVNParamsT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EPS = 4,
    VT_ACROSS_CHANNELS = 6,
    VT_NORMALIZE_VARIANCE = 8
  };
  float eps() const {
    return GetField<float>(VT_EPS, 1e-8f);
  }
  bool across_channels() const {
    return GetField<uint8_t>(VT_ACROSS_CHANNELS, 0) != 0;
  }
  bool normalize_variance() const {
    return GetField<uint8_t>(VT_NORMALIZE_VARIANCE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_EPS) &&
           VerifyField<uint8_t>(verifier, VT_ACROSS_CHANNELS) &&
           VerifyField<uint8_t>(verifier, VT_NORMALIZE_VARIANCE) &&
           verifier.EndTable();
  }
  MVNParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MVNParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MVNParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MVNParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MVNParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eps(float eps) {
    fbb_.AddElement<float>(MVNParams::VT_EPS, eps, 1e-8f);
  }
  void add_across_channels(bool across_channels) {
    fbb_.AddElement<uint8_t>(MVNParams::VT_ACROSS_CHANNELS, static_cast<uint8_t>(across_channels), 0);
  }
  void add_normalize_variance(bool normalize_variance) {
    fbb_.AddElement<uint8_t>(MVNParams::VT_NORMALIZE_VARIANCE, static_cast<uint8_t>(normalize_variance), 0);
  }
  explicit MVNParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MVNParamsBuilder &operator=(const MVNParamsBuilder &);
  flatbuffers::Offset<MVNParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MVNParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<MVNParams> CreateMVNParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    float eps = 1e-8f,
    bool across_channels = false,
    bool normalize_variance = false) {
  MVNParamsBuilder builder_(_fbb);
  builder_.add_eps(eps);
  builder_.add_normalize_variance(normalize_variance);
  builder_.add_across_channels(across_channels);
  return builder_.Finish();
}

flatbuffers::Offset<MVNParams> CreateMVNParams(flatbuffers::FlatBufferBuilder &_fbb, const MVNParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GRNParamsT : public flatbuffers::NativeTable {
  typedef GRNParams TableType;
  float bias;
  GRNParamsT()
      : bias(0.0f) {
  }
};

struct GRNParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GRNParamsT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BIAS = 4
  };
  float bias() const {
    return GetField<float>(VT_BIAS, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_BIAS) &&
           verifier.EndTable();
  }
  GRNParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GRNParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GRNParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GRNParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GRNParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bias(float bias) {
    fbb_.AddElement<float>(GRNParams::VT_BIAS, bias, 0.0f);
  }
  explicit GRNParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GRNParamsBuilder &operator=(const GRNParamsBuilder &);
  flatbuffers::Offset<GRNParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GRNParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<GRNParams> CreateGRNParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    float bias = 0.0f) {
  GRNParamsBuilder builder_(_fbb);
  builder_.add_bias(bias);
  return builder_.Finish();
}

flatbuffers::Offset<GRNParams> CreateGRNParams(flatbuffers::FlatBufferBuilder &_fbb, const GRNParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CTCDecoderParamsT : public flatbuffers::NativeTable {
  typedef CTCDecoderParams TableType;
  bool ctc_merge_repeated;
  CTCDecoderParamsT()
      : ctc_merge_repeated(false) {
  }
};

struct CTCDecoderParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CTCDecoderParamsT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CTC_MERGE_REPEATED = 4
  };
  bool ctc_merge_repeated() const {
    return GetField<uint8_t>(VT_CTC_MERGE_REPEATED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CTC_MERGE_REPEATED) &&
           verifier.EndTable();
  }
  CTCDecoderParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CTCDecoderParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CTCDecoderParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CTCDecoderParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CTCDecoderParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ctc_merge_repeated(bool ctc_merge_repeated) {
    fbb_.AddElement<uint8_t>(CTCDecoderParams::VT_CTC_MERGE_REPEATED, static_cast<uint8_t>(ctc_merge_repeated), 0);
  }
  explicit CTCDecoderParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CTCDecoderParamsBuilder &operator=(const CTCDecoderParamsBuilder &);
  flatbuffers::Offset<CTCDecoderParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CTCDecoderParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<CTCDecoderParams> CreateCTCDecoderParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool ctc_merge_repeated = false) {
  CTCDecoderParamsBuilder builder_(_fbb);
  builder_.add_ctc_merge_repeated(ctc_merge_repeated);
  return builder_.Finish();
}

flatbuffers::Offset<CTCDecoderParams> CreateCTCDecoderParams(flatbuffers::FlatBufferBuilder &_fbb, const CTCDecoderParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SpatialTransformParamsT : public flatbuffers::NativeTable {
  typedef SpatialTransformParams TableType;
  std::vector<float> theta;
  SpatialTransformParamsT() {
  }
};

struct SpatialTransformParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SpatialTransformParamsT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_THETA = 4
  };
  const flatbuffers::Vector<float> *theta() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_THETA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_THETA) &&
           verifier.VerifyVector(theta()) &&
           verifier.EndTable();
  }
  SpatialTransformParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SpatialTransformParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SpatialTransformParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpatialTransformParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SpatialTransformParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_theta(flatbuffers::Offset<flatbuffers::Vector<float>> theta) {
    fbb_.AddOffset(SpatialTransformParams::VT_THETA, theta);
  }
  explicit SpatialTransformParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SpatialTransformParamsBuilder &operator=(const SpatialTransformParamsBuilder &);
  flatbuffers::Offset<SpatialTransformParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpatialTransformParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpatialTransformParams> CreateSpatialTransformParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> theta = 0) {
  SpatialTransformParamsBuilder builder_(_fbb);
  builder_.add_theta(theta);
  return builder_.Finish();
}

inline flatbuffers::Offset<SpatialTransformParams> CreateSpatialTransformParamsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *theta = nullptr) {
  auto theta__ = theta ? _fbb.CreateVector<float>(*theta) : 0;
  return MVCNN::CreateSpatialTransformParams(
      _fbb,
      theta__);
}

flatbuffers::Offset<SpatialTransformParams> CreateSpatialTransformParams(flatbuffers::FlatBufferBuilder &_fbb, const SpatialTransformParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FakeQuantizeParamsT : public flatbuffers::NativeTable {
  typedef FakeQuantizeParams TableType;
  uint32_t levels;
  std::vector<uint16_t> input_low;
  std::vector<uint16_t> input_high;
  std::vector<uint16_t> output_low;
  std::vector<uint16_t> output_high;
  FakeQuantizeParamsT()
      : levels(0) {
  }
};

struct FakeQuantizeParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FakeQuantizeParamsT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEVELS = 4,
    VT_INPUT_LOW = 6,
    VT_INPUT_HIGH = 8,
    VT_OUTPUT_LOW = 10,
    VT_OUTPUT_HIGH = 12
  };
  uint32_t levels() const {
    return GetField<uint32_t>(VT_LEVELS, 0);
  }
  const flatbuffers::Vector<uint16_t> *input_low() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_INPUT_LOW);
  }
  const flatbuffers::Vector<uint16_t> *input_high() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_INPUT_HIGH);
  }
  const flatbuffers::Vector<uint16_t> *output_low() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_OUTPUT_LOW);
  }
  const flatbuffers::Vector<uint16_t> *output_high() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_OUTPUT_HIGH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_LEVELS) &&
           VerifyOffset(verifier, VT_INPUT_LOW) &&
           verifier.VerifyVector(input_low()) &&
           VerifyOffset(verifier, VT_INPUT_HIGH) &&
           verifier.VerifyVector(input_high()) &&
           VerifyOffset(verifier, VT_OUTPUT_LOW) &&
           verifier.VerifyVector(output_low()) &&
           VerifyOffset(verifier, VT_OUTPUT_HIGH) &&
           verifier.VerifyVector(output_high()) &&
           verifier.EndTable();
  }
  FakeQuantizeParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FakeQuantizeParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FakeQuantizeParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantizeParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FakeQuantizeParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_levels(uint32_t levels) {
    fbb_.AddElement<uint32_t>(FakeQuantizeParams::VT_LEVELS, levels, 0);
  }
  void add_input_low(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> input_low) {
    fbb_.AddOffset(FakeQuantizeParams::VT_INPUT_LOW, input_low);
  }
  void add_input_high(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> input_high) {
    fbb_.AddOffset(FakeQuantizeParams::VT_INPUT_HIGH, input_high);
  }
  void add_output_low(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> output_low) {
    fbb_.AddOffset(FakeQuantizeParams::VT_OUTPUT_LOW, output_low);
  }
  void add_output_high(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> output_high) {
    fbb_.AddOffset(FakeQuantizeParams::VT_OUTPUT_HIGH, output_high);
  }
  explicit FakeQuantizeParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FakeQuantizeParamsBuilder &operator=(const FakeQuantizeParamsBuilder &);
  flatbuffers::Offset<FakeQuantizeParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FakeQuantizeParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<FakeQuantizeParams> CreateFakeQuantizeParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t levels = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> input_low = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> input_high = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> output_low = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> output_high = 0) {
  FakeQuantizeParamsBuilder builder_(_fbb);
  builder_.add_output_high(output_high);
  builder_.add_output_low(output_low);
  builder_.add_input_high(input_high);
  builder_.add_input_low(input_low);
  builder_.add_levels(levels);
  return builder_.Finish();
}

inline flatbuffers::Offset<FakeQuantizeParams> CreateFakeQuantizeParamsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t levels = 0,
    const std::vector<uint16_t> *input_low = nullptr,
    const std::vector<uint16_t> *input_high = nullptr,
    const std::vector<uint16_t> *output_low = nullptr,
    const std::vector<uint16_t> *output_high = nullptr) {
  auto input_low__ = input_low ? _fbb.CreateVector<uint16_t>(*input_low) : 0;
  auto input_high__ = input_high ? _fbb.CreateVector<uint16_t>(*input_high) : 0;
  auto output_low__ = output_low ? _fbb.CreateVector<uint16_t>(*output_low) : 0;
  auto output_high__ = output_high ? _fbb.CreateVector<uint16_t>(*output_high) : 0;
  return MVCNN::CreateFakeQuantizeParams(
      _fbb,
      levels,
      input_low__,
      input_high__,
      output_low__,
      output_high__);
}

flatbuffers::Offset<FakeQuantizeParams> CreateFakeQuantizeParams(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantizeParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PoolingParamsT : public flatbuffers::NativeTable {
  typedef PoolingParams TableType;
  std::unique_ptr<order3> kernel;
  std::string pool_method;
  std::string exclude_pad;
  std::unique_ptr<order3> strides;
  std::unique_ptr<order3> pads_begin;
  std::unique_ptr<order3> pads_end;
  std::string rounding_type;
  std::string auto_pad;
  PoolingParamsT() {
  }
};

struct PoolingParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PoolingParamsT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KERNEL = 4,
    VT_POOL_METHOD = 6,
    VT_EXCLUDE_PAD = 8,
    VT_STRIDES = 10,
    VT_PADS_BEGIN = 12,
    VT_PADS_END = 14,
    VT_ROUNDING_TYPE = 16,
    VT_AUTO_PAD = 18
  };
  const order3 *kernel() const {
    return GetStruct<const order3 *>(VT_KERNEL);
  }
  const flatbuffers::String *pool_method() const {
    return GetPointer<const flatbuffers::String *>(VT_POOL_METHOD);
  }
  const flatbuffers::String *exclude_pad() const {
    return GetPointer<const flatbuffers::String *>(VT_EXCLUDE_PAD);
  }
  const order3 *strides() const {
    return GetStruct<const order3 *>(VT_STRIDES);
  }
  const order3 *pads_begin() const {
    return GetStruct<const order3 *>(VT_PADS_BEGIN);
  }
  const order3 *pads_end() const {
    return GetStruct<const order3 *>(VT_PADS_END);
  }
  const flatbuffers::String *rounding_type() const {
    return GetPointer<const flatbuffers::String *>(VT_ROUNDING_TYPE);
  }
  const flatbuffers::String *auto_pad() const {
    return GetPointer<const flatbuffers::String *>(VT_AUTO_PAD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<order3>(verifier, VT_KERNEL) &&
           VerifyOffset(verifier, VT_POOL_METHOD) &&
           verifier.VerifyString(pool_method()) &&
           VerifyOffset(verifier, VT_EXCLUDE_PAD) &&
           verifier.VerifyString(exclude_pad()) &&
           VerifyField<order3>(verifier, VT_STRIDES) &&
           VerifyField<order3>(verifier, VT_PADS_BEGIN) &&
           VerifyField<order3>(verifier, VT_PADS_END) &&
           VerifyOffset(verifier, VT_ROUNDING_TYPE) &&
           verifier.VerifyString(rounding_type()) &&
           VerifyOffset(verifier, VT_AUTO_PAD) &&
           verifier.VerifyString(auto_pad()) &&
           verifier.EndTable();
  }
  PoolingParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PoolingParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PoolingParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PoolingParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PoolingParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kernel(const order3 *kernel) {
    fbb_.AddStruct(PoolingParams::VT_KERNEL, kernel);
  }
  void add_pool_method(flatbuffers::Offset<flatbuffers::String> pool_method) {
    fbb_.AddOffset(PoolingParams::VT_POOL_METHOD, pool_method);
  }
  void add_exclude_pad(flatbuffers::Offset<flatbuffers::String> exclude_pad) {
    fbb_.AddOffset(PoolingParams::VT_EXCLUDE_PAD, exclude_pad);
  }
  void add_strides(const order3 *strides) {
    fbb_.AddStruct(PoolingParams::VT_STRIDES, strides);
  }
  void add_pads_begin(const order3 *pads_begin) {
    fbb_.AddStruct(PoolingParams::VT_PADS_BEGIN, pads_begin);
  }
  void add_pads_end(const order3 *pads_end) {
    fbb_.AddStruct(PoolingParams::VT_PADS_END, pads_end);
  }
  void add_rounding_type(flatbuffers::Offset<flatbuffers::String> rounding_type) {
    fbb_.AddOffset(PoolingParams::VT_ROUNDING_TYPE, rounding_type);
  }
  void add_auto_pad(flatbuffers::Offset<flatbuffers::String> auto_pad) {
    fbb_.AddOffset(PoolingParams::VT_AUTO_PAD, auto_pad);
  }
  explicit PoolingParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PoolingParamsBuilder &operator=(const PoolingParamsBuilder &);
  flatbuffers::Offset<PoolingParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PoolingParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<PoolingParams> CreatePoolingParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    const order3 *kernel = 0,
    flatbuffers::Offset<flatbuffers::String> pool_method = 0,
    flatbuffers::Offset<flatbuffers::String> exclude_pad = 0,
    const order3 *strides = 0,
    const order3 *pads_begin = 0,
    const order3 *pads_end = 0,
    flatbuffers::Offset<flatbuffers::String> rounding_type = 0,
    flatbuffers::Offset<flatbuffers::String> auto_pad = 0) {
  PoolingParamsBuilder builder_(_fbb);
  builder_.add_auto_pad(auto_pad);
  builder_.add_rounding_type(rounding_type);
  builder_.add_pads_end(pads_end);
  builder_.add_pads_begin(pads_begin);
  builder_.add_strides(strides);
  builder_.add_exclude_pad(exclude_pad);
  builder_.add_pool_method(pool_method);
  builder_.add_kernel(kernel);
  return builder_.Finish();
}

inline flatbuffers::Offset<PoolingParams> CreatePoolingParamsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const order3 *kernel = 0,
    const char *pool_method = nullptr,
    const char *exclude_pad = nullptr,
    const order3 *strides = 0,
    const order3 *pads_begin = 0,
    const order3 *pads_end = 0,
    const char *rounding_type = nullptr,
    const char *auto_pad = nullptr) {
  auto pool_method__ = pool_method ? _fbb.CreateString(pool_method) : 0;
  auto exclude_pad__ = exclude_pad ? _fbb.CreateString(exclude_pad) : 0;
  auto rounding_type__ = rounding_type ? _fbb.CreateString(rounding_type) : 0;
  auto auto_pad__ = auto_pad ? _fbb.CreateString(auto_pad) : 0;
  return MVCNN::CreatePoolingParams(
      _fbb,
      kernel,
      pool_method__,
      exclude_pad__,
      strides,
      pads_begin,
      pads_end,
      rounding_type__,
      auto_pad__);
}

flatbuffers::Offset<PoolingParams> CreatePoolingParams(flatbuffers::FlatBufferBuilder &_fbb, const PoolingParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TileParamsT : public flatbuffers::NativeTable {
  typedef TileParams TableType;
  uint32_t axis;
  uint32_t tiles;
  TileParamsT()
      : axis(0),
        tiles(0) {
  }
};

struct TileParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TileParamsT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_TILES = 6
  };
  uint32_t axis() const {
    return GetField<uint32_t>(VT_AXIS, 0);
  }
  uint32_t tiles() const {
    return GetField<uint32_t>(VT_TILES, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_AXIS) &&
           VerifyField<uint32_t>(verifier, VT_TILES) &&
           verifier.EndTable();
  }
  TileParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TileParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TileParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TileParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TileParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(uint32_t axis) {
    fbb_.AddElement<uint32_t>(TileParams::VT_AXIS, axis, 0);
  }
  void add_tiles(uint32_t tiles) {
    fbb_.AddElement<uint32_t>(TileParams::VT_TILES, tiles, 0);
  }
  explicit TileParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TileParamsBuilder &operator=(const TileParamsBuilder &);
  flatbuffers::Offset<TileParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TileParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<TileParams> CreateTileParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t axis = 0,
    uint32_t tiles = 0) {
  TileParamsBuilder builder_(_fbb);
  builder_.add_tiles(tiles);
  builder_.add_axis(axis);
  return builder_.Finish();
}

flatbuffers::Offset<TileParams> CreateTileParams(flatbuffers::FlatBufferBuilder &_fbb, const TileParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LeakyReluParamsT : public flatbuffers::NativeTable {
  typedef LeakyReluParams TableType;
  float negative_slope;
  LeakyReluParamsT()
      : negative_slope(0.0f) {
  }
};

struct LeakyReluParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LeakyReluParamsT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NEGATIVE_SLOPE = 4
  };
  float negative_slope() const {
    return GetField<float>(VT_NEGATIVE_SLOPE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_NEGATIVE_SLOPE) &&
           verifier.EndTable();
  }
  LeakyReluParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LeakyReluParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LeakyReluParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LeakyReluParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_negative_slope(float negative_slope) {
    fbb_.AddElement<float>(LeakyReluParams::VT_NEGATIVE_SLOPE, negative_slope, 0.0f);
  }
  explicit LeakyReluParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LeakyReluParamsBuilder &operator=(const LeakyReluParamsBuilder &);
  flatbuffers::Offset<LeakyReluParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LeakyReluParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<LeakyReluParams> CreateLeakyReluParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    float negative_slope = 0.0f) {
  LeakyReluParamsBuilder builder_(_fbb);
  builder_.add_negative_slope(negative_slope);
  return builder_.Finish();
}

flatbuffers::Offset<LeakyReluParams> CreateLeakyReluParams(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SigmoidParamsT : public flatbuffers::NativeTable {
  typedef SigmoidParams TableType;
  SigmoidParamsT() {
  }
};

struct SigmoidParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SigmoidParamsT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SigmoidParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SigmoidParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SigmoidParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SigmoidParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SigmoidParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SigmoidParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SigmoidParamsBuilder &operator=(const SigmoidParamsBuilder &);
  flatbuffers::Offset<SigmoidParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SigmoidParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<SigmoidParams> CreateSigmoidParams(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SigmoidParamsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SigmoidParams> CreateSigmoidParams(flatbuffers::FlatBufferBuilder &_fbb, const SigmoidParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnaryOpParamsT : public flatbuffers::NativeTable {
  typedef UnaryOpParams TableType;
  UnaryOpNestedParamsUnion nested_params;
  UnaryOpParamsT() {
  }
};

struct UnaryOpParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnaryOpParamsT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NESTED_PARAMS_TYPE = 4,
    VT_NESTED_PARAMS = 6
  };
  UnaryOpNestedParams nested_params_type() const {
    return static_cast<UnaryOpNestedParams>(GetField<uint8_t>(VT_NESTED_PARAMS_TYPE, 0));
  }
  const void *nested_params() const {
    return GetPointer<const void *>(VT_NESTED_PARAMS);
  }
  template<typename T> const T *nested_params_as() const;
  const LeakyReluParams *nested_params_as_LeakyReluParams() const {
    return nested_params_type() == UnaryOpNestedParams_LeakyReluParams ? static_cast<const LeakyReluParams *>(nested_params()) : nullptr;
  }
  const SigmoidParams *nested_params_as_SigmoidParams() const {
    return nested_params_type() == UnaryOpNestedParams_SigmoidParams ? static_cast<const SigmoidParams *>(nested_params()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_NESTED_PARAMS_TYPE) &&
           VerifyOffset(verifier, VT_NESTED_PARAMS) &&
           VerifyUnaryOpNestedParams(verifier, nested_params(), nested_params_type()) &&
           verifier.EndTable();
  }
  UnaryOpParamsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnaryOpParamsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UnaryOpParams> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnaryOpParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const LeakyReluParams *UnaryOpParams::nested_params_as<LeakyReluParams>() const {
  return nested_params_as_LeakyReluParams();
}

template<> inline const SigmoidParams *UnaryOpParams::nested_params_as<SigmoidParams>() const {
  return nested_params_as_SigmoidParams();
}

struct UnaryOpParamsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_nested_params_type(UnaryOpNestedParams nested_params_type) {
    fbb_.AddElement<uint8_t>(UnaryOpParams::VT_NESTED_PARAMS_TYPE, static_cast<uint8_t>(nested_params_type), 0);
  }
  void add_nested_params(flatbuffers::Offset<void> nested_params) {
    fbb_.AddOffset(UnaryOpParams::VT_NESTED_PARAMS, nested_params);
  }
  explicit UnaryOpParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnaryOpParamsBuilder &operator=(const UnaryOpParamsBuilder &);
  flatbuffers::Offset<UnaryOpParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnaryOpParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnaryOpParams> CreateUnaryOpParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    UnaryOpNestedParams nested_params_type = UnaryOpNestedParams_NONE,
    flatbuffers::Offset<void> nested_params = 0) {
  UnaryOpParamsBuilder builder_(_fbb);
  builder_.add_nested_params(nested_params);
  builder_.add_nested_params_type(nested_params_type);
  return builder_.Finish();
}

flatbuffers::Offset<UnaryOpParams> CreateUnaryOpParams(flatbuffers::FlatBufferBuilder &_fbb, const UnaryOpParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UPALayerTaskT : public flatbuffers::NativeTable {
  typedef UPALayerTask TableType;
  uint8_t maxShaves;
  SoftwareLayerParamsUnion softLayerParams;
  std::unique_ptr<TensorReferenceT> input_data;
  std::unique_ptr<TensorReferenceT> output_data;
  std::unique_ptr<TensorReferenceT> weights_data;
  std::unique_ptr<TensorReferenceT> weights_table;
  std::vector<std::unique_ptr<TensorReferenceT>> inputs;
  std::vector<std::unique_ptr<TensorReferenceT>> outputs;
  bool isTrailingSWLayer;
  UPALayerTaskT()
      : maxShaves(0),
        isTrailingSWLayer(false) {
  }
};

struct UPALayerTask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UPALayerTaskT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAXSHAVES = 4,
    VT_SOFTLAYERPARAMS_TYPE = 6,
    VT_SOFTLAYERPARAMS = 8,
    VT_INPUT_DATA = 10,
    VT_OUTPUT_DATA = 12,
    VT_WEIGHTS_DATA = 14,
    VT_WEIGHTS_TABLE = 16,
    VT_INPUTS = 18,
    VT_OUTPUTS = 20,
    VT_ISTRAILINGSWLAYER = 22
  };
  uint8_t maxShaves() const {
    return GetField<uint8_t>(VT_MAXSHAVES, 0);
  }
  SoftwareLayerParams softLayerParams_type() const {
    return static_cast<SoftwareLayerParams>(GetField<uint8_t>(VT_SOFTLAYERPARAMS_TYPE, 0));
  }
  const void *softLayerParams() const {
    return GetPointer<const void *>(VT_SOFTLAYERPARAMS);
  }
  template<typename T> const T *softLayerParams_as() const;
  const DummyParams *softLayerParams_as_DummyParams() const {
    return softLayerParams_type() == SoftwareLayerParams_DummyParams ? static_cast<const DummyParams *>(softLayerParams()) : nullptr;
  }
  const DetectionOutputParams *softLayerParams_as_DetectionOutputParams() const {
    return softLayerParams_type() == SoftwareLayerParams_DetectionOutputParams ? static_cast<const DetectionOutputParams *>(softLayerParams()) : nullptr;
  }
  const FlattenParams *softLayerParams_as_FlattenParams() const {
    return softLayerParams_type() == SoftwareLayerParams_FlattenParams ? static_cast<const FlattenParams *>(softLayerParams()) : nullptr;
  }
  const InterpParams *softLayerParams_as_InterpParams() const {
    return softLayerParams_type() == SoftwareLayerParams_InterpParams ? static_cast<const InterpParams *>(softLayerParams()) : nullptr;
  }
  const NormalizeParams *softLayerParams_as_NormalizeParams() const {
    return softLayerParams_type() == SoftwareLayerParams_NormalizeParams ? static_cast<const NormalizeParams *>(softLayerParams()) : nullptr;
  }
  const PermuteParams *softLayerParams_as_PermuteParams() const {
    return softLayerParams_type() == SoftwareLayerParams_PermuteParams ? static_cast<const PermuteParams *>(softLayerParams()) : nullptr;
  }
  const PriorboxParams *softLayerParams_as_PriorboxParams() const {
    return softLayerParams_type() == SoftwareLayerParams_PriorboxParams ? static_cast<const PriorboxParams *>(softLayerParams()) : nullptr;
  }
  const ProposalParams *softLayerParams_as_ProposalParams() const {
    return softLayerParams_type() == SoftwareLayerParams_ProposalParams ? static_cast<const ProposalParams *>(softLayerParams()) : nullptr;
  }
  const RegionYOLOParams *softLayerParams_as_RegionYOLOParams() const {
    return softLayerParams_type() == SoftwareLayerParams_RegionYOLOParams ? static_cast<const RegionYOLOParams *>(softLayerParams()) : nullptr;
  }
  const ReorgYOLOParams *softLayerParams_as_ReorgYOLOParams() const {
    return softLayerParams_type() == SoftwareLayerParams_ReorgYOLOParams ? static_cast<const ReorgYOLOParams *>(softLayerParams()) : nullptr;
  }
  const ReshapeParams *softLayerParams_as_ReshapeParams() const {
    return softLayerParams_type() == SoftwareLayerParams_ReshapeParams ? static_cast<const ReshapeParams *>(softLayerParams()) : nullptr;
  }
  const SoftmaxParams *softLayerParams_as_SoftmaxParams() const {
    return softLayerParams_type() == SoftwareLayerParams_SoftmaxParams ? static_cast<const SoftmaxParams *>(softLayerParams()) : nullptr;
  }
  const CustomLayerParams *softLayerParams_as_CustomLayerParams() const {
    return softLayerParams_type() == SoftwareLayerParams_CustomLayerParams ? static_cast<const CustomLayerParams *>(softLayerParams()) : nullptr;
  }
  const PassthroughParams *softLayerParams_as_PassthroughParams() const {
    return softLayerParams_type() == SoftwareLayerParams_PassthroughParams ? static_cast<const PassthroughParams *>(softLayerParams()) : nullptr;
  }
  const LayerRecordParams *softLayerParams_as_LayerRecordParams() const {
    return softLayerParams_type() == SoftwareLayerParams_LayerRecordParams ? static_cast<const LayerRecordParams *>(softLayerParams()) : nullptr;
  }
  const ROIPoolingParams *softLayerParams_as_ROIPoolingParams() const {
    return softLayerParams_type() == SoftwareLayerParams_ROIPoolingParams ? static_cast<const ROIPoolingParams *>(softLayerParams()) : nullptr;
  }
  const QuantizeParams *softLayerParams_as_QuantizeParams() const {
    return softLayerParams_type() == SoftwareLayerParams_QuantizeParams ? static_cast<const QuantizeParams *>(softLayerParams()) : nullptr;
  }
  const ArgMaxParams *softLayerParams_as_ArgMaxParams() const {
    return softLayerParams_type() == SoftwareLayerParams_ArgMaxParams ? static_cast<const ArgMaxParams *>(softLayerParams()) : nullptr;
  }
  const NormParams *softLayerParams_as_NormParams() const {
    return softLayerParams_type() == SoftwareLayerParams_NormParams ? static_cast<const NormParams *>(softLayerParams()) : nullptr;
  }
  const EltwiseParams *softLayerParams_as_EltwiseParams() const {
    return softLayerParams_type() == SoftwareLayerParams_EltwiseParams ? static_cast<const EltwiseParams *>(softLayerParams()) : nullptr;
  }
  const ResampleParams *softLayerParams_as_ResampleParams() const {
    return softLayerParams_type() == SoftwareLayerParams_ResampleParams ? static_cast<const ResampleParams *>(softLayerParams()) : nullptr;
  }
  const CorrelationParams *softLayerParams_as_CorrelationParams() const {
    return softLayerParams_type() == SoftwareLayerParams_CorrelationParams ? static_cast<const CorrelationParams *>(softLayerParams()) : nullptr;
  }
  const MVNParams *softLayerParams_as_MVNParams() const {
    return softLayerParams_type() == SoftwareLayerParams_MVNParams ? static_cast<const MVNParams *>(softLayerParams()) : nullptr;
  }
  const GRNParams *softLayerParams_as_GRNParams() const {
    return softLayerParams_type() == SoftwareLayerParams_GRNParams ? static_cast<const GRNParams *>(softLayerParams()) : nullptr;
  }
  const CTCDecoderParams *softLayerParams_as_CTCDecoderParams() const {
    return softLayerParams_type() == SoftwareLayerParams_CTCDecoderParams ? static_cast<const CTCDecoderParams *>(softLayerParams()) : nullptr;
  }
  const SpatialTransformParams *softLayerParams_as_SpatialTransformParams() const {
    return softLayerParams_type() == SoftwareLayerParams_SpatialTransformParams ? static_cast<const SpatialTransformParams *>(softLayerParams()) : nullptr;
  }
  const FakeQuantizeParams *softLayerParams_as_FakeQuantizeParams() const {
    return softLayerParams_type() == SoftwareLayerParams_FakeQuantizeParams ? static_cast<const FakeQuantizeParams *>(softLayerParams()) : nullptr;
  }
  const PoolingParams *softLayerParams_as_PoolingParams() const {
    return softLayerParams_type() == SoftwareLayerParams_PoolingParams ? static_cast<const PoolingParams *>(softLayerParams()) : nullptr;
  }
  const EdslParams *softLayerParams_as_EdslParams() const {
    return softLayerParams_type() == SoftwareLayerParams_EdslParams ? static_cast<const EdslParams *>(softLayerParams()) : nullptr;
  }
  const TileParams *softLayerParams_as_TileParams() const {
    return softLayerParams_type() == SoftwareLayerParams_TileParams ? static_cast<const TileParams *>(softLayerParams()) : nullptr;
  }
  const PSROIPoolingParams *softLayerParams_as_PSROIPoolingParams() const {
    return softLayerParams_type() == SoftwareLayerParams_PSROIPoolingParams ? static_cast<const PSROIPoolingParams *>(softLayerParams()) : nullptr;
  }
  const DeconvolutionParams *softLayerParams_as_DeconvolutionParams() const {
    return softLayerParams_type() == SoftwareLayerParams_DeconvolutionParams ? static_cast<const DeconvolutionParams *>(softLayerParams()) : nullptr;
  }
  const UnaryOpParams *softLayerParams_as_UnaryOpParams() const {
    return softLayerParams_type() == SoftwareLayerParams_UnaryOpParams ? static_cast<const UnaryOpParams *>(softLayerParams()) : nullptr;
  }
  const TensorReference *input_data() const {
    return GetPointer<const TensorReference *>(VT_INPUT_DATA);
  }
  const TensorReference *output_data() const {
    return GetPointer<const TensorReference *>(VT_OUTPUT_DATA);
  }
  const TensorReference *weights_data() const {
    return GetPointer<const TensorReference *>(VT_WEIGHTS_DATA);
  }
  const TensorReference *weights_table() const {
    return GetPointer<const TensorReference *>(VT_WEIGHTS_TABLE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TensorReference>> *inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TensorReference>> *>(VT_INPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TensorReference>> *outputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TensorReference>> *>(VT_OUTPUTS);
  }
  bool isTrailingSWLayer() const {
    return GetField<uint8_t>(VT_ISTRAILINGSWLAYER, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MAXSHAVES) &&
           VerifyField<uint8_t>(verifier, VT_SOFTLAYERPARAMS_TYPE) &&
           VerifyOffset(verifier, VT_SOFTLAYERPARAMS) &&
           VerifySoftwareLayerParams(verifier, softLayerParams(), softLayerParams_type()) &&
           VerifyOffset(verifier, VT_INPUT_DATA) &&
           verifier.VerifyTable(input_data()) &&
           VerifyOffset(verifier, VT_OUTPUT_DATA) &&
           verifier.VerifyTable(output_data()) &&
           VerifyOffset(verifier, VT_WEIGHTS_DATA) &&
           verifier.VerifyTable(weights_data()) &&
           VerifyOffset(verifier, VT_WEIGHTS_TABLE) &&
           verifier.VerifyTable(weights_table()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           verifier.VerifyVectorOfTables(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfTables(outputs()) &&
           VerifyField<uint8_t>(verifier, VT_ISTRAILINGSWLAYER) &&
           verifier.EndTable();
  }
  UPALayerTaskT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UPALayerTaskT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UPALayerTask> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UPALayerTaskT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const DummyParams *UPALayerTask::softLayerParams_as<DummyParams>() const {
  return softLayerParams_as_DummyParams();
}

template<> inline const DetectionOutputParams *UPALayerTask::softLayerParams_as<DetectionOutputParams>() const {
  return softLayerParams_as_DetectionOutputParams();
}

template<> inline const FlattenParams *UPALayerTask::softLayerParams_as<FlattenParams>() const {
  return softLayerParams_as_FlattenParams();
}

template<> inline const InterpParams *UPALayerTask::softLayerParams_as<InterpParams>() const {
  return softLayerParams_as_InterpParams();
}

template<> inline const NormalizeParams *UPALayerTask::softLayerParams_as<NormalizeParams>() const {
  return softLayerParams_as_NormalizeParams();
}

template<> inline const PermuteParams *UPALayerTask::softLayerParams_as<PermuteParams>() const {
  return softLayerParams_as_PermuteParams();
}

template<> inline const PriorboxParams *UPALayerTask::softLayerParams_as<PriorboxParams>() const {
  return softLayerParams_as_PriorboxParams();
}

template<> inline const ProposalParams *UPALayerTask::softLayerParams_as<ProposalParams>() const {
  return softLayerParams_as_ProposalParams();
}

template<> inline const RegionYOLOParams *UPALayerTask::softLayerParams_as<RegionYOLOParams>() const {
  return softLayerParams_as_RegionYOLOParams();
}

template<> inline const ReorgYOLOParams *UPALayerTask::softLayerParams_as<ReorgYOLOParams>() const {
  return softLayerParams_as_ReorgYOLOParams();
}

template<> inline const ReshapeParams *UPALayerTask::softLayerParams_as<ReshapeParams>() const {
  return softLayerParams_as_ReshapeParams();
}

template<> inline const SoftmaxParams *UPALayerTask::softLayerParams_as<SoftmaxParams>() const {
  return softLayerParams_as_SoftmaxParams();
}

template<> inline const CustomLayerParams *UPALayerTask::softLayerParams_as<CustomLayerParams>() const {
  return softLayerParams_as_CustomLayerParams();
}

template<> inline const PassthroughParams *UPALayerTask::softLayerParams_as<PassthroughParams>() const {
  return softLayerParams_as_PassthroughParams();
}

template<> inline const LayerRecordParams *UPALayerTask::softLayerParams_as<LayerRecordParams>() const {
  return softLayerParams_as_LayerRecordParams();
}

template<> inline const ROIPoolingParams *UPALayerTask::softLayerParams_as<ROIPoolingParams>() const {
  return softLayerParams_as_ROIPoolingParams();
}

template<> inline const QuantizeParams *UPALayerTask::softLayerParams_as<QuantizeParams>() const {
  return softLayerParams_as_QuantizeParams();
}

template<> inline const ArgMaxParams *UPALayerTask::softLayerParams_as<ArgMaxParams>() const {
  return softLayerParams_as_ArgMaxParams();
}

template<> inline const NormParams *UPALayerTask::softLayerParams_as<NormParams>() const {
  return softLayerParams_as_NormParams();
}

template<> inline const EltwiseParams *UPALayerTask::softLayerParams_as<EltwiseParams>() const {
  return softLayerParams_as_EltwiseParams();
}

template<> inline const ResampleParams *UPALayerTask::softLayerParams_as<ResampleParams>() const {
  return softLayerParams_as_ResampleParams();
}

template<> inline const CorrelationParams *UPALayerTask::softLayerParams_as<CorrelationParams>() const {
  return softLayerParams_as_CorrelationParams();
}

template<> inline const MVNParams *UPALayerTask::softLayerParams_as<MVNParams>() const {
  return softLayerParams_as_MVNParams();
}

template<> inline const GRNParams *UPALayerTask::softLayerParams_as<GRNParams>() const {
  return softLayerParams_as_GRNParams();
}

template<> inline const CTCDecoderParams *UPALayerTask::softLayerParams_as<CTCDecoderParams>() const {
  return softLayerParams_as_CTCDecoderParams();
}

template<> inline const SpatialTransformParams *UPALayerTask::softLayerParams_as<SpatialTransformParams>() const {
  return softLayerParams_as_SpatialTransformParams();
}

template<> inline const FakeQuantizeParams *UPALayerTask::softLayerParams_as<FakeQuantizeParams>() const {
  return softLayerParams_as_FakeQuantizeParams();
}

template<> inline const PoolingParams *UPALayerTask::softLayerParams_as<PoolingParams>() const {
  return softLayerParams_as_PoolingParams();
}

template<> inline const EdslParams *UPALayerTask::softLayerParams_as<EdslParams>() const {
  return softLayerParams_as_EdslParams();
}

template<> inline const TileParams *UPALayerTask::softLayerParams_as<TileParams>() const {
  return softLayerParams_as_TileParams();
}

template<> inline const PSROIPoolingParams *UPALayerTask::softLayerParams_as<PSROIPoolingParams>() const {
  return softLayerParams_as_PSROIPoolingParams();
}

template<> inline const DeconvolutionParams *UPALayerTask::softLayerParams_as<DeconvolutionParams>() const {
  return softLayerParams_as_DeconvolutionParams();
}

template<> inline const UnaryOpParams *UPALayerTask::softLayerParams_as<UnaryOpParams>() const {
  return softLayerParams_as_UnaryOpParams();
}

struct UPALayerTaskBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_maxShaves(uint8_t maxShaves) {
    fbb_.AddElement<uint8_t>(UPALayerTask::VT_MAXSHAVES, maxShaves, 0);
  }
  void add_softLayerParams_type(SoftwareLayerParams softLayerParams_type) {
    fbb_.AddElement<uint8_t>(UPALayerTask::VT_SOFTLAYERPARAMS_TYPE, static_cast<uint8_t>(softLayerParams_type), 0);
  }
  void add_softLayerParams(flatbuffers::Offset<void> softLayerParams) {
    fbb_.AddOffset(UPALayerTask::VT_SOFTLAYERPARAMS, softLayerParams);
  }
  void add_input_data(flatbuffers::Offset<TensorReference> input_data) {
    fbb_.AddOffset(UPALayerTask::VT_INPUT_DATA, input_data);
  }
  void add_output_data(flatbuffers::Offset<TensorReference> output_data) {
    fbb_.AddOffset(UPALayerTask::VT_OUTPUT_DATA, output_data);
  }
  void add_weights_data(flatbuffers::Offset<TensorReference> weights_data) {
    fbb_.AddOffset(UPALayerTask::VT_WEIGHTS_DATA, weights_data);
  }
  void add_weights_table(flatbuffers::Offset<TensorReference> weights_table) {
    fbb_.AddOffset(UPALayerTask::VT_WEIGHTS_TABLE, weights_table);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TensorReference>>> inputs) {
    fbb_.AddOffset(UPALayerTask::VT_INPUTS, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TensorReference>>> outputs) {
    fbb_.AddOffset(UPALayerTask::VT_OUTPUTS, outputs);
  }
  void add_isTrailingSWLayer(bool isTrailingSWLayer) {
    fbb_.AddElement<uint8_t>(UPALayerTask::VT_ISTRAILINGSWLAYER, static_cast<uint8_t>(isTrailingSWLayer), 0);
  }
  explicit UPALayerTaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UPALayerTaskBuilder &operator=(const UPALayerTaskBuilder &);
  flatbuffers::Offset<UPALayerTask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UPALayerTask>(end);
    return o;
  }
};

inline flatbuffers::Offset<UPALayerTask> CreateUPALayerTask(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t maxShaves = 0,
    SoftwareLayerParams softLayerParams_type = SoftwareLayerParams_NONE,
    flatbuffers::Offset<void> softLayerParams = 0,
    flatbuffers::Offset<TensorReference> input_data = 0,
    flatbuffers::Offset<TensorReference> output_data = 0,
    flatbuffers::Offset<TensorReference> weights_data = 0,
    flatbuffers::Offset<TensorReference> weights_table = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TensorReference>>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TensorReference>>> outputs = 0,
    bool isTrailingSWLayer = false) {
  UPALayerTaskBuilder builder_(_fbb);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_weights_table(weights_table);
  builder_.add_weights_data(weights_data);
  builder_.add_output_data(output_data);
  builder_.add_input_data(input_data);
  builder_.add_softLayerParams(softLayerParams);
  builder_.add_isTrailingSWLayer(isTrailingSWLayer);
  builder_.add_softLayerParams_type(softLayerParams_type);
  builder_.add_maxShaves(maxShaves);
  return builder_.Finish();
}

inline flatbuffers::Offset<UPALayerTask> CreateUPALayerTaskDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t maxShaves = 0,
    SoftwareLayerParams softLayerParams_type = SoftwareLayerParams_NONE,
    flatbuffers::Offset<void> softLayerParams = 0,
    flatbuffers::Offset<TensorReference> input_data = 0,
    flatbuffers::Offset<TensorReference> output_data = 0,
    flatbuffers::Offset<TensorReference> weights_data = 0,
    flatbuffers::Offset<TensorReference> weights_table = 0,
    const std::vector<flatbuffers::Offset<TensorReference>> *inputs = nullptr,
    const std::vector<flatbuffers::Offset<TensorReference>> *outputs = nullptr,
    bool isTrailingSWLayer = false) {
  auto inputs__ = inputs ? _fbb.CreateVector<flatbuffers::Offset<TensorReference>>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<flatbuffers::Offset<TensorReference>>(*outputs) : 0;
  return MVCNN::CreateUPALayerTask(
      _fbb,
      maxShaves,
      softLayerParams_type,
      softLayerParams,
      input_data,
      output_data,
      weights_data,
      weights_table,
      inputs__,
      outputs__,
      isTrailingSWLayer);
}

flatbuffers::Offset<UPALayerTask> CreateUPALayerTask(flatbuffers::FlatBufferBuilder &_fbb, const UPALayerTaskT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SNNLayerTaskT : public flatbuffers::NativeTable {
  typedef SNNLayerTask TableType;
  SoftwareLayerParamsUnion softLayerParams;
  SNNLayerTaskT() {
  }
};

struct SNNLayerTask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SNNLayerTaskT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SOFTLAYERPARAMS_TYPE = 4,
    VT_SOFTLAYERPARAMS = 6
  };
  SoftwareLayerParams softLayerParams_type() const {
    return static_cast<SoftwareLayerParams>(GetField<uint8_t>(VT_SOFTLAYERPARAMS_TYPE, 0));
  }
  const void *softLayerParams() const {
    return GetPointer<const void *>(VT_SOFTLAYERPARAMS);
  }
  template<typename T> const T *softLayerParams_as() const;
  const DummyParams *softLayerParams_as_DummyParams() const {
    return softLayerParams_type() == SoftwareLayerParams_DummyParams ? static_cast<const DummyParams *>(softLayerParams()) : nullptr;
  }
  const DetectionOutputParams *softLayerParams_as_DetectionOutputParams() const {
    return softLayerParams_type() == SoftwareLayerParams_DetectionOutputParams ? static_cast<const DetectionOutputParams *>(softLayerParams()) : nullptr;
  }
  const FlattenParams *softLayerParams_as_FlattenParams() const {
    return softLayerParams_type() == SoftwareLayerParams_FlattenParams ? static_cast<const FlattenParams *>(softLayerParams()) : nullptr;
  }
  const InterpParams *softLayerParams_as_InterpParams() const {
    return softLayerParams_type() == SoftwareLayerParams_InterpParams ? static_cast<const InterpParams *>(softLayerParams()) : nullptr;
  }
  const NormalizeParams *softLayerParams_as_NormalizeParams() const {
    return softLayerParams_type() == SoftwareLayerParams_NormalizeParams ? static_cast<const NormalizeParams *>(softLayerParams()) : nullptr;
  }
  const PermuteParams *softLayerParams_as_PermuteParams() const {
    return softLayerParams_type() == SoftwareLayerParams_PermuteParams ? static_cast<const PermuteParams *>(softLayerParams()) : nullptr;
  }
  const PriorboxParams *softLayerParams_as_PriorboxParams() const {
    return softLayerParams_type() == SoftwareLayerParams_PriorboxParams ? static_cast<const PriorboxParams *>(softLayerParams()) : nullptr;
  }
  const ProposalParams *softLayerParams_as_ProposalParams() const {
    return softLayerParams_type() == SoftwareLayerParams_ProposalParams ? static_cast<const ProposalParams *>(softLayerParams()) : nullptr;
  }
  const RegionYOLOParams *softLayerParams_as_RegionYOLOParams() const {
    return softLayerParams_type() == SoftwareLayerParams_RegionYOLOParams ? static_cast<const RegionYOLOParams *>(softLayerParams()) : nullptr;
  }
  const ReorgYOLOParams *softLayerParams_as_ReorgYOLOParams() const {
    return softLayerParams_type() == SoftwareLayerParams_ReorgYOLOParams ? static_cast<const ReorgYOLOParams *>(softLayerParams()) : nullptr;
  }
  const ReshapeParams *softLayerParams_as_ReshapeParams() const {
    return softLayerParams_type() == SoftwareLayerParams_ReshapeParams ? static_cast<const ReshapeParams *>(softLayerParams()) : nullptr;
  }
  const SoftmaxParams *softLayerParams_as_SoftmaxParams() const {
    return softLayerParams_type() == SoftwareLayerParams_SoftmaxParams ? static_cast<const SoftmaxParams *>(softLayerParams()) : nullptr;
  }
  const CustomLayerParams *softLayerParams_as_CustomLayerParams() const {
    return softLayerParams_type() == SoftwareLayerParams_CustomLayerParams ? static_cast<const CustomLayerParams *>(softLayerParams()) : nullptr;
  }
  const PassthroughParams *softLayerParams_as_PassthroughParams() const {
    return softLayerParams_type() == SoftwareLayerParams_PassthroughParams ? static_cast<const PassthroughParams *>(softLayerParams()) : nullptr;
  }
  const LayerRecordParams *softLayerParams_as_LayerRecordParams() const {
    return softLayerParams_type() == SoftwareLayerParams_LayerRecordParams ? static_cast<const LayerRecordParams *>(softLayerParams()) : nullptr;
  }
  const ROIPoolingParams *softLayerParams_as_ROIPoolingParams() const {
    return softLayerParams_type() == SoftwareLayerParams_ROIPoolingParams ? static_cast<const ROIPoolingParams *>(softLayerParams()) : nullptr;
  }
  const QuantizeParams *softLayerParams_as_QuantizeParams() const {
    return softLayerParams_type() == SoftwareLayerParams_QuantizeParams ? static_cast<const QuantizeParams *>(softLayerParams()) : nullptr;
  }
  const ArgMaxParams *softLayerParams_as_ArgMaxParams() const {
    return softLayerParams_type() == SoftwareLayerParams_ArgMaxParams ? static_cast<const ArgMaxParams *>(softLayerParams()) : nullptr;
  }
  const NormParams *softLayerParams_as_NormParams() const {
    return softLayerParams_type() == SoftwareLayerParams_NormParams ? static_cast<const NormParams *>(softLayerParams()) : nullptr;
  }
  const EltwiseParams *softLayerParams_as_EltwiseParams() const {
    return softLayerParams_type() == SoftwareLayerParams_EltwiseParams ? static_cast<const EltwiseParams *>(softLayerParams()) : nullptr;
  }
  const ResampleParams *softLayerParams_as_ResampleParams() const {
    return softLayerParams_type() == SoftwareLayerParams_ResampleParams ? static_cast<const ResampleParams *>(softLayerParams()) : nullptr;
  }
  const CorrelationParams *softLayerParams_as_CorrelationParams() const {
    return softLayerParams_type() == SoftwareLayerParams_CorrelationParams ? static_cast<const CorrelationParams *>(softLayerParams()) : nullptr;
  }
  const MVNParams *softLayerParams_as_MVNParams() const {
    return softLayerParams_type() == SoftwareLayerParams_MVNParams ? static_cast<const MVNParams *>(softLayerParams()) : nullptr;
  }
  const GRNParams *softLayerParams_as_GRNParams() const {
    return softLayerParams_type() == SoftwareLayerParams_GRNParams ? static_cast<const GRNParams *>(softLayerParams()) : nullptr;
  }
  const CTCDecoderParams *softLayerParams_as_CTCDecoderParams() const {
    return softLayerParams_type() == SoftwareLayerParams_CTCDecoderParams ? static_cast<const CTCDecoderParams *>(softLayerParams()) : nullptr;
  }
  const SpatialTransformParams *softLayerParams_as_SpatialTransformParams() const {
    return softLayerParams_type() == SoftwareLayerParams_SpatialTransformParams ? static_cast<const SpatialTransformParams *>(softLayerParams()) : nullptr;
  }
  const FakeQuantizeParams *softLayerParams_as_FakeQuantizeParams() const {
    return softLayerParams_type() == SoftwareLayerParams_FakeQuantizeParams ? static_cast<const FakeQuantizeParams *>(softLayerParams()) : nullptr;
  }
  const PoolingParams *softLayerParams_as_PoolingParams() const {
    return softLayerParams_type() == SoftwareLayerParams_PoolingParams ? static_cast<const PoolingParams *>(softLayerParams()) : nullptr;
  }
  const EdslParams *softLayerParams_as_EdslParams() const {
    return softLayerParams_type() == SoftwareLayerParams_EdslParams ? static_cast<const EdslParams *>(softLayerParams()) : nullptr;
  }
  const TileParams *softLayerParams_as_TileParams() const {
    return softLayerParams_type() == SoftwareLayerParams_TileParams ? static_cast<const TileParams *>(softLayerParams()) : nullptr;
  }
  const PSROIPoolingParams *softLayerParams_as_PSROIPoolingParams() const {
    return softLayerParams_type() == SoftwareLayerParams_PSROIPoolingParams ? static_cast<const PSROIPoolingParams *>(softLayerParams()) : nullptr;
  }
  const DeconvolutionParams *softLayerParams_as_DeconvolutionParams() const {
    return softLayerParams_type() == SoftwareLayerParams_DeconvolutionParams ? static_cast<const DeconvolutionParams *>(softLayerParams()) : nullptr;
  }
  const UnaryOpParams *softLayerParams_as_UnaryOpParams() const {
    return softLayerParams_type() == SoftwareLayerParams_UnaryOpParams ? static_cast<const UnaryOpParams *>(softLayerParams()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SOFTLAYERPARAMS_TYPE) &&
           VerifyOffset(verifier, VT_SOFTLAYERPARAMS) &&
           VerifySoftwareLayerParams(verifier, softLayerParams(), softLayerParams_type()) &&
           verifier.EndTable();
  }
  SNNLayerTaskT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SNNLayerTaskT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SNNLayerTask> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SNNLayerTaskT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const DummyParams *SNNLayerTask::softLayerParams_as<DummyParams>() const {
  return softLayerParams_as_DummyParams();
}

template<> inline const DetectionOutputParams *SNNLayerTask::softLayerParams_as<DetectionOutputParams>() const {
  return softLayerParams_as_DetectionOutputParams();
}

template<> inline const FlattenParams *SNNLayerTask::softLayerParams_as<FlattenParams>() const {
  return softLayerParams_as_FlattenParams();
}

template<> inline const InterpParams *SNNLayerTask::softLayerParams_as<InterpParams>() const {
  return softLayerParams_as_InterpParams();
}

template<> inline const NormalizeParams *SNNLayerTask::softLayerParams_as<NormalizeParams>() const {
  return softLayerParams_as_NormalizeParams();
}

template<> inline const PermuteParams *SNNLayerTask::softLayerParams_as<PermuteParams>() const {
  return softLayerParams_as_PermuteParams();
}

template<> inline const PriorboxParams *SNNLayerTask::softLayerParams_as<PriorboxParams>() const {
  return softLayerParams_as_PriorboxParams();
}

template<> inline const ProposalParams *SNNLayerTask::softLayerParams_as<ProposalParams>() const {
  return softLayerParams_as_ProposalParams();
}

template<> inline const RegionYOLOParams *SNNLayerTask::softLayerParams_as<RegionYOLOParams>() const {
  return softLayerParams_as_RegionYOLOParams();
}

template<> inline const ReorgYOLOParams *SNNLayerTask::softLayerParams_as<ReorgYOLOParams>() const {
  return softLayerParams_as_ReorgYOLOParams();
}

template<> inline const ReshapeParams *SNNLayerTask::softLayerParams_as<ReshapeParams>() const {
  return softLayerParams_as_ReshapeParams();
}

template<> inline const SoftmaxParams *SNNLayerTask::softLayerParams_as<SoftmaxParams>() const {
  return softLayerParams_as_SoftmaxParams();
}

template<> inline const CustomLayerParams *SNNLayerTask::softLayerParams_as<CustomLayerParams>() const {
  return softLayerParams_as_CustomLayerParams();
}

template<> inline const PassthroughParams *SNNLayerTask::softLayerParams_as<PassthroughParams>() const {
  return softLayerParams_as_PassthroughParams();
}

template<> inline const LayerRecordParams *SNNLayerTask::softLayerParams_as<LayerRecordParams>() const {
  return softLayerParams_as_LayerRecordParams();
}

template<> inline const ROIPoolingParams *SNNLayerTask::softLayerParams_as<ROIPoolingParams>() const {
  return softLayerParams_as_ROIPoolingParams();
}

template<> inline const QuantizeParams *SNNLayerTask::softLayerParams_as<QuantizeParams>() const {
  return softLayerParams_as_QuantizeParams();
}

template<> inline const ArgMaxParams *SNNLayerTask::softLayerParams_as<ArgMaxParams>() const {
  return softLayerParams_as_ArgMaxParams();
}

template<> inline const NormParams *SNNLayerTask::softLayerParams_as<NormParams>() const {
  return softLayerParams_as_NormParams();
}

template<> inline const EltwiseParams *SNNLayerTask::softLayerParams_as<EltwiseParams>() const {
  return softLayerParams_as_EltwiseParams();
}

template<> inline const ResampleParams *SNNLayerTask::softLayerParams_as<ResampleParams>() const {
  return softLayerParams_as_ResampleParams();
}

template<> inline const CorrelationParams *SNNLayerTask::softLayerParams_as<CorrelationParams>() const {
  return softLayerParams_as_CorrelationParams();
}

template<> inline const MVNParams *SNNLayerTask::softLayerParams_as<MVNParams>() const {
  return softLayerParams_as_MVNParams();
}

template<> inline const GRNParams *SNNLayerTask::softLayerParams_as<GRNParams>() const {
  return softLayerParams_as_GRNParams();
}

template<> inline const CTCDecoderParams *SNNLayerTask::softLayerParams_as<CTCDecoderParams>() const {
  return softLayerParams_as_CTCDecoderParams();
}

template<> inline const SpatialTransformParams *SNNLayerTask::softLayerParams_as<SpatialTransformParams>() const {
  return softLayerParams_as_SpatialTransformParams();
}

template<> inline const FakeQuantizeParams *SNNLayerTask::softLayerParams_as<FakeQuantizeParams>() const {
  return softLayerParams_as_FakeQuantizeParams();
}

template<> inline const PoolingParams *SNNLayerTask::softLayerParams_as<PoolingParams>() const {
  return softLayerParams_as_PoolingParams();
}

template<> inline const EdslParams *SNNLayerTask::softLayerParams_as<EdslParams>() const {
  return softLayerParams_as_EdslParams();
}

template<> inline const TileParams *SNNLayerTask::softLayerParams_as<TileParams>() const {
  return softLayerParams_as_TileParams();
}

template<> inline const PSROIPoolingParams *SNNLayerTask::softLayerParams_as<PSROIPoolingParams>() const {
  return softLayerParams_as_PSROIPoolingParams();
}

template<> inline const DeconvolutionParams *SNNLayerTask::softLayerParams_as<DeconvolutionParams>() const {
  return softLayerParams_as_DeconvolutionParams();
}

template<> inline const UnaryOpParams *SNNLayerTask::softLayerParams_as<UnaryOpParams>() const {
  return softLayerParams_as_UnaryOpParams();
}

struct SNNLayerTaskBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_softLayerParams_type(SoftwareLayerParams softLayerParams_type) {
    fbb_.AddElement<uint8_t>(SNNLayerTask::VT_SOFTLAYERPARAMS_TYPE, static_cast<uint8_t>(softLayerParams_type), 0);
  }
  void add_softLayerParams(flatbuffers::Offset<void> softLayerParams) {
    fbb_.AddOffset(SNNLayerTask::VT_SOFTLAYERPARAMS, softLayerParams);
  }
  explicit SNNLayerTaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SNNLayerTaskBuilder &operator=(const SNNLayerTaskBuilder &);
  flatbuffers::Offset<SNNLayerTask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SNNLayerTask>(end);
    return o;
  }
};

inline flatbuffers::Offset<SNNLayerTask> CreateSNNLayerTask(
    flatbuffers::FlatBufferBuilder &_fbb,
    SoftwareLayerParams softLayerParams_type = SoftwareLayerParams_NONE,
    flatbuffers::Offset<void> softLayerParams = 0) {
  SNNLayerTaskBuilder builder_(_fbb);
  builder_.add_softLayerParams(softLayerParams);
  builder_.add_softLayerParams_type(softLayerParams_type);
  return builder_.Finish();
}

flatbuffers::Offset<SNNLayerTask> CreateSNNLayerTask(flatbuffers::FlatBufferBuilder &_fbb, const SNNLayerTaskT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TensorT : public flatbuffers::NativeTable {
  typedef Tensor TableType;
  uint32_t dimX;
  uint32_t dimY;
  uint32_t dimZ;
  uint32_t strideX;
  uint32_t strideY;
  uint32_t strideZ;
  uint32_t offset;
  uint32_t location;
  uint32_t dataType;
  uint32_t order;
  TensorT()
      : dimX(0),
        dimY(0),
        dimZ(0),
        strideX(0),
        strideY(0),
        strideZ(0),
        offset(0),
        location(0),
        dataType(0),
        order(0) {
  }
};

struct Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIMX = 4,
    VT_DIMY = 6,
    VT_DIMZ = 8,
    VT_STRIDEX = 10,
    VT_STRIDEY = 12,
    VT_STRIDEZ = 14,
    VT_OFFSET = 16,
    VT_LOCATION = 18,
    VT_DATATYPE = 20,
    VT_ORDER = 22
  };
  uint32_t dimX() const {
    return GetField<uint32_t>(VT_DIMX, 0);
  }
  uint32_t dimY() const {
    return GetField<uint32_t>(VT_DIMY, 0);
  }
  uint32_t dimZ() const {
    return GetField<uint32_t>(VT_DIMZ, 0);
  }
  uint32_t strideX() const {
    return GetField<uint32_t>(VT_STRIDEX, 0);
  }
  uint32_t strideY() const {
    return GetField<uint32_t>(VT_STRIDEY, 0);
  }
  uint32_t strideZ() const {
    return GetField<uint32_t>(VT_STRIDEZ, 0);
  }
  uint32_t offset() const {
    return GetField<uint32_t>(VT_OFFSET, 0);
  }
  uint32_t location() const {
    return GetField<uint32_t>(VT_LOCATION, 0);
  }
  uint32_t dataType() const {
    return GetField<uint32_t>(VT_DATATYPE, 0);
  }
  uint32_t order() const {
    return GetField<uint32_t>(VT_ORDER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_DIMX) &&
           VerifyField<uint32_t>(verifier, VT_DIMY) &&
           VerifyField<uint32_t>(verifier, VT_DIMZ) &&
           VerifyField<uint32_t>(verifier, VT_STRIDEX) &&
           VerifyField<uint32_t>(verifier, VT_STRIDEY) &&
           VerifyField<uint32_t>(verifier, VT_STRIDEZ) &&
           VerifyField<uint32_t>(verifier, VT_OFFSET) &&
           VerifyField<uint32_t>(verifier, VT_LOCATION) &&
           VerifyField<uint32_t>(verifier, VT_DATATYPE) &&
           VerifyField<uint32_t>(verifier, VT_ORDER) &&
           verifier.EndTable();
  }
  TensorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Tensor> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dimX(uint32_t dimX) {
    fbb_.AddElement<uint32_t>(Tensor::VT_DIMX, dimX, 0);
  }
  void add_dimY(uint32_t dimY) {
    fbb_.AddElement<uint32_t>(Tensor::VT_DIMY, dimY, 0);
  }
  void add_dimZ(uint32_t dimZ) {
    fbb_.AddElement<uint32_t>(Tensor::VT_DIMZ, dimZ, 0);
  }
  void add_strideX(uint32_t strideX) {
    fbb_.AddElement<uint32_t>(Tensor::VT_STRIDEX, strideX, 0);
  }
  void add_strideY(uint32_t strideY) {
    fbb_.AddElement<uint32_t>(Tensor::VT_STRIDEY, strideY, 0);
  }
  void add_strideZ(uint32_t strideZ) {
    fbb_.AddElement<uint32_t>(Tensor::VT_STRIDEZ, strideZ, 0);
  }
  void add_offset(uint32_t offset) {
    fbb_.AddElement<uint32_t>(Tensor::VT_OFFSET, offset, 0);
  }
  void add_location(uint32_t location) {
    fbb_.AddElement<uint32_t>(Tensor::VT_LOCATION, location, 0);
  }
  void add_dataType(uint32_t dataType) {
    fbb_.AddElement<uint32_t>(Tensor::VT_DATATYPE, dataType, 0);
  }
  void add_order(uint32_t order) {
    fbb_.AddElement<uint32_t>(Tensor::VT_ORDER, order, 0);
  }
  explicit TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TensorBuilder &operator=(const TensorBuilder &);
  flatbuffers::Offset<Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tensor> CreateTensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t dimX = 0,
    uint32_t dimY = 0,
    uint32_t dimZ = 0,
    uint32_t strideX = 0,
    uint32_t strideY = 0,
    uint32_t strideZ = 0,
    uint32_t offset = 0,
    uint32_t location = 0,
    uint32_t dataType = 0,
    uint32_t order = 0) {
  TensorBuilder builder_(_fbb);
  builder_.add_order(order);
  builder_.add_dataType(dataType);
  builder_.add_location(location);
  builder_.add_offset(offset);
  builder_.add_strideZ(strideZ);
  builder_.add_strideY(strideY);
  builder_.add_strideX(strideX);
  builder_.add_dimZ(dimZ);
  builder_.add_dimY(dimY);
  builder_.add_dimX(dimX);
  return builder_.Finish();
}

flatbuffers::Offset<Tensor> CreateTensor(flatbuffers::FlatBufferBuilder &_fbb, const TensorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Conv2DT : public flatbuffers::NativeTable {
  typedef Conv2D TableType;
  uint32_t radixX;
  uint32_t radixY;
  uint32_t strideX;
  uint32_t strideY;
  uint32_t padX;
  uint32_t padY;
  uint32_t padStyle;
  uint32_t dilation;
  std::unique_ptr<TensorReferenceT> input;
  std::unique_ptr<TensorReferenceT> output;
  std::unique_ptr<TensorReferenceT> weight;
  std::unique_ptr<TensorReferenceT> bias;
  Conv2DT()
      : radixX(0),
        radixY(0),
        strideX(0),
        strideY(0),
        padX(0),
        padY(0),
        padStyle(0),
        dilation(0) {
  }
};

struct Conv2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Conv2DT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RADIXX = 4,
    VT_RADIXY = 6,
    VT_STRIDEX = 8,
    VT_STRIDEY = 10,
    VT_PADX = 12,
    VT_PADY = 14,
    VT_PADSTYLE = 16,
    VT_DILATION = 18,
    VT_INPUT = 20,
    VT_OUTPUT = 22,
    VT_WEIGHT = 24,
    VT_BIAS = 26
  };
  uint32_t radixX() const {
    return GetField<uint32_t>(VT_RADIXX, 0);
  }
  uint32_t radixY() const {
    return GetField<uint32_t>(VT_RADIXY, 0);
  }
  uint32_t strideX() const {
    return GetField<uint32_t>(VT_STRIDEX, 0);
  }
  uint32_t strideY() const {
    return GetField<uint32_t>(VT_STRIDEY, 0);
  }
  uint32_t padX() const {
    return GetField<uint32_t>(VT_PADX, 0);
  }
  uint32_t padY() const {
    return GetField<uint32_t>(VT_PADY, 0);
  }
  uint32_t padStyle() const {
    return GetField<uint32_t>(VT_PADSTYLE, 0);
  }
  uint32_t dilation() const {
    return GetField<uint32_t>(VT_DILATION, 0);
  }
  const TensorReference *input() const {
    return GetPointer<const TensorReference *>(VT_INPUT);
  }
  const TensorReference *output() const {
    return GetPointer<const TensorReference *>(VT_OUTPUT);
  }
  const TensorReference *weight() const {
    return GetPointer<const TensorReference *>(VT_WEIGHT);
  }
  const TensorReference *bias() const {
    return GetPointer<const TensorReference *>(VT_BIAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RADIXX) &&
           VerifyField<uint32_t>(verifier, VT_RADIXY) &&
           VerifyField<uint32_t>(verifier, VT_STRIDEX) &&
           VerifyField<uint32_t>(verifier, VT_STRIDEY) &&
           VerifyField<uint32_t>(verifier, VT_PADX) &&
           VerifyField<uint32_t>(verifier, VT_PADY) &&
           VerifyField<uint32_t>(verifier, VT_PADSTYLE) &&
           VerifyField<uint32_t>(verifier, VT_DILATION) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyTable(input()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyTable(output()) &&
           VerifyOffset(verifier, VT_WEIGHT) &&
           verifier.VerifyTable(weight()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyTable(bias()) &&
           verifier.EndTable();
  }
  Conv2DT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Conv2DT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Conv2D> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Conv2DBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_radixX(uint32_t radixX) {
    fbb_.AddElement<uint32_t>(Conv2D::VT_RADIXX, radixX, 0);
  }
  void add_radixY(uint32_t radixY) {
    fbb_.AddElement<uint32_t>(Conv2D::VT_RADIXY, radixY, 0);
  }
  void add_strideX(uint32_t strideX) {
    fbb_.AddElement<uint32_t>(Conv2D::VT_STRIDEX, strideX, 0);
  }
  void add_strideY(uint32_t strideY) {
    fbb_.AddElement<uint32_t>(Conv2D::VT_STRIDEY, strideY, 0);
  }
  void add_padX(uint32_t padX) {
    fbb_.AddElement<uint32_t>(Conv2D::VT_PADX, padX, 0);
  }
  void add_padY(uint32_t padY) {
    fbb_.AddElement<uint32_t>(Conv2D::VT_PADY, padY, 0);
  }
  void add_padStyle(uint32_t padStyle) {
    fbb_.AddElement<uint32_t>(Conv2D::VT_PADSTYLE, padStyle, 0);
  }
  void add_dilation(uint32_t dilation) {
    fbb_.AddElement<uint32_t>(Conv2D::VT_DILATION, dilation, 0);
  }
  void add_input(flatbuffers::Offset<TensorReference> input) {
    fbb_.AddOffset(Conv2D::VT_INPUT, input);
  }
  void add_output(flatbuffers::Offset<TensorReference> output) {
    fbb_.AddOffset(Conv2D::VT_OUTPUT, output);
  }
  void add_weight(flatbuffers::Offset<TensorReference> weight) {
    fbb_.AddOffset(Conv2D::VT_WEIGHT, weight);
  }
  void add_bias(flatbuffers::Offset<TensorReference> bias) {
    fbb_.AddOffset(Conv2D::VT_BIAS, bias);
  }
  explicit Conv2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Conv2DBuilder &operator=(const Conv2DBuilder &);
  flatbuffers::Offset<Conv2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv2D>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv2D> CreateConv2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t radixX = 0,
    uint32_t radixY = 0,
    uint32_t strideX = 0,
    uint32_t strideY = 0,
    uint32_t padX = 0,
    uint32_t padY = 0,
    uint32_t padStyle = 0,
    uint32_t dilation = 0,
    flatbuffers::Offset<TensorReference> input = 0,
    flatbuffers::Offset<TensorReference> output = 0,
    flatbuffers::Offset<TensorReference> weight = 0,
    flatbuffers::Offset<TensorReference> bias = 0) {
  Conv2DBuilder builder_(_fbb);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_output(output);
  builder_.add_input(input);
  builder_.add_dilation(dilation);
  builder_.add_padStyle(padStyle);
  builder_.add_padY(padY);
  builder_.add_padX(padX);
  builder_.add_strideY(strideY);
  builder_.add_strideX(strideX);
  builder_.add_radixY(radixY);
  builder_.add_radixX(radixX);
  return builder_.Finish();
}

flatbuffers::Offset<Conv2D> CreateConv2D(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PoolingT : public flatbuffers::NativeTable {
  typedef Pooling TableType;
  uint32_t radixX;
  uint32_t radixY;
  uint32_t strideX;
  uint32_t strideY;
  uint32_t padX;
  uint32_t padY;
  uint32_t padStyle;
  uint32_t dilation;
  std::unique_ptr<TensorReferenceT> input;
  std::unique_ptr<TensorReferenceT> output;
  PoolingT()
      : radixX(0),
        radixY(0),
        strideX(0),
        strideY(0),
        padX(0),
        padY(0),
        padStyle(0),
        dilation(0) {
  }
};

struct Pooling FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PoolingT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RADIXX = 4,
    VT_RADIXY = 6,
    VT_STRIDEX = 8,
    VT_STRIDEY = 10,
    VT_PADX = 12,
    VT_PADY = 14,
    VT_PADSTYLE = 16,
    VT_DILATION = 18,
    VT_INPUT = 20,
    VT_OUTPUT = 22
  };
  uint32_t radixX() const {
    return GetField<uint32_t>(VT_RADIXX, 0);
  }
  uint32_t radixY() const {
    return GetField<uint32_t>(VT_RADIXY, 0);
  }
  uint32_t strideX() const {
    return GetField<uint32_t>(VT_STRIDEX, 0);
  }
  uint32_t strideY() const {
    return GetField<uint32_t>(VT_STRIDEY, 0);
  }
  uint32_t padX() const {
    return GetField<uint32_t>(VT_PADX, 0);
  }
  uint32_t padY() const {
    return GetField<uint32_t>(VT_PADY, 0);
  }
  uint32_t padStyle() const {
    return GetField<uint32_t>(VT_PADSTYLE, 0);
  }
  uint32_t dilation() const {
    return GetField<uint32_t>(VT_DILATION, 0);
  }
  const TensorReference *input() const {
    return GetPointer<const TensorReference *>(VT_INPUT);
  }
  const TensorReference *output() const {
    return GetPointer<const TensorReference *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RADIXX) &&
           VerifyField<uint32_t>(verifier, VT_RADIXY) &&
           VerifyField<uint32_t>(verifier, VT_STRIDEX) &&
           VerifyField<uint32_t>(verifier, VT_STRIDEY) &&
           VerifyField<uint32_t>(verifier, VT_PADX) &&
           VerifyField<uint32_t>(verifier, VT_PADY) &&
           VerifyField<uint32_t>(verifier, VT_PADSTYLE) &&
           VerifyField<uint32_t>(verifier, VT_DILATION) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyTable(input()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyTable(output()) &&
           verifier.EndTable();
  }
  PoolingT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PoolingT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Pooling> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PoolingT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PoolingBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_radixX(uint32_t radixX) {
    fbb_.AddElement<uint32_t>(Pooling::VT_RADIXX, radixX, 0);
  }
  void add_radixY(uint32_t radixY) {
    fbb_.AddElement<uint32_t>(Pooling::VT_RADIXY, radixY, 0);
  }
  void add_strideX(uint32_t strideX) {
    fbb_.AddElement<uint32_t>(Pooling::VT_STRIDEX, strideX, 0);
  }
  void add_strideY(uint32_t strideY) {
    fbb_.AddElement<uint32_t>(Pooling::VT_STRIDEY, strideY, 0);
  }
  void add_padX(uint32_t padX) {
    fbb_.AddElement<uint32_t>(Pooling::VT_PADX, padX, 0);
  }
  void add_padY(uint32_t padY) {
    fbb_.AddElement<uint32_t>(Pooling::VT_PADY, padY, 0);
  }
  void add_padStyle(uint32_t padStyle) {
    fbb_.AddElement<uint32_t>(Pooling::VT_PADSTYLE, padStyle, 0);
  }
  void add_dilation(uint32_t dilation) {
    fbb_.AddElement<uint32_t>(Pooling::VT_DILATION, dilation, 0);
  }
  void add_input(flatbuffers::Offset<TensorReference> input) {
    fbb_.AddOffset(Pooling::VT_INPUT, input);
  }
  void add_output(flatbuffers::Offset<TensorReference> output) {
    fbb_.AddOffset(Pooling::VT_OUTPUT, output);
  }
  explicit PoolingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PoolingBuilder &operator=(const PoolingBuilder &);
  flatbuffers::Offset<Pooling> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pooling>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pooling> CreatePooling(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t radixX = 0,
    uint32_t radixY = 0,
    uint32_t strideX = 0,
    uint32_t strideY = 0,
    uint32_t padX = 0,
    uint32_t padY = 0,
    uint32_t padStyle = 0,
    uint32_t dilation = 0,
    flatbuffers::Offset<TensorReference> input = 0,
    flatbuffers::Offset<TensorReference> output = 0) {
  PoolingBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_input(input);
  builder_.add_dilation(dilation);
  builder_.add_padStyle(padStyle);
  builder_.add_padY(padY);
  builder_.add_padX(padX);
  builder_.add_strideY(strideY);
  builder_.add_strideX(strideX);
  builder_.add_radixY(radixY);
  builder_.add_radixX(radixX);
  return builder_.Finish();
}

flatbuffers::Offset<Pooling> CreatePooling(flatbuffers::FlatBufferBuilder &_fbb, const PoolingT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReLUT : public flatbuffers::NativeTable {
  typedef ReLU TableType;
  uint32_t opX;
  std::unique_ptr<TensorReferenceT> input;
  std::unique_ptr<TensorReferenceT> output;
  uint32_t strideX;
  uint32_t strideY;
  ReLUT()
      : opX(0),
        strideX(0),
        strideY(0) {
  }
};

struct ReLU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReLUT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPX = 4,
    VT_INPUT = 6,
    VT_OUTPUT = 8,
    VT_STRIDEX = 10,
    VT_STRIDEY = 12
  };
  uint32_t opX() const {
    return GetField<uint32_t>(VT_OPX, 0);
  }
  const TensorReference *input() const {
    return GetPointer<const TensorReference *>(VT_INPUT);
  }
  const TensorReference *output() const {
    return GetPointer<const TensorReference *>(VT_OUTPUT);
  }
  uint32_t strideX() const {
    return GetField<uint32_t>(VT_STRIDEX, 0);
  }
  uint32_t strideY() const {
    return GetField<uint32_t>(VT_STRIDEY, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_OPX) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyTable(input()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyTable(output()) &&
           VerifyField<uint32_t>(verifier, VT_STRIDEX) &&
           VerifyField<uint32_t>(verifier, VT_STRIDEY) &&
           verifier.EndTable();
  }
  ReLUT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReLUT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReLU> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReLUT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReLUBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_opX(uint32_t opX) {
    fbb_.AddElement<uint32_t>(ReLU::VT_OPX, opX, 0);
  }
  void add_input(flatbuffers::Offset<TensorReference> input) {
    fbb_.AddOffset(ReLU::VT_INPUT, input);
  }
  void add_output(flatbuffers::Offset<TensorReference> output) {
    fbb_.AddOffset(ReLU::VT_OUTPUT, output);
  }
  void add_strideX(uint32_t strideX) {
    fbb_.AddElement<uint32_t>(ReLU::VT_STRIDEX, strideX, 0);
  }
  void add_strideY(uint32_t strideY) {
    fbb_.AddElement<uint32_t>(ReLU::VT_STRIDEY, strideY, 0);
  }
  explicit ReLUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReLUBuilder &operator=(const ReLUBuilder &);
  flatbuffers::Offset<ReLU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReLU>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReLU> CreateReLU(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t opX = 0,
    flatbuffers::Offset<TensorReference> input = 0,
    flatbuffers::Offset<TensorReference> output = 0,
    uint32_t strideX = 0,
    uint32_t strideY = 0) {
  ReLUBuilder builder_(_fbb);
  builder_.add_strideY(strideY);
  builder_.add_strideX(strideX);
  builder_.add_output(output);
  builder_.add_input(input);
  builder_.add_opX(opX);
  return builder_.Finish();
}

flatbuffers::Offset<ReLU> CreateReLU(flatbuffers::FlatBufferBuilder &_fbb, const ReLUT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PassthroughT : public flatbuffers::NativeTable {
  typedef Passthrough TableType;
  std::unique_ptr<TensorReferenceT> input;
  std::unique_ptr<TensorReferenceT> output;
  PassthroughT() {
  }
};

struct Passthrough FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PassthroughT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_OUTPUT = 6
  };
  const TensorReference *input() const {
    return GetPointer<const TensorReference *>(VT_INPUT);
  }
  const TensorReference *output() const {
    return GetPointer<const TensorReference *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyTable(input()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyTable(output()) &&
           verifier.EndTable();
  }
  PassthroughT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PassthroughT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Passthrough> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PassthroughT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PassthroughBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<TensorReference> input) {
    fbb_.AddOffset(Passthrough::VT_INPUT, input);
  }
  void add_output(flatbuffers::Offset<TensorReference> output) {
    fbb_.AddOffset(Passthrough::VT_OUTPUT, output);
  }
  explicit PassthroughBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PassthroughBuilder &operator=(const PassthroughBuilder &);
  flatbuffers::Offset<Passthrough> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Passthrough>(end);
    return o;
  }
};

inline flatbuffers::Offset<Passthrough> CreatePassthrough(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<TensorReference> input = 0,
    flatbuffers::Offset<TensorReference> output = 0) {
  PassthroughBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_input(input);
  return builder_.Finish();
}

flatbuffers::Offset<Passthrough> CreatePassthrough(flatbuffers::FlatBufferBuilder &_fbb, const PassthroughT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CustomT : public flatbuffers::NativeTable {
  typedef Custom TableType;
  std::vector<int8_t> data;
  std::vector<int64_t> length;
  int16_t id;
  CustomT()
      : id(0) {
  }
};

struct Custom FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CustomT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4,
    VT_LENGTH = 6,
    VT_ID = 8
  };
  const flatbuffers::Vector<int8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_DATA);
  }
  const flatbuffers::Vector<int64_t> *length() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_LENGTH);
  }
  int16_t id() const {
    return GetField<int16_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           VerifyOffset(verifier, VT_LENGTH) &&
           verifier.VerifyVector(length()) &&
           VerifyField<int16_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
  CustomT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CustomT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Custom> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CustomBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<int8_t>> data) {
    fbb_.AddOffset(Custom::VT_DATA, data);
  }
  void add_length(flatbuffers::Offset<flatbuffers::Vector<int64_t>> length) {
    fbb_.AddOffset(Custom::VT_LENGTH, length);
  }
  void add_id(int16_t id) {
    fbb_.AddElement<int16_t>(Custom::VT_ID, id, 0);
  }
  explicit CustomBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CustomBuilder &operator=(const CustomBuilder &);
  flatbuffers::Offset<Custom> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Custom>(end);
    return o;
  }
};

inline flatbuffers::Offset<Custom> CreateCustom(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> data = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> length = 0,
    int16_t id = 0) {
  CustomBuilder builder_(_fbb);
  builder_.add_length(length);
  builder_.add_data(data);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Custom> CreateCustomDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *data = nullptr,
    const std::vector<int64_t> *length = nullptr,
    int16_t id = 0) {
  auto data__ = data ? _fbb.CreateVector<int8_t>(*data) : 0;
  auto length__ = length ? _fbb.CreateVector<int64_t>(*length) : 0;
  return MVCNN::CreateCustom(
      _fbb,
      data__,
      length__,
      id);
}

flatbuffers::Offset<Custom> CreateCustom(flatbuffers::FlatBufferBuilder &_fbb, const CustomT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MvTensorTaskT : public flatbuffers::NativeTable {
  typedef MvTensorTask TableType;
  SoftwareLayerUnion layer;
  MvTensorTaskT() {
  }
};

struct MvTensorTask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MvTensorTaskT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LAYER_TYPE = 4,
    VT_LAYER = 6
  };
  SoftwareLayer layer_type() const {
    return static_cast<SoftwareLayer>(GetField<uint8_t>(VT_LAYER_TYPE, 0));
  }
  const void *layer() const {
    return GetPointer<const void *>(VT_LAYER);
  }
  template<typename T> const T *layer_as() const;
  const Conv2D *layer_as_Conv2D() const {
    return layer_type() == SoftwareLayer_Conv2D ? static_cast<const Conv2D *>(layer()) : nullptr;
  }
  const Pooling *layer_as_Pooling() const {
    return layer_type() == SoftwareLayer_Pooling ? static_cast<const Pooling *>(layer()) : nullptr;
  }
  const ReLU *layer_as_ReLU() const {
    return layer_type() == SoftwareLayer_ReLU ? static_cast<const ReLU *>(layer()) : nullptr;
  }
  const Passthrough *layer_as_Passthrough() const {
    return layer_type() == SoftwareLayer_Passthrough ? static_cast<const Passthrough *>(layer()) : nullptr;
  }
  const Custom *layer_as_Custom() const {
    return layer_type() == SoftwareLayer_Custom ? static_cast<const Custom *>(layer()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_LAYER_TYPE) &&
           VerifyOffset(verifier, VT_LAYER) &&
           VerifySoftwareLayer(verifier, layer(), layer_type()) &&
           verifier.EndTable();
  }
  MvTensorTaskT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MvTensorTaskT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MvTensorTask> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MvTensorTaskT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const Conv2D *MvTensorTask::layer_as<Conv2D>() const {
  return layer_as_Conv2D();
}

template<> inline const Pooling *MvTensorTask::layer_as<Pooling>() const {
  return layer_as_Pooling();
}

template<> inline const ReLU *MvTensorTask::layer_as<ReLU>() const {
  return layer_as_ReLU();
}

template<> inline const Passthrough *MvTensorTask::layer_as<Passthrough>() const {
  return layer_as_Passthrough();
}

template<> inline const Custom *MvTensorTask::layer_as<Custom>() const {
  return layer_as_Custom();
}

struct MvTensorTaskBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_layer_type(SoftwareLayer layer_type) {
    fbb_.AddElement<uint8_t>(MvTensorTask::VT_LAYER_TYPE, static_cast<uint8_t>(layer_type), 0);
  }
  void add_layer(flatbuffers::Offset<void> layer) {
    fbb_.AddOffset(MvTensorTask::VT_LAYER, layer);
  }
  explicit MvTensorTaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MvTensorTaskBuilder &operator=(const MvTensorTaskBuilder &);
  flatbuffers::Offset<MvTensorTask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MvTensorTask>(end);
    return o;
  }
};

inline flatbuffers::Offset<MvTensorTask> CreateMvTensorTask(
    flatbuffers::FlatBufferBuilder &_fbb,
    SoftwareLayer layer_type = SoftwareLayer_NONE,
    flatbuffers::Offset<void> layer = 0) {
  MvTensorTaskBuilder builder_(_fbb);
  builder_.add_layer(layer);
  builder_.add_layer_type(layer_type);
  return builder_.Finish();
}

flatbuffers::Offset<MvTensorTask> CreateMvTensorTask(flatbuffers::FlatBufferBuilder &_fbb, const MvTensorTaskT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PPEConfigureT : public flatbuffers::NativeTable {
  typedef PPEConfigure TableType;
  std::vector<int8_t> vals;
  PPEConfigureT() {
  }
};

struct PPEConfigure FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PPEConfigureT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALS = 4
  };
  const flatbuffers::Vector<int8_t> *vals() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_VALS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALS) &&
           verifier.VerifyVector(vals()) &&
           verifier.EndTable();
  }
  PPEConfigureT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PPEConfigureT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PPEConfigure> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PPEConfigureT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PPEConfigureBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_vals(flatbuffers::Offset<flatbuffers::Vector<int8_t>> vals) {
    fbb_.AddOffset(PPEConfigure::VT_VALS, vals);
  }
  explicit PPEConfigureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PPEConfigureBuilder &operator=(const PPEConfigureBuilder &);
  flatbuffers::Offset<PPEConfigure> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PPEConfigure>(end);
    return o;
  }
};

inline flatbuffers::Offset<PPEConfigure> CreatePPEConfigure(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> vals = 0) {
  PPEConfigureBuilder builder_(_fbb);
  builder_.add_vals(vals);
  return builder_.Finish();
}

inline flatbuffers::Offset<PPEConfigure> CreatePPEConfigureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *vals = nullptr) {
  auto vals__ = vals ? _fbb.CreateVector<int8_t>(*vals) : 0;
  return MVCNN::CreatePPEConfigure(
      _fbb,
      vals__);
}

flatbuffers::Offset<PPEConfigure> CreatePPEConfigure(flatbuffers::FlatBufferBuilder &_fbb, const PPEConfigureT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PPEAssistT : public flatbuffers::NativeTable {
  typedef PPEAssist TableType;
  int8_t op;
  PPEAssistT()
      : op(0) {
  }
};

struct PPEAssist FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PPEAssistT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP = 4
  };
  int8_t op() const {
    return GetField<int8_t>(VT_OP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_OP) &&
           verifier.EndTable();
  }
  PPEAssistT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PPEAssistT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PPEAssist> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PPEAssistT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PPEAssistBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_op(int8_t op) {
    fbb_.AddElement<int8_t>(PPEAssist::VT_OP, op, 0);
  }
  explicit PPEAssistBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PPEAssistBuilder &operator=(const PPEAssistBuilder &);
  flatbuffers::Offset<PPEAssist> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PPEAssist>(end);
    return o;
  }
};

inline flatbuffers::Offset<PPEAssist> CreatePPEAssist(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t op = 0) {
  PPEAssistBuilder builder_(_fbb);
  builder_.add_op(op);
  return builder_.Finish();
}

flatbuffers::Offset<PPEAssist> CreatePPEAssist(flatbuffers::FlatBufferBuilder &_fbb, const PPEAssistT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NNTensorTaskT : public flatbuffers::NativeTable {
  typedef NNTensorTask TableType;
  NNHelperUnion subtask;
  NNTensorTaskT() {
  }
};

struct NNTensorTask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NNTensorTaskT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUBTASK_TYPE = 4,
    VT_SUBTASK = 6
  };
  NNHelper subtask_type() const {
    return static_cast<NNHelper>(GetField<uint8_t>(VT_SUBTASK_TYPE, 0));
  }
  const void *subtask() const {
    return GetPointer<const void *>(VT_SUBTASK);
  }
  template<typename T> const T *subtask_as() const;
  const PPEConfigure *subtask_as_PPEConfigure() const {
    return subtask_type() == NNHelper_PPEConfigure ? static_cast<const PPEConfigure *>(subtask()) : nullptr;
  }
  const PPEAssist *subtask_as_PPEAssist() const {
    return subtask_type() == NNHelper_PPEAssist ? static_cast<const PPEAssist *>(subtask()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUBTASK_TYPE) &&
           VerifyOffset(verifier, VT_SUBTASK) &&
           VerifyNNHelper(verifier, subtask(), subtask_type()) &&
           verifier.EndTable();
  }
  NNTensorTaskT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NNTensorTaskT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NNTensorTask> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NNTensorTaskT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const PPEConfigure *NNTensorTask::subtask_as<PPEConfigure>() const {
  return subtask_as_PPEConfigure();
}

template<> inline const PPEAssist *NNTensorTask::subtask_as<PPEAssist>() const {
  return subtask_as_PPEAssist();
}

struct NNTensorTaskBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_subtask_type(NNHelper subtask_type) {
    fbb_.AddElement<uint8_t>(NNTensorTask::VT_SUBTASK_TYPE, static_cast<uint8_t>(subtask_type), 0);
  }
  void add_subtask(flatbuffers::Offset<void> subtask) {
    fbb_.AddOffset(NNTensorTask::VT_SUBTASK, subtask);
  }
  explicit NNTensorTaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NNTensorTaskBuilder &operator=(const NNTensorTaskBuilder &);
  flatbuffers::Offset<NNTensorTask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NNTensorTask>(end);
    return o;
  }
};

inline flatbuffers::Offset<NNTensorTask> CreateNNTensorTask(
    flatbuffers::FlatBufferBuilder &_fbb,
    NNHelper subtask_type = NNHelper_NONE,
    flatbuffers::Offset<void> subtask = 0) {
  NNTensorTaskBuilder builder_(_fbb);
  builder_.add_subtask(subtask);
  builder_.add_subtask_type(subtask_type);
  return builder_.Finish();
}

flatbuffers::Offset<NNTensorTask> CreateNNTensorTask(flatbuffers::FlatBufferBuilder &_fbb, const NNTensorTaskT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline QuantizeParamsT *QuantizeParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new QuantizeParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void QuantizeParams::UnPackTo(QuantizeParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = scale(); if (_e) { _o->scale.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->scale[_i] = _e->Get(_i); } } };
  { auto _e = zero(); if (_e) { _o->zero.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->zero[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<QuantizeParams> QuantizeParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantizeParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateQuantizeParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<QuantizeParams> CreateQuantizeParams(flatbuffers::FlatBufferBuilder &_fbb, const QuantizeParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const QuantizeParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _scale = _fbb.CreateVector(_o->scale);
  auto _zero = _fbb.CreateVector(_o->zero);
  return MVCNN::CreateQuantizeParams(
      _fbb,
      _scale,
      _zero);
}

inline DummyParamsT *DummyParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DummyParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DummyParams::UnPackTo(DummyParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = message(); if (_e) _o->message = _e->str(); };
  { auto _e = executeShaveKernel(); _o->executeShaveKernel = _e; };
}

inline flatbuffers::Offset<DummyParams> DummyParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DummyParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDummyParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DummyParams> CreateDummyParams(flatbuffers::FlatBufferBuilder &_fbb, const DummyParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DummyParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _message = _o->message.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->message);
  auto _executeShaveKernel = _o->executeShaveKernel;
  return MVCNN::CreateDummyParams(
      _fbb,
      _message,
      _executeShaveKernel);
}

inline DetectionOutputParamsT *DetectionOutputParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DetectionOutputParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DetectionOutputParams::UnPackTo(DetectionOutputParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = num_classes(); _o->num_classes = _e; };
  { auto _e = keep_top_k(); _o->keep_top_k = _e; };
  { auto _e = nms_threshold(); _o->nms_threshold = _e; };
  { auto _e = background_label_id(); _o->background_label_id = _e; };
  { auto _e = top_k(); _o->top_k = _e; };
  { auto _e = variance_encoded_in_target(); _o->variance_encoded_in_target = _e; };
  { auto _e = code_type(); if (_e) _o->code_type = _e->str(); };
  { auto _e = share_location(); _o->share_location = _e; };
  { auto _e = confidence_threshold(); _o->confidence_threshold = _e; };
  { auto _e = clip_before_nms(); _o->clip_before_nms = _e; };
  { auto _e = clip_after_nms(); _o->clip_after_nms = _e; };
  { auto _e = decrease_label_id(); _o->decrease_label_id = _e; };
  { auto _e = normalized(); _o->normalized = _e; };
  { auto _e = input_height(); _o->input_height = _e; };
  { auto _e = input_width(); _o->input_width = _e; };
  { auto _e = objectness_score(); _o->objectness_score = _e; };
}

inline flatbuffers::Offset<DetectionOutputParams> DetectionOutputParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DetectionOutputParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDetectionOutputParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DetectionOutputParams> CreateDetectionOutputParams(flatbuffers::FlatBufferBuilder &_fbb, const DetectionOutputParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DetectionOutputParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _num_classes = _o->num_classes;
  auto _keep_top_k = _o->keep_top_k;
  auto _nms_threshold = _o->nms_threshold;
  auto _background_label_id = _o->background_label_id;
  auto _top_k = _o->top_k;
  auto _variance_encoded_in_target = _o->variance_encoded_in_target;
  auto _code_type = _o->code_type.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->code_type);
  auto _share_location = _o->share_location;
  auto _confidence_threshold = _o->confidence_threshold;
  auto _clip_before_nms = _o->clip_before_nms;
  auto _clip_after_nms = _o->clip_after_nms;
  auto _decrease_label_id = _o->decrease_label_id;
  auto _normalized = _o->normalized;
  auto _input_height = _o->input_height;
  auto _input_width = _o->input_width;
  auto _objectness_score = _o->objectness_score;
  return MVCNN::CreateDetectionOutputParams(
      _fbb,
      _num_classes,
      _keep_top_k,
      _nms_threshold,
      _background_label_id,
      _top_k,
      _variance_encoded_in_target,
      _code_type,
      _share_location,
      _confidence_threshold,
      _clip_before_nms,
      _clip_after_nms,
      _decrease_label_id,
      _normalized,
      _input_height,
      _input_width,
      _objectness_score);
}

inline DeconvolutionParamsT *DeconvolutionParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DeconvolutionParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DeconvolutionParams::UnPackTo(DeconvolutionParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kernel(); if (_e) _o->kernel = std::unique_ptr<order3>(new order3(*_e)); };
  { auto _e = strides(); if (_e) _o->strides = std::unique_ptr<order3>(new order3(*_e)); };
  { auto _e = dilations(); if (_e) _o->dilations = std::unique_ptr<order3>(new order3(*_e)); };
  { auto _e = pads_begin(); if (_e) _o->pads_begin = std::unique_ptr<order3>(new order3(*_e)); };
  { auto _e = pads_end(); if (_e) _o->pads_end = std::unique_ptr<order3>(new order3(*_e)); };
  { auto _e = output_padding(); if (_e) _o->output_padding = std::unique_ptr<order3>(new order3(*_e)); };
  { auto _e = is_depthwise(); _o->is_depthwise = _e; };
}

inline flatbuffers::Offset<DeconvolutionParams> DeconvolutionParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DeconvolutionParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDeconvolutionParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DeconvolutionParams> CreateDeconvolutionParams(flatbuffers::FlatBufferBuilder &_fbb, const DeconvolutionParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DeconvolutionParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kernel = _o->kernel ? _o->kernel.get() : 0;
  auto _strides = _o->strides ? _o->strides.get() : 0;
  auto _dilations = _o->dilations ? _o->dilations.get() : 0;
  auto _pads_begin = _o->pads_begin ? _o->pads_begin.get() : 0;
  auto _pads_end = _o->pads_end ? _o->pads_end.get() : 0;
  auto _output_padding = _o->output_padding ? _o->output_padding.get() : 0;
  auto _is_depthwise = _o->is_depthwise;
  return MVCNN::CreateDeconvolutionParams(
      _fbb,
      _kernel,
      _strides,
      _dilations,
      _pads_begin,
      _pads_end,
      _output_padding,
      _is_depthwise);
}

inline FlattenParamsT *FlattenParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FlattenParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void FlattenParams::UnPackTo(FlattenParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<FlattenParams> FlattenParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlattenParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlattenParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FlattenParams> CreateFlattenParams(flatbuffers::FlatBufferBuilder &_fbb, const FlattenParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FlattenParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return MVCNN::CreateFlattenParams(
      _fbb);
}

inline InterpParamsT *InterpParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new InterpParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void InterpParams::UnPackTo(InterpParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = pad_beg(); _o->pad_beg = _e; };
  { auto _e = pad_end(); _o->pad_end = _e; };
  { auto _e = align_corners(); _o->align_corners = _e; };
}

inline flatbuffers::Offset<InterpParams> InterpParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InterpParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInterpParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InterpParams> CreateInterpParams(flatbuffers::FlatBufferBuilder &_fbb, const InterpParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InterpParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _pad_beg = _o->pad_beg;
  auto _pad_end = _o->pad_end;
  auto _align_corners = _o->align_corners;
  return MVCNN::CreateInterpParams(
      _fbb,
      _pad_beg,
      _pad_end,
      _align_corners);
}

inline NormalizeParamsT *NormalizeParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NormalizeParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void NormalizeParams::UnPackTo(NormalizeParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = eps(); _o->eps = _e; };
  { auto _e = across_spatial(); _o->across_spatial = _e; };
  { auto _e = channel_shared(); _o->channel_shared = _e; };
}

inline flatbuffers::Offset<NormalizeParams> NormalizeParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NormalizeParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNormalizeParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NormalizeParams> CreateNormalizeParams(flatbuffers::FlatBufferBuilder &_fbb, const NormalizeParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NormalizeParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _eps = _o->eps;
  auto _across_spatial = _o->across_spatial;
  auto _channel_shared = _o->channel_shared;
  return MVCNN::CreateNormalizeParams(
      _fbb,
      _eps,
      _across_spatial,
      _channel_shared);
}

inline PermuteParamsT *PermuteParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PermuteParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PermuteParams::UnPackTo(PermuteParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = permute_order(); if (_e) _o->permute_order = std::unique_ptr<order3>(new order3(*_e)); };
}

inline flatbuffers::Offset<PermuteParams> PermuteParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PermuteParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePermuteParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PermuteParams> CreatePermuteParams(flatbuffers::FlatBufferBuilder &_fbb, const PermuteParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PermuteParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _permute_order = _o->permute_order ? _o->permute_order.get() : 0;
  return MVCNN::CreatePermuteParams(
      _fbb,
      _permute_order);
}

inline PriorboxParamsT *PriorboxParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PriorboxParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PriorboxParams::UnPackTo(PriorboxParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = min_sizes(); if (_e) { _o->min_sizes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->min_sizes[_i] = _e->Get(_i); } } };
  { auto _e = max_sizes(); if (_e) { _o->max_sizes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->max_sizes[_i] = _e->Get(_i); } } };
  { auto _e = aspect_ratios(); if (_e) { _o->aspect_ratios.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->aspect_ratios[_i] = _e->Get(_i); } } };
  { auto _e = variances(); if (_e) { _o->variances.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->variances[_i] = _e->Get(_i); } } };
  { auto _e = flip(); _o->flip = _e; };
  { auto _e = clip(); _o->clip = _e; };
  { auto _e = step_w(); _o->step_w = _e; };
  { auto _e = step_h(); _o->step_h = _e; };
  { auto _e = offset(); _o->offset = _e; };
}

inline flatbuffers::Offset<PriorboxParams> PriorboxParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PriorboxParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePriorboxParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PriorboxParams> CreatePriorboxParams(flatbuffers::FlatBufferBuilder &_fbb, const PriorboxParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PriorboxParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _min_sizes = _fbb.CreateVector(_o->min_sizes);
  auto _max_sizes = _fbb.CreateVector(_o->max_sizes);
  auto _aspect_ratios = _fbb.CreateVector(_o->aspect_ratios);
  auto _variances = _fbb.CreateVector(_o->variances);
  auto _flip = _o->flip;
  auto _clip = _o->clip;
  auto _step_w = _o->step_w;
  auto _step_h = _o->step_h;
  auto _offset = _o->offset;
  return MVCNN::CreatePriorboxParams(
      _fbb,
      _min_sizes,
      _max_sizes,
      _aspect_ratios,
      _variances,
      _flip,
      _clip,
      _step_w,
      _step_h,
      _offset);
}

inline ROIPoolingParamsT *ROIPoolingParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ROIPoolingParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ROIPoolingParams::UnPackTo(ROIPoolingParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = pooled_w(); _o->pooled_w = _e; };
  { auto _e = pooled_h(); _o->pooled_h = _e; };
  { auto _e = spatial_scale(); _o->spatial_scale = _e; };
  { auto _e = roi_pooling_method(); _o->roi_pooling_method = _e; };
  { auto _e = num_rois(); _o->num_rois = _e; };
}

inline flatbuffers::Offset<ROIPoolingParams> ROIPoolingParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ROIPoolingParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateROIPoolingParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ROIPoolingParams> CreateROIPoolingParams(flatbuffers::FlatBufferBuilder &_fbb, const ROIPoolingParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ROIPoolingParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _pooled_w = _o->pooled_w;
  auto _pooled_h = _o->pooled_h;
  auto _spatial_scale = _o->spatial_scale;
  auto _roi_pooling_method = _o->roi_pooling_method;
  auto _num_rois = _o->num_rois;
  return MVCNN::CreateROIPoolingParams(
      _fbb,
      _pooled_w,
      _pooled_h,
      _spatial_scale,
      _roi_pooling_method,
      _num_rois);
}

inline PSROIPoolingParamsT *PSROIPoolingParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PSROIPoolingParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PSROIPoolingParams::UnPackTo(PSROIPoolingParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = output_dim(); _o->output_dim = _e; };
  { auto _e = group_size(); _o->group_size = _e; };
  { auto _e = spatial_scale(); _o->spatial_scale = _e; };
  { auto _e = pooled_w(); _o->pooled_w = _e; };
  { auto _e = pooled_h(); _o->pooled_h = _e; };
  { auto _e = spatial_bin_x(); _o->spatial_bin_x = _e; };
  { auto _e = spatial_bin_y(); _o->spatial_bin_y = _e; };
  { auto _e = mode(); _o->mode = _e; };
}

inline flatbuffers::Offset<PSROIPoolingParams> PSROIPoolingParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PSROIPoolingParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePSROIPoolingParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PSROIPoolingParams> CreatePSROIPoolingParams(flatbuffers::FlatBufferBuilder &_fbb, const PSROIPoolingParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PSROIPoolingParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _output_dim = _o->output_dim;
  auto _group_size = _o->group_size;
  auto _spatial_scale = _o->spatial_scale;
  auto _pooled_w = _o->pooled_w;
  auto _pooled_h = _o->pooled_h;
  auto _spatial_bin_x = _o->spatial_bin_x;
  auto _spatial_bin_y = _o->spatial_bin_y;
  auto _mode = _o->mode;
  return MVCNN::CreatePSROIPoolingParams(
      _fbb,
      _output_dim,
      _group_size,
      _spatial_scale,
      _pooled_w,
      _pooled_h,
      _spatial_bin_x,
      _spatial_bin_y,
      _mode);
}

inline ProposalParamsT *ProposalParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ProposalParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ProposalParams::UnPackTo(ProposalParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = base_size(); _o->base_size = _e; };
  { auto _e = pre_nms_topn(); _o->pre_nms_topn = _e; };
  { auto _e = post_nms_topn(); _o->post_nms_topn = _e; };
  { auto _e = nms_thresh(); _o->nms_thresh = _e; };
  { auto _e = feat_stride(); _o->feat_stride = _e; };
  { auto _e = min_size(); _o->min_size = _e; };
  { auto _e = ratio(); if (_e) { _o->ratio.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ratio[_i] = _e->Get(_i); } } };
  { auto _e = scale(); if (_e) { _o->scale.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->scale[_i] = _e->Get(_i); } } };
  { auto _e = pre_nms_thresh(); _o->pre_nms_thresh = _e; };
  { auto _e = clip_before_nms(); _o->clip_before_nms = _e; };
  { auto _e = clip_after_nms(); _o->clip_after_nms = _e; };
  { auto _e = normalize(); _o->normalize = _e; };
  { auto _e = box_size_scale(); _o->box_size_scale = _e; };
  { auto _e = box_coordinate_scale(); _o->box_coordinate_scale = _e; };
  { auto _e = framework(); if (_e) _o->framework = _e->str(); };
  { auto _e = for_deformable(); _o->for_deformable = _e; };
}

inline flatbuffers::Offset<ProposalParams> ProposalParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProposalParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateProposalParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ProposalParams> CreateProposalParams(flatbuffers::FlatBufferBuilder &_fbb, const ProposalParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ProposalParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _base_size = _o->base_size;
  auto _pre_nms_topn = _o->pre_nms_topn;
  auto _post_nms_topn = _o->post_nms_topn;
  auto _nms_thresh = _o->nms_thresh;
  auto _feat_stride = _o->feat_stride;
  auto _min_size = _o->min_size;
  auto _ratio = _fbb.CreateVector(_o->ratio);
  auto _scale = _fbb.CreateVector(_o->scale);
  auto _pre_nms_thresh = _o->pre_nms_thresh;
  auto _clip_before_nms = _o->clip_before_nms;
  auto _clip_after_nms = _o->clip_after_nms;
  auto _normalize = _o->normalize;
  auto _box_size_scale = _o->box_size_scale;
  auto _box_coordinate_scale = _o->box_coordinate_scale;
  auto _framework = _o->framework.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->framework);
  auto _for_deformable = _o->for_deformable;
  return MVCNN::CreateProposalParams(
      _fbb,
      _base_size,
      _pre_nms_topn,
      _post_nms_topn,
      _nms_thresh,
      _feat_stride,
      _min_size,
      _ratio,
      _scale,
      _pre_nms_thresh,
      _clip_before_nms,
      _clip_after_nms,
      _normalize,
      _box_size_scale,
      _box_coordinate_scale,
      _framework,
      _for_deformable);
}

inline RegionYOLOParamsT *RegionYOLOParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RegionYOLOParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RegionYOLOParams::UnPackTo(RegionYOLOParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = coords(); _o->coords = _e; };
  { auto _e = classes(); _o->classes = _e; };
  { auto _e = num(); _o->num = _e; };
  { auto _e = do_softmax(); _o->do_softmax = _e; };
  { auto _e = mask(); if (_e) { _o->mask.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->mask[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<RegionYOLOParams> RegionYOLOParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RegionYOLOParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRegionYOLOParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RegionYOLOParams> CreateRegionYOLOParams(flatbuffers::FlatBufferBuilder &_fbb, const RegionYOLOParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RegionYOLOParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _coords = _o->coords;
  auto _classes = _o->classes;
  auto _num = _o->num;
  auto _do_softmax = _o->do_softmax;
  auto _mask = _fbb.CreateVector(_o->mask);
  return MVCNN::CreateRegionYOLOParams(
      _fbb,
      _coords,
      _classes,
      _num,
      _do_softmax,
      _mask);
}

inline ReorgYOLOParamsT *ReorgYOLOParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ReorgYOLOParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ReorgYOLOParams::UnPackTo(ReorgYOLOParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = stride(); _o->stride = _e; };
}

inline flatbuffers::Offset<ReorgYOLOParams> ReorgYOLOParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReorgYOLOParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReorgYOLOParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReorgYOLOParams> CreateReorgYOLOParams(flatbuffers::FlatBufferBuilder &_fbb, const ReorgYOLOParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReorgYOLOParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _stride = _o->stride;
  return MVCNN::CreateReorgYOLOParams(
      _fbb,
      _stride);
}

inline ReshapeParamsT *ReshapeParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ReshapeParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ReshapeParams::UnPackTo(ReshapeParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ReshapeParams> ReshapeParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReshapeParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReshapeParams> CreateReshapeParams(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReshapeParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return MVCNN::CreateReshapeParams(
      _fbb);
}

inline SoftmaxParamsT *SoftmaxParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SoftmaxParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SoftmaxParams::UnPackTo(SoftmaxParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; };
}

inline flatbuffers::Offset<SoftmaxParams> SoftmaxParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSoftmaxParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SoftmaxParams> CreateSoftmaxParams(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SoftmaxParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  return MVCNN::CreateSoftmaxParams(
      _fbb,
      _axis);
}

inline CustomLayerParamsT *CustomLayerParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CustomLayerParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CustomLayerParams::UnPackTo(CustomLayerParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = leonPreambleID(); _o->leonPreambleID = _e; };
  { auto _e = kernelData(); if (_e) _o->kernelData = std::unique_ptr<BinaryDataT>(_e->UnPack(_resolver)); };
  { auto _e = paramData(); if (_e) _o->paramData = std::unique_ptr<BinaryDataT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<CustomLayerParams> CustomLayerParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomLayerParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCustomLayerParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CustomLayerParams> CreateCustomLayerParams(flatbuffers::FlatBufferBuilder &_fbb, const CustomLayerParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CustomLayerParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _leonPreambleID = _o->leonPreambleID;
  auto _kernelData = _o->kernelData ? CreateBinaryData(_fbb, _o->kernelData.get(), _rehasher) : 0;
  auto _paramData = _o->paramData ? CreateBinaryData(_fbb, _o->paramData.get(), _rehasher) : 0;
  return MVCNN::CreateCustomLayerParams(
      _fbb,
      _leonPreambleID,
      _kernelData,
      _paramData);
}

inline EdslParamsT *EdslParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new EdslParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void EdslParams::UnPackTo(EdslParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = leonPreambleID(); _o->leonPreambleID = _e; };
  { auto _e = kernelData(); if (_e) _o->kernelData = std::unique_ptr<BinaryDataT>(_e->UnPack(_resolver)); };
  { auto _e = paramData(); if (_e) _o->paramData = std::unique_ptr<BinaryDataT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<EdslParams> EdslParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EdslParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEdslParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EdslParams> CreateEdslParams(flatbuffers::FlatBufferBuilder &_fbb, const EdslParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EdslParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _leonPreambleID = _o->leonPreambleID;
  auto _kernelData = _o->kernelData ? CreateBinaryData(_fbb, _o->kernelData.get(), _rehasher) : 0;
  auto _paramData = _o->paramData ? CreateBinaryData(_fbb, _o->paramData.get(), _rehasher) : 0;
  return MVCNN::CreateEdslParams(
      _fbb,
      _leonPreambleID,
      _kernelData,
      _paramData);
}

inline PassthroughParamsT *PassthroughParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PassthroughParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PassthroughParams::UnPackTo(PassthroughParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = min_delay_us(); _o->min_delay_us = _e; };
}

inline flatbuffers::Offset<PassthroughParams> PassthroughParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PassthroughParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePassthroughParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PassthroughParams> CreatePassthroughParams(flatbuffers::FlatBufferBuilder &_fbb, const PassthroughParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PassthroughParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _min_delay_us = _o->min_delay_us;
  return MVCNN::CreatePassthroughParams(
      _fbb,
      _min_delay_us);
}

inline LayerRecordParamsT *LayerRecordParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LayerRecordParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LayerRecordParams::UnPackTo(LayerRecordParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LayerRecordParams> LayerRecordParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LayerRecordParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLayerRecordParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LayerRecordParams> CreateLayerRecordParams(flatbuffers::FlatBufferBuilder &_fbb, const LayerRecordParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LayerRecordParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return MVCNN::CreateLayerRecordParams(
      _fbb);
}

inline ArgMaxParamsT *ArgMaxParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ArgMaxParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ArgMaxParams::UnPackTo(ArgMaxParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = out_max_val(); _o->out_max_val = _e; };
  { auto _e = top_k(); _o->top_k = _e; };
  { auto _e = axis(); _o->axis = _e; };
}

inline flatbuffers::Offset<ArgMaxParams> ArgMaxParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateArgMaxParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ArgMaxParams> CreateArgMaxParams(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ArgMaxParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _out_max_val = _o->out_max_val;
  auto _top_k = _o->top_k;
  auto _axis = _o->axis;
  return MVCNN::CreateArgMaxParams(
      _fbb,
      _out_max_val,
      _top_k,
      _axis);
}

inline NormParamsT *NormParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NormParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void NormParams::UnPackTo(NormParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = alpha(); _o->alpha = _e; };
  { auto _e = beta(); _o->beta = _e; };
  { auto _e = region(); if (_e) _o->region = _e->str(); };
  { auto _e = local_size(); _o->local_size = _e; };
}

inline flatbuffers::Offset<NormParams> NormParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NormParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNormParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NormParams> CreateNormParams(flatbuffers::FlatBufferBuilder &_fbb, const NormParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NormParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _alpha = _o->alpha;
  auto _beta = _o->beta;
  auto _region = _o->region.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->region);
  auto _local_size = _o->local_size;
  return MVCNN::CreateNormParams(
      _fbb,
      _alpha,
      _beta,
      _region,
      _local_size);
}

inline EltwiseParamsT *EltwiseParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new EltwiseParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void EltwiseParams::UnPackTo(EltwiseParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = operation(); if (_e) _o->operation = _e->str(); };
}

inline flatbuffers::Offset<EltwiseParams> EltwiseParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEltwiseParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EltwiseParams> CreateEltwiseParams(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EltwiseParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _operation = _o->operation.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->operation);
  return MVCNN::CreateEltwiseParams(
      _fbb,
      _operation);
}

inline ResampleParamsT *ResampleParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ResampleParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ResampleParams::UnPackTo(ResampleParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = interpolation(); _o->interpolation = _e; };
  { auto _e = antialias(); _o->antialias = _e; };
}

inline flatbuffers::Offset<ResampleParams> ResampleParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResampleParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResampleParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ResampleParams> CreateResampleParams(flatbuffers::FlatBufferBuilder &_fbb, const ResampleParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ResampleParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _interpolation = _o->interpolation;
  auto _antialias = _o->antialias;
  return MVCNN::CreateResampleParams(
      _fbb,
      _interpolation,
      _antialias);
}

inline CorrelationParamsT *CorrelationParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CorrelationParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CorrelationParams::UnPackTo(CorrelationParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kernel_size(); _o->kernel_size = _e; };
  { auto _e = max_displacement(); _o->max_displacement = _e; };
  { auto _e = pad_size(); _o->pad_size = _e; };
  { auto _e = stride1(); _o->stride1 = _e; };
  { auto _e = stride2(); _o->stride2 = _e; };
  { auto _e = correlation_type(); _o->correlation_type = _e; };
}

inline flatbuffers::Offset<CorrelationParams> CorrelationParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CorrelationParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCorrelationParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CorrelationParams> CreateCorrelationParams(flatbuffers::FlatBufferBuilder &_fbb, const CorrelationParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CorrelationParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kernel_size = _o->kernel_size;
  auto _max_displacement = _o->max_displacement;
  auto _pad_size = _o->pad_size;
  auto _stride1 = _o->stride1;
  auto _stride2 = _o->stride2;
  auto _correlation_type = _o->correlation_type;
  return MVCNN::CreateCorrelationParams(
      _fbb,
      _kernel_size,
      _max_displacement,
      _pad_size,
      _stride1,
      _stride2,
      _correlation_type);
}

inline MVNParamsT *MVNParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MVNParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MVNParams::UnPackTo(MVNParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = eps(); _o->eps = _e; };
  { auto _e = across_channels(); _o->across_channels = _e; };
  { auto _e = normalize_variance(); _o->normalize_variance = _e; };
}

inline flatbuffers::Offset<MVNParams> MVNParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MVNParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMVNParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MVNParams> CreateMVNParams(flatbuffers::FlatBufferBuilder &_fbb, const MVNParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MVNParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _eps = _o->eps;
  auto _across_channels = _o->across_channels;
  auto _normalize_variance = _o->normalize_variance;
  return MVCNN::CreateMVNParams(
      _fbb,
      _eps,
      _across_channels,
      _normalize_variance);
}

inline GRNParamsT *GRNParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GRNParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GRNParams::UnPackTo(GRNParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = bias(); _o->bias = _e; };
}

inline flatbuffers::Offset<GRNParams> GRNParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GRNParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGRNParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GRNParams> CreateGRNParams(flatbuffers::FlatBufferBuilder &_fbb, const GRNParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GRNParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _bias = _o->bias;
  return MVCNN::CreateGRNParams(
      _fbb,
      _bias);
}

inline CTCDecoderParamsT *CTCDecoderParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CTCDecoderParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CTCDecoderParams::UnPackTo(CTCDecoderParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ctc_merge_repeated(); _o->ctc_merge_repeated = _e; };
}

inline flatbuffers::Offset<CTCDecoderParams> CTCDecoderParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CTCDecoderParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCTCDecoderParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CTCDecoderParams> CreateCTCDecoderParams(flatbuffers::FlatBufferBuilder &_fbb, const CTCDecoderParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CTCDecoderParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ctc_merge_repeated = _o->ctc_merge_repeated;
  return MVCNN::CreateCTCDecoderParams(
      _fbb,
      _ctc_merge_repeated);
}

inline SpatialTransformParamsT *SpatialTransformParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SpatialTransformParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SpatialTransformParams::UnPackTo(SpatialTransformParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = theta(); if (_e) { _o->theta.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->theta[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<SpatialTransformParams> SpatialTransformParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpatialTransformParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSpatialTransformParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SpatialTransformParams> CreateSpatialTransformParams(flatbuffers::FlatBufferBuilder &_fbb, const SpatialTransformParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SpatialTransformParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _theta = _fbb.CreateVector(_o->theta);
  return MVCNN::CreateSpatialTransformParams(
      _fbb,
      _theta);
}

inline FakeQuantizeParamsT *FakeQuantizeParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FakeQuantizeParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void FakeQuantizeParams::UnPackTo(FakeQuantizeParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = levels(); _o->levels = _e; };
  { auto _e = input_low(); if (_e) { _o->input_low.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->input_low[_i] = _e->Get(_i); } } };
  { auto _e = input_high(); if (_e) { _o->input_high.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->input_high[_i] = _e->Get(_i); } } };
  { auto _e = output_low(); if (_e) { _o->output_low.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->output_low[_i] = _e->Get(_i); } } };
  { auto _e = output_high(); if (_e) { _o->output_high.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->output_high[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<FakeQuantizeParams> FakeQuantizeParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantizeParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFakeQuantizeParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FakeQuantizeParams> CreateFakeQuantizeParams(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantizeParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FakeQuantizeParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _levels = _o->levels;
  auto _input_low = _fbb.CreateVector(_o->input_low);
  auto _input_high = _fbb.CreateVector(_o->input_high);
  auto _output_low = _fbb.CreateVector(_o->output_low);
  auto _output_high = _fbb.CreateVector(_o->output_high);
  return MVCNN::CreateFakeQuantizeParams(
      _fbb,
      _levels,
      _input_low,
      _input_high,
      _output_low,
      _output_high);
}

inline PoolingParamsT *PoolingParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PoolingParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PoolingParams::UnPackTo(PoolingParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kernel(); if (_e) _o->kernel = std::unique_ptr<order3>(new order3(*_e)); };
  { auto _e = pool_method(); if (_e) _o->pool_method = _e->str(); };
  { auto _e = exclude_pad(); if (_e) _o->exclude_pad = _e->str(); };
  { auto _e = strides(); if (_e) _o->strides = std::unique_ptr<order3>(new order3(*_e)); };
  { auto _e = pads_begin(); if (_e) _o->pads_begin = std::unique_ptr<order3>(new order3(*_e)); };
  { auto _e = pads_end(); if (_e) _o->pads_end = std::unique_ptr<order3>(new order3(*_e)); };
  { auto _e = rounding_type(); if (_e) _o->rounding_type = _e->str(); };
  { auto _e = auto_pad(); if (_e) _o->auto_pad = _e->str(); };
}

inline flatbuffers::Offset<PoolingParams> PoolingParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PoolingParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePoolingParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PoolingParams> CreatePoolingParams(flatbuffers::FlatBufferBuilder &_fbb, const PoolingParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PoolingParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kernel = _o->kernel ? _o->kernel.get() : 0;
  auto _pool_method = _o->pool_method.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->pool_method);
  auto _exclude_pad = _o->exclude_pad.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->exclude_pad);
  auto _strides = _o->strides ? _o->strides.get() : 0;
  auto _pads_begin = _o->pads_begin ? _o->pads_begin.get() : 0;
  auto _pads_end = _o->pads_end ? _o->pads_end.get() : 0;
  auto _rounding_type = _o->rounding_type.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->rounding_type);
  auto _auto_pad = _o->auto_pad.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->auto_pad);
  return MVCNN::CreatePoolingParams(
      _fbb,
      _kernel,
      _pool_method,
      _exclude_pad,
      _strides,
      _pads_begin,
      _pads_end,
      _rounding_type,
      _auto_pad);
}

inline TileParamsT *TileParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TileParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TileParams::UnPackTo(TileParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; };
  { auto _e = tiles(); _o->tiles = _e; };
}

inline flatbuffers::Offset<TileParams> TileParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TileParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTileParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TileParams> CreateTileParams(flatbuffers::FlatBufferBuilder &_fbb, const TileParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TileParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  auto _tiles = _o->tiles;
  return MVCNN::CreateTileParams(
      _fbb,
      _axis,
      _tiles);
}

inline LeakyReluParamsT *LeakyReluParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LeakyReluParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LeakyReluParams::UnPackTo(LeakyReluParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = negative_slope(); _o->negative_slope = _e; };
}

inline flatbuffers::Offset<LeakyReluParams> LeakyReluParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLeakyReluParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LeakyReluParams> CreateLeakyReluParams(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LeakyReluParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _negative_slope = _o->negative_slope;
  return MVCNN::CreateLeakyReluParams(
      _fbb,
      _negative_slope);
}

inline SigmoidParamsT *SigmoidParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SigmoidParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SigmoidParams::UnPackTo(SigmoidParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SigmoidParams> SigmoidParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SigmoidParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSigmoidParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SigmoidParams> CreateSigmoidParams(flatbuffers::FlatBufferBuilder &_fbb, const SigmoidParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SigmoidParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return MVCNN::CreateSigmoidParams(
      _fbb);
}

inline UnaryOpParamsT *UnaryOpParams::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UnaryOpParamsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void UnaryOpParams::UnPackTo(UnaryOpParamsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = nested_params_type(); _o->nested_params.type = _e; };
  { auto _e = nested_params(); if (_e) _o->nested_params.value = UnaryOpNestedParamsUnion::UnPack(_e, nested_params_type(), _resolver); };
}

inline flatbuffers::Offset<UnaryOpParams> UnaryOpParams::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnaryOpParamsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnaryOpParams(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnaryOpParams> CreateUnaryOpParams(flatbuffers::FlatBufferBuilder &_fbb, const UnaryOpParamsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnaryOpParamsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _nested_params_type = _o->nested_params.type;
  auto _nested_params = _o->nested_params.Pack(_fbb);
  return MVCNN::CreateUnaryOpParams(
      _fbb,
      _nested_params_type,
      _nested_params);
}

inline UPALayerTaskT *UPALayerTask::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UPALayerTaskT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void UPALayerTask::UnPackTo(UPALayerTaskT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = maxShaves(); _o->maxShaves = _e; };
  { auto _e = softLayerParams_type(); _o->softLayerParams.type = _e; };
  { auto _e = softLayerParams(); if (_e) _o->softLayerParams.value = SoftwareLayerParamsUnion::UnPack(_e, softLayerParams_type(), _resolver); };
  { auto _e = input_data(); if (_e) _o->input_data = std::unique_ptr<TensorReferenceT>(_e->UnPack(_resolver)); };
  { auto _e = output_data(); if (_e) _o->output_data = std::unique_ptr<TensorReferenceT>(_e->UnPack(_resolver)); };
  { auto _e = weights_data(); if (_e) _o->weights_data = std::unique_ptr<TensorReferenceT>(_e->UnPack(_resolver)); };
  { auto _e = weights_table(); if (_e) _o->weights_table = std::unique_ptr<TensorReferenceT>(_e->UnPack(_resolver)); };
  { auto _e = inputs(); if (_e) { _o->inputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inputs[_i] = std::unique_ptr<TensorReferenceT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = outputs(); if (_e) { _o->outputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputs[_i] = std::unique_ptr<TensorReferenceT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = isTrailingSWLayer(); _o->isTrailingSWLayer = _e; };
}

inline flatbuffers::Offset<UPALayerTask> UPALayerTask::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UPALayerTaskT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUPALayerTask(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UPALayerTask> CreateUPALayerTask(flatbuffers::FlatBufferBuilder &_fbb, const UPALayerTaskT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UPALayerTaskT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _maxShaves = _o->maxShaves;
  auto _softLayerParams_type = _o->softLayerParams.type;
  auto _softLayerParams = _o->softLayerParams.Pack(_fbb);
  auto _input_data = _o->input_data ? CreateTensorReference(_fbb, _o->input_data.get(), _rehasher) : 0;
  auto _output_data = _o->output_data ? CreateTensorReference(_fbb, _o->output_data.get(), _rehasher) : 0;
  auto _weights_data = _o->weights_data ? CreateTensorReference(_fbb, _o->weights_data.get(), _rehasher) : 0;
  auto _weights_table = _o->weights_table ? CreateTensorReference(_fbb, _o->weights_table.get(), _rehasher) : 0;
  auto _inputs = _fbb.CreateVector<flatbuffers::Offset<TensorReference>> (_o->inputs.size(), [](size_t i, _VectorArgs *__va) { return CreateTensorReference(*__va->__fbb, __va->__o->inputs[i].get(), __va->__rehasher); }, &_va );
  auto _outputs = _fbb.CreateVector<flatbuffers::Offset<TensorReference>> (_o->outputs.size(), [](size_t i, _VectorArgs *__va) { return CreateTensorReference(*__va->__fbb, __va->__o->outputs[i].get(), __va->__rehasher); }, &_va );
  auto _isTrailingSWLayer = _o->isTrailingSWLayer;
  return MVCNN::CreateUPALayerTask(
      _fbb,
      _maxShaves,
      _softLayerParams_type,
      _softLayerParams,
      _input_data,
      _output_data,
      _weights_data,
      _weights_table,
      _inputs,
      _outputs,
      _isTrailingSWLayer);
}

inline SNNLayerTaskT *SNNLayerTask::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SNNLayerTaskT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SNNLayerTask::UnPackTo(SNNLayerTaskT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = softLayerParams_type(); _o->softLayerParams.type = _e; };
  { auto _e = softLayerParams(); if (_e) _o->softLayerParams.value = SoftwareLayerParamsUnion::UnPack(_e, softLayerParams_type(), _resolver); };
}

inline flatbuffers::Offset<SNNLayerTask> SNNLayerTask::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SNNLayerTaskT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSNNLayerTask(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SNNLayerTask> CreateSNNLayerTask(flatbuffers::FlatBufferBuilder &_fbb, const SNNLayerTaskT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SNNLayerTaskT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _softLayerParams_type = _o->softLayerParams.type;
  auto _softLayerParams = _o->softLayerParams.Pack(_fbb);
  return MVCNN::CreateSNNLayerTask(
      _fbb,
      _softLayerParams_type,
      _softLayerParams);
}

inline TensorT *Tensor::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TensorT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Tensor::UnPackTo(TensorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dimX(); _o->dimX = _e; };
  { auto _e = dimY(); _o->dimY = _e; };
  { auto _e = dimZ(); _o->dimZ = _e; };
  { auto _e = strideX(); _o->strideX = _e; };
  { auto _e = strideY(); _o->strideY = _e; };
  { auto _e = strideZ(); _o->strideZ = _e; };
  { auto _e = offset(); _o->offset = _e; };
  { auto _e = location(); _o->location = _e; };
  { auto _e = dataType(); _o->dataType = _e; };
  { auto _e = order(); _o->order = _e; };
}

inline flatbuffers::Offset<Tensor> Tensor::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensor(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Tensor> CreateTensor(flatbuffers::FlatBufferBuilder &_fbb, const TensorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dimX = _o->dimX;
  auto _dimY = _o->dimY;
  auto _dimZ = _o->dimZ;
  auto _strideX = _o->strideX;
  auto _strideY = _o->strideY;
  auto _strideZ = _o->strideZ;
  auto _offset = _o->offset;
  auto _location = _o->location;
  auto _dataType = _o->dataType;
  auto _order = _o->order;
  return MVCNN::CreateTensor(
      _fbb,
      _dimX,
      _dimY,
      _dimZ,
      _strideX,
      _strideY,
      _strideZ,
      _offset,
      _location,
      _dataType,
      _order);
}

inline Conv2DT *Conv2D::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Conv2DT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Conv2D::UnPackTo(Conv2DT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = radixX(); _o->radixX = _e; };
  { auto _e = radixY(); _o->radixY = _e; };
  { auto _e = strideX(); _o->strideX = _e; };
  { auto _e = strideY(); _o->strideY = _e; };
  { auto _e = padX(); _o->padX = _e; };
  { auto _e = padY(); _o->padY = _e; };
  { auto _e = padStyle(); _o->padStyle = _e; };
  { auto _e = dilation(); _o->dilation = _e; };
  { auto _e = input(); if (_e) _o->input = std::unique_ptr<TensorReferenceT>(_e->UnPack(_resolver)); };
  { auto _e = output(); if (_e) _o->output = std::unique_ptr<TensorReferenceT>(_e->UnPack(_resolver)); };
  { auto _e = weight(); if (_e) _o->weight = std::unique_ptr<TensorReferenceT>(_e->UnPack(_resolver)); };
  { auto _e = bias(); if (_e) _o->bias = std::unique_ptr<TensorReferenceT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<Conv2D> Conv2D::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConv2D(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Conv2D> CreateConv2D(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Conv2DT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _radixX = _o->radixX;
  auto _radixY = _o->radixY;
  auto _strideX = _o->strideX;
  auto _strideY = _o->strideY;
  auto _padX = _o->padX;
  auto _padY = _o->padY;
  auto _padStyle = _o->padStyle;
  auto _dilation = _o->dilation;
  auto _input = _o->input ? CreateTensorReference(_fbb, _o->input.get(), _rehasher) : 0;
  auto _output = _o->output ? CreateTensorReference(_fbb, _o->output.get(), _rehasher) : 0;
  auto _weight = _o->weight ? CreateTensorReference(_fbb, _o->weight.get(), _rehasher) : 0;
  auto _bias = _o->bias ? CreateTensorReference(_fbb, _o->bias.get(), _rehasher) : 0;
  return MVCNN::CreateConv2D(
      _fbb,
      _radixX,
      _radixY,
      _strideX,
      _strideY,
      _padX,
      _padY,
      _padStyle,
      _dilation,
      _input,
      _output,
      _weight,
      _bias);
}

inline PoolingT *Pooling::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PoolingT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Pooling::UnPackTo(PoolingT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = radixX(); _o->radixX = _e; };
  { auto _e = radixY(); _o->radixY = _e; };
  { auto _e = strideX(); _o->strideX = _e; };
  { auto _e = strideY(); _o->strideY = _e; };
  { auto _e = padX(); _o->padX = _e; };
  { auto _e = padY(); _o->padY = _e; };
  { auto _e = padStyle(); _o->padStyle = _e; };
  { auto _e = dilation(); _o->dilation = _e; };
  { auto _e = input(); if (_e) _o->input = std::unique_ptr<TensorReferenceT>(_e->UnPack(_resolver)); };
  { auto _e = output(); if (_e) _o->output = std::unique_ptr<TensorReferenceT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<Pooling> Pooling::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PoolingT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePooling(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Pooling> CreatePooling(flatbuffers::FlatBufferBuilder &_fbb, const PoolingT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PoolingT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _radixX = _o->radixX;
  auto _radixY = _o->radixY;
  auto _strideX = _o->strideX;
  auto _strideY = _o->strideY;
  auto _padX = _o->padX;
  auto _padY = _o->padY;
  auto _padStyle = _o->padStyle;
  auto _dilation = _o->dilation;
  auto _input = _o->input ? CreateTensorReference(_fbb, _o->input.get(), _rehasher) : 0;
  auto _output = _o->output ? CreateTensorReference(_fbb, _o->output.get(), _rehasher) : 0;
  return MVCNN::CreatePooling(
      _fbb,
      _radixX,
      _radixY,
      _strideX,
      _strideY,
      _padX,
      _padY,
      _padStyle,
      _dilation,
      _input,
      _output);
}

inline ReLUT *ReLU::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ReLUT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ReLU::UnPackTo(ReLUT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = opX(); _o->opX = _e; };
  { auto _e = input(); if (_e) _o->input = std::unique_ptr<TensorReferenceT>(_e->UnPack(_resolver)); };
  { auto _e = output(); if (_e) _o->output = std::unique_ptr<TensorReferenceT>(_e->UnPack(_resolver)); };
  { auto _e = strideX(); _o->strideX = _e; };
  { auto _e = strideY(); _o->strideY = _e; };
}

inline flatbuffers::Offset<ReLU> ReLU::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReLUT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReLU(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReLU> CreateReLU(flatbuffers::FlatBufferBuilder &_fbb, const ReLUT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReLUT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _opX = _o->opX;
  auto _input = _o->input ? CreateTensorReference(_fbb, _o->input.get(), _rehasher) : 0;
  auto _output = _o->output ? CreateTensorReference(_fbb, _o->output.get(), _rehasher) : 0;
  auto _strideX = _o->strideX;
  auto _strideY = _o->strideY;
  return MVCNN::CreateReLU(
      _fbb,
      _opX,
      _input,
      _output,
      _strideX,
      _strideY);
}

inline PassthroughT *Passthrough::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PassthroughT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Passthrough::UnPackTo(PassthroughT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = input(); if (_e) _o->input = std::unique_ptr<TensorReferenceT>(_e->UnPack(_resolver)); };
  { auto _e = output(); if (_e) _o->output = std::unique_ptr<TensorReferenceT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<Passthrough> Passthrough::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PassthroughT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePassthrough(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Passthrough> CreatePassthrough(flatbuffers::FlatBufferBuilder &_fbb, const PassthroughT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PassthroughT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _input = _o->input ? CreateTensorReference(_fbb, _o->input.get(), _rehasher) : 0;
  auto _output = _o->output ? CreateTensorReference(_fbb, _o->output.get(), _rehasher) : 0;
  return MVCNN::CreatePassthrough(
      _fbb,
      _input,
      _output);
}

inline CustomT *Custom::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CustomT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Custom::UnPackTo(CustomT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = _e->Get(_i); } } };
  { auto _e = length(); if (_e) { _o->length.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->length[_i] = _e->Get(_i); } } };
  { auto _e = id(); _o->id = _e; };
}

inline flatbuffers::Offset<Custom> Custom::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCustom(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Custom> CreateCustom(flatbuffers::FlatBufferBuilder &_fbb, const CustomT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CustomT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _data = _fbb.CreateVector(_o->data);
  auto _length = _fbb.CreateVector(_o->length);
  auto _id = _o->id;
  return MVCNN::CreateCustom(
      _fbb,
      _data,
      _length,
      _id);
}

inline MvTensorTaskT *MvTensorTask::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MvTensorTaskT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MvTensorTask::UnPackTo(MvTensorTaskT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = layer_type(); _o->layer.type = _e; };
  { auto _e = layer(); if (_e) _o->layer.value = SoftwareLayerUnion::UnPack(_e, layer_type(), _resolver); };
}

inline flatbuffers::Offset<MvTensorTask> MvTensorTask::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MvTensorTaskT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMvTensorTask(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MvTensorTask> CreateMvTensorTask(flatbuffers::FlatBufferBuilder &_fbb, const MvTensorTaskT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MvTensorTaskT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _layer_type = _o->layer.type;
  auto _layer = _o->layer.Pack(_fbb);
  return MVCNN::CreateMvTensorTask(
      _fbb,
      _layer_type,
      _layer);
}

inline PPEConfigureT *PPEConfigure::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PPEConfigureT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PPEConfigure::UnPackTo(PPEConfigureT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = vals(); if (_e) { _o->vals.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->vals[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<PPEConfigure> PPEConfigure::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PPEConfigureT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePPEConfigure(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PPEConfigure> CreatePPEConfigure(flatbuffers::FlatBufferBuilder &_fbb, const PPEConfigureT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PPEConfigureT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _vals = _fbb.CreateVector(_o->vals);
  return MVCNN::CreatePPEConfigure(
      _fbb,
      _vals);
}

inline PPEAssistT *PPEAssist::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PPEAssistT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PPEAssist::UnPackTo(PPEAssistT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = op(); _o->op = _e; };
}

inline flatbuffers::Offset<PPEAssist> PPEAssist::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PPEAssistT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePPEAssist(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PPEAssist> CreatePPEAssist(flatbuffers::FlatBufferBuilder &_fbb, const PPEAssistT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PPEAssistT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _op = _o->op;
  return MVCNN::CreatePPEAssist(
      _fbb,
      _op);
}

inline NNTensorTaskT *NNTensorTask::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NNTensorTaskT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void NNTensorTask::UnPackTo(NNTensorTaskT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = subtask_type(); _o->subtask.type = _e; };
  { auto _e = subtask(); if (_e) _o->subtask.value = NNHelperUnion::UnPack(_e, subtask_type(), _resolver); };
}

inline flatbuffers::Offset<NNTensorTask> NNTensorTask::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NNTensorTaskT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNNTensorTask(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NNTensorTask> CreateNNTensorTask(flatbuffers::FlatBufferBuilder &_fbb, const NNTensorTaskT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NNTensorTaskT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _subtask_type = _o->subtask.type;
  auto _subtask = _o->subtask.Pack(_fbb);
  return MVCNN::CreateNNTensorTask(
      _fbb,
      _subtask_type,
      _subtask);
}

inline bool VerifyUnaryOpNestedParams(flatbuffers::Verifier &verifier, const void *obj, UnaryOpNestedParams type) {
  switch (type) {
    case UnaryOpNestedParams_NONE: {
      return true;
    }
    case UnaryOpNestedParams_LeakyReluParams: {
      auto ptr = reinterpret_cast<const LeakyReluParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UnaryOpNestedParams_SigmoidParams: {
      auto ptr = reinterpret_cast<const SigmoidParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyUnaryOpNestedParamsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyUnaryOpNestedParams(
        verifier,  values->Get(i), types->GetEnum<UnaryOpNestedParams>(i))) {
      return false;
    }
  }
  return true;
}

inline void *UnaryOpNestedParamsUnion::UnPack(const void *obj, UnaryOpNestedParams type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case UnaryOpNestedParams_LeakyReluParams: {
      auto ptr = reinterpret_cast<const LeakyReluParams *>(obj);
      return ptr->UnPack(resolver);
    }
    case UnaryOpNestedParams_SigmoidParams: {
      auto ptr = reinterpret_cast<const SigmoidParams *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> UnaryOpNestedParamsUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case UnaryOpNestedParams_LeakyReluParams: {
      auto ptr = reinterpret_cast<const LeakyReluParamsT *>(value);
      return CreateLeakyReluParams(_fbb, ptr, _rehasher).Union();
    }
    case UnaryOpNestedParams_SigmoidParams: {
      auto ptr = reinterpret_cast<const SigmoidParamsT *>(value);
      return CreateSigmoidParams(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline UnaryOpNestedParamsUnion::UnaryOpNestedParamsUnion(const UnaryOpNestedParamsUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case UnaryOpNestedParams_LeakyReluParams: {
      value = new LeakyReluParamsT(*reinterpret_cast<LeakyReluParamsT *>(u.value));
      break;
    }
    case UnaryOpNestedParams_SigmoidParams: {
      value = new SigmoidParamsT(*reinterpret_cast<SigmoidParamsT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void UnaryOpNestedParamsUnion::Reset() {
  switch (type) {
    case UnaryOpNestedParams_LeakyReluParams: {
      auto ptr = reinterpret_cast<LeakyReluParamsT *>(value);
      delete ptr;
      break;
    }
    case UnaryOpNestedParams_SigmoidParams: {
      auto ptr = reinterpret_cast<SigmoidParamsT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = UnaryOpNestedParams_NONE;
}

inline bool VerifySoftwareLayerParams(flatbuffers::Verifier &verifier, const void *obj, SoftwareLayerParams type) {
  switch (type) {
    case SoftwareLayerParams_NONE: {
      return true;
    }
    case SoftwareLayerParams_DummyParams: {
      auto ptr = reinterpret_cast<const DummyParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SoftwareLayerParams_DetectionOutputParams: {
      auto ptr = reinterpret_cast<const DetectionOutputParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SoftwareLayerParams_FlattenParams: {
      auto ptr = reinterpret_cast<const FlattenParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SoftwareLayerParams_InterpParams: {
      auto ptr = reinterpret_cast<const InterpParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SoftwareLayerParams_NormalizeParams: {
      auto ptr = reinterpret_cast<const NormalizeParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SoftwareLayerParams_PermuteParams: {
      auto ptr = reinterpret_cast<const PermuteParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SoftwareLayerParams_PriorboxParams: {
      auto ptr = reinterpret_cast<const PriorboxParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SoftwareLayerParams_ProposalParams: {
      auto ptr = reinterpret_cast<const ProposalParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SoftwareLayerParams_RegionYOLOParams: {
      auto ptr = reinterpret_cast<const RegionYOLOParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SoftwareLayerParams_ReorgYOLOParams: {
      auto ptr = reinterpret_cast<const ReorgYOLOParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SoftwareLayerParams_ReshapeParams: {
      auto ptr = reinterpret_cast<const ReshapeParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SoftwareLayerParams_SoftmaxParams: {
      auto ptr = reinterpret_cast<const SoftmaxParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SoftwareLayerParams_CustomLayerParams: {
      auto ptr = reinterpret_cast<const CustomLayerParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SoftwareLayerParams_PassthroughParams: {
      auto ptr = reinterpret_cast<const PassthroughParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SoftwareLayerParams_LayerRecordParams: {
      auto ptr = reinterpret_cast<const LayerRecordParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SoftwareLayerParams_ROIPoolingParams: {
      auto ptr = reinterpret_cast<const ROIPoolingParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SoftwareLayerParams_QuantizeParams: {
      auto ptr = reinterpret_cast<const QuantizeParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SoftwareLayerParams_ArgMaxParams: {
      auto ptr = reinterpret_cast<const ArgMaxParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SoftwareLayerParams_NormParams: {
      auto ptr = reinterpret_cast<const NormParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SoftwareLayerParams_EltwiseParams: {
      auto ptr = reinterpret_cast<const EltwiseParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SoftwareLayerParams_ResampleParams: {
      auto ptr = reinterpret_cast<const ResampleParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SoftwareLayerParams_CorrelationParams: {
      auto ptr = reinterpret_cast<const CorrelationParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SoftwareLayerParams_MVNParams: {
      auto ptr = reinterpret_cast<const MVNParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SoftwareLayerParams_GRNParams: {
      auto ptr = reinterpret_cast<const GRNParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SoftwareLayerParams_CTCDecoderParams: {
      auto ptr = reinterpret_cast<const CTCDecoderParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SoftwareLayerParams_SpatialTransformParams: {
      auto ptr = reinterpret_cast<const SpatialTransformParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SoftwareLayerParams_FakeQuantizeParams: {
      auto ptr = reinterpret_cast<const FakeQuantizeParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SoftwareLayerParams_PoolingParams: {
      auto ptr = reinterpret_cast<const PoolingParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SoftwareLayerParams_EdslParams: {
      auto ptr = reinterpret_cast<const EdslParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SoftwareLayerParams_TileParams: {
      auto ptr = reinterpret_cast<const TileParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SoftwareLayerParams_PSROIPoolingParams: {
      auto ptr = reinterpret_cast<const PSROIPoolingParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SoftwareLayerParams_DeconvolutionParams: {
      auto ptr = reinterpret_cast<const DeconvolutionParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SoftwareLayerParams_UnaryOpParams: {
      auto ptr = reinterpret_cast<const UnaryOpParams *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifySoftwareLayerParamsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifySoftwareLayerParams(
        verifier,  values->Get(i), types->GetEnum<SoftwareLayerParams>(i))) {
      return false;
    }
  }
  return true;
}

inline void *SoftwareLayerParamsUnion::UnPack(const void *obj, SoftwareLayerParams type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case SoftwareLayerParams_DummyParams: {
      auto ptr = reinterpret_cast<const DummyParams *>(obj);
      return ptr->UnPack(resolver);
    }
    case SoftwareLayerParams_DetectionOutputParams: {
      auto ptr = reinterpret_cast<const DetectionOutputParams *>(obj);
      return ptr->UnPack(resolver);
    }
    case SoftwareLayerParams_FlattenParams: {
      auto ptr = reinterpret_cast<const FlattenParams *>(obj);
      return ptr->UnPack(resolver);
    }
    case SoftwareLayerParams_InterpParams: {
      auto ptr = reinterpret_cast<const InterpParams *>(obj);
      return ptr->UnPack(resolver);
    }
    case SoftwareLayerParams_NormalizeParams: {
      auto ptr = reinterpret_cast<const NormalizeParams *>(obj);
      return ptr->UnPack(resolver);
    }
    case SoftwareLayerParams_PermuteParams: {
      auto ptr = reinterpret_cast<const PermuteParams *>(obj);
      return ptr->UnPack(resolver);
    }
    case SoftwareLayerParams_PriorboxParams: {
      auto ptr = reinterpret_cast<const PriorboxParams *>(obj);
      return ptr->UnPack(resolver);
    }
    case SoftwareLayerParams_ProposalParams: {
      auto ptr = reinterpret_cast<const ProposalParams *>(obj);
      return ptr->UnPack(resolver);
    }
    case SoftwareLayerParams_RegionYOLOParams: {
      auto ptr = reinterpret_cast<const RegionYOLOParams *>(obj);
      return ptr->UnPack(resolver);
    }
    case SoftwareLayerParams_ReorgYOLOParams: {
      auto ptr = reinterpret_cast<const ReorgYOLOParams *>(obj);
      return ptr->UnPack(resolver);
    }
    case SoftwareLayerParams_ReshapeParams: {
      auto ptr = reinterpret_cast<const ReshapeParams *>(obj);
      return ptr->UnPack(resolver);
    }
    case SoftwareLayerParams_SoftmaxParams: {
      auto ptr = reinterpret_cast<const SoftmaxParams *>(obj);
      return ptr->UnPack(resolver);
    }
    case SoftwareLayerParams_CustomLayerParams: {
      auto ptr = reinterpret_cast<const CustomLayerParams *>(obj);
      return ptr->UnPack(resolver);
    }
    case SoftwareLayerParams_PassthroughParams: {
      auto ptr = reinterpret_cast<const PassthroughParams *>(obj);
      return ptr->UnPack(resolver);
    }
    case SoftwareLayerParams_LayerRecordParams: {
      auto ptr = reinterpret_cast<const LayerRecordParams *>(obj);
      return ptr->UnPack(resolver);
    }
    case SoftwareLayerParams_ROIPoolingParams: {
      auto ptr = reinterpret_cast<const ROIPoolingParams *>(obj);
      return ptr->UnPack(resolver);
    }
    case SoftwareLayerParams_QuantizeParams: {
      auto ptr = reinterpret_cast<const QuantizeParams *>(obj);
      return ptr->UnPack(resolver);
    }
    case SoftwareLayerParams_ArgMaxParams: {
      auto ptr = reinterpret_cast<const ArgMaxParams *>(obj);
      return ptr->UnPack(resolver);
    }
    case SoftwareLayerParams_NormParams: {
      auto ptr = reinterpret_cast<const NormParams *>(obj);
      return ptr->UnPack(resolver);
    }
    case SoftwareLayerParams_EltwiseParams: {
      auto ptr = reinterpret_cast<const EltwiseParams *>(obj);
      return ptr->UnPack(resolver);
    }
    case SoftwareLayerParams_ResampleParams: {
      auto ptr = reinterpret_cast<const ResampleParams *>(obj);
      return ptr->UnPack(resolver);
    }
    case SoftwareLayerParams_CorrelationParams: {
      auto ptr = reinterpret_cast<const CorrelationParams *>(obj);
      return ptr->UnPack(resolver);
    }
    case SoftwareLayerParams_MVNParams: {
      auto ptr = reinterpret_cast<const MVNParams *>(obj);
      return ptr->UnPack(resolver);
    }
    case SoftwareLayerParams_GRNParams: {
      auto ptr = reinterpret_cast<const GRNParams *>(obj);
      return ptr->UnPack(resolver);
    }
    case SoftwareLayerParams_CTCDecoderParams: {
      auto ptr = reinterpret_cast<const CTCDecoderParams *>(obj);
      return ptr->UnPack(resolver);
    }
    case SoftwareLayerParams_SpatialTransformParams: {
      auto ptr = reinterpret_cast<const SpatialTransformParams *>(obj);
      return ptr->UnPack(resolver);
    }
    case SoftwareLayerParams_FakeQuantizeParams: {
      auto ptr = reinterpret_cast<const FakeQuantizeParams *>(obj);
      return ptr->UnPack(resolver);
    }
    case SoftwareLayerParams_PoolingParams: {
      auto ptr = reinterpret_cast<const PoolingParams *>(obj);
      return ptr->UnPack(resolver);
    }
    case SoftwareLayerParams_EdslParams: {
      auto ptr = reinterpret_cast<const EdslParams *>(obj);
      return ptr->UnPack(resolver);
    }
    case SoftwareLayerParams_TileParams: {
      auto ptr = reinterpret_cast<const TileParams *>(obj);
      return ptr->UnPack(resolver);
    }
    case SoftwareLayerParams_PSROIPoolingParams: {
      auto ptr = reinterpret_cast<const PSROIPoolingParams *>(obj);
      return ptr->UnPack(resolver);
    }
    case SoftwareLayerParams_DeconvolutionParams: {
      auto ptr = reinterpret_cast<const DeconvolutionParams *>(obj);
      return ptr->UnPack(resolver);
    }
    case SoftwareLayerParams_UnaryOpParams: {
      auto ptr = reinterpret_cast<const UnaryOpParams *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> SoftwareLayerParamsUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case SoftwareLayerParams_DummyParams: {
      auto ptr = reinterpret_cast<const DummyParamsT *>(value);
      return CreateDummyParams(_fbb, ptr, _rehasher).Union();
    }
    case SoftwareLayerParams_DetectionOutputParams: {
      auto ptr = reinterpret_cast<const DetectionOutputParamsT *>(value);
      return CreateDetectionOutputParams(_fbb, ptr, _rehasher).Union();
    }
    case SoftwareLayerParams_FlattenParams: {
      auto ptr = reinterpret_cast<const FlattenParamsT *>(value);
      return CreateFlattenParams(_fbb, ptr, _rehasher).Union();
    }
    case SoftwareLayerParams_InterpParams: {
      auto ptr = reinterpret_cast<const InterpParamsT *>(value);
      return CreateInterpParams(_fbb, ptr, _rehasher).Union();
    }
    case SoftwareLayerParams_NormalizeParams: {
      auto ptr = reinterpret_cast<const NormalizeParamsT *>(value);
      return CreateNormalizeParams(_fbb, ptr, _rehasher).Union();
    }
    case SoftwareLayerParams_PermuteParams: {
      auto ptr = reinterpret_cast<const PermuteParamsT *>(value);
      return CreatePermuteParams(_fbb, ptr, _rehasher).Union();
    }
    case SoftwareLayerParams_PriorboxParams: {
      auto ptr = reinterpret_cast<const PriorboxParamsT *>(value);
      return CreatePriorboxParams(_fbb, ptr, _rehasher).Union();
    }
    case SoftwareLayerParams_ProposalParams: {
      auto ptr = reinterpret_cast<const ProposalParamsT *>(value);
      return CreateProposalParams(_fbb, ptr, _rehasher).Union();
    }
    case SoftwareLayerParams_RegionYOLOParams: {
      auto ptr = reinterpret_cast<const RegionYOLOParamsT *>(value);
      return CreateRegionYOLOParams(_fbb, ptr, _rehasher).Union();
    }
    case SoftwareLayerParams_ReorgYOLOParams: {
      auto ptr = reinterpret_cast<const ReorgYOLOParamsT *>(value);
      return CreateReorgYOLOParams(_fbb, ptr, _rehasher).Union();
    }
    case SoftwareLayerParams_ReshapeParams: {
      auto ptr = reinterpret_cast<const ReshapeParamsT *>(value);
      return CreateReshapeParams(_fbb, ptr, _rehasher).Union();
    }
    case SoftwareLayerParams_SoftmaxParams: {
      auto ptr = reinterpret_cast<const SoftmaxParamsT *>(value);
      return CreateSoftmaxParams(_fbb, ptr, _rehasher).Union();
    }
    case SoftwareLayerParams_CustomLayerParams: {
      auto ptr = reinterpret_cast<const CustomLayerParamsT *>(value);
      return CreateCustomLayerParams(_fbb, ptr, _rehasher).Union();
    }
    case SoftwareLayerParams_PassthroughParams: {
      auto ptr = reinterpret_cast<const PassthroughParamsT *>(value);
      return CreatePassthroughParams(_fbb, ptr, _rehasher).Union();
    }
    case SoftwareLayerParams_LayerRecordParams: {
      auto ptr = reinterpret_cast<const LayerRecordParamsT *>(value);
      return CreateLayerRecordParams(_fbb, ptr, _rehasher).Union();
    }
    case SoftwareLayerParams_ROIPoolingParams: {
      auto ptr = reinterpret_cast<const ROIPoolingParamsT *>(value);
      return CreateROIPoolingParams(_fbb, ptr, _rehasher).Union();
    }
    case SoftwareLayerParams_QuantizeParams: {
      auto ptr = reinterpret_cast<const QuantizeParamsT *>(value);
      return CreateQuantizeParams(_fbb, ptr, _rehasher).Union();
    }
    case SoftwareLayerParams_ArgMaxParams: {
      auto ptr = reinterpret_cast<const ArgMaxParamsT *>(value);
      return CreateArgMaxParams(_fbb, ptr, _rehasher).Union();
    }
    case SoftwareLayerParams_NormParams: {
      auto ptr = reinterpret_cast<const NormParamsT *>(value);
      return CreateNormParams(_fbb, ptr, _rehasher).Union();
    }
    case SoftwareLayerParams_EltwiseParams: {
      auto ptr = reinterpret_cast<const EltwiseParamsT *>(value);
      return CreateEltwiseParams(_fbb, ptr, _rehasher).Union();
    }
    case SoftwareLayerParams_ResampleParams: {
      auto ptr = reinterpret_cast<const ResampleParamsT *>(value);
      return CreateResampleParams(_fbb, ptr, _rehasher).Union();
    }
    case SoftwareLayerParams_CorrelationParams: {
      auto ptr = reinterpret_cast<const CorrelationParamsT *>(value);
      return CreateCorrelationParams(_fbb, ptr, _rehasher).Union();
    }
    case SoftwareLayerParams_MVNParams: {
      auto ptr = reinterpret_cast<const MVNParamsT *>(value);
      return CreateMVNParams(_fbb, ptr, _rehasher).Union();
    }
    case SoftwareLayerParams_GRNParams: {
      auto ptr = reinterpret_cast<const GRNParamsT *>(value);
      return CreateGRNParams(_fbb, ptr, _rehasher).Union();
    }
    case SoftwareLayerParams_CTCDecoderParams: {
      auto ptr = reinterpret_cast<const CTCDecoderParamsT *>(value);
      return CreateCTCDecoderParams(_fbb, ptr, _rehasher).Union();
    }
    case SoftwareLayerParams_SpatialTransformParams: {
      auto ptr = reinterpret_cast<const SpatialTransformParamsT *>(value);
      return CreateSpatialTransformParams(_fbb, ptr, _rehasher).Union();
    }
    case SoftwareLayerParams_FakeQuantizeParams: {
      auto ptr = reinterpret_cast<const FakeQuantizeParamsT *>(value);
      return CreateFakeQuantizeParams(_fbb, ptr, _rehasher).Union();
    }
    case SoftwareLayerParams_PoolingParams: {
      auto ptr = reinterpret_cast<const PoolingParamsT *>(value);
      return CreatePoolingParams(_fbb, ptr, _rehasher).Union();
    }
    case SoftwareLayerParams_EdslParams: {
      auto ptr = reinterpret_cast<const EdslParamsT *>(value);
      return CreateEdslParams(_fbb, ptr, _rehasher).Union();
    }
    case SoftwareLayerParams_TileParams: {
      auto ptr = reinterpret_cast<const TileParamsT *>(value);
      return CreateTileParams(_fbb, ptr, _rehasher).Union();
    }
    case SoftwareLayerParams_PSROIPoolingParams: {
      auto ptr = reinterpret_cast<const PSROIPoolingParamsT *>(value);
      return CreatePSROIPoolingParams(_fbb, ptr, _rehasher).Union();
    }
    case SoftwareLayerParams_DeconvolutionParams: {
      auto ptr = reinterpret_cast<const DeconvolutionParamsT *>(value);
      return CreateDeconvolutionParams(_fbb, ptr, _rehasher).Union();
    }
    case SoftwareLayerParams_UnaryOpParams: {
      auto ptr = reinterpret_cast<const UnaryOpParamsT *>(value);
      return CreateUnaryOpParams(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline SoftwareLayerParamsUnion::SoftwareLayerParamsUnion(const SoftwareLayerParamsUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case SoftwareLayerParams_DummyParams: {
      value = new DummyParamsT(*reinterpret_cast<DummyParamsT *>(u.value));
      break;
    }
    case SoftwareLayerParams_DetectionOutputParams: {
      value = new DetectionOutputParamsT(*reinterpret_cast<DetectionOutputParamsT *>(u.value));
      break;
    }
    case SoftwareLayerParams_FlattenParams: {
      value = new FlattenParamsT(*reinterpret_cast<FlattenParamsT *>(u.value));
      break;
    }
    case SoftwareLayerParams_InterpParams: {
      value = new InterpParamsT(*reinterpret_cast<InterpParamsT *>(u.value));
      break;
    }
    case SoftwareLayerParams_NormalizeParams: {
      value = new NormalizeParamsT(*reinterpret_cast<NormalizeParamsT *>(u.value));
      break;
    }
    case SoftwareLayerParams_PermuteParams: {
      FLATBUFFERS_ASSERT(false);  // PermuteParamsT not copyable.
      break;
    }
    case SoftwareLayerParams_PriorboxParams: {
      value = new PriorboxParamsT(*reinterpret_cast<PriorboxParamsT *>(u.value));
      break;
    }
    case SoftwareLayerParams_ProposalParams: {
      value = new ProposalParamsT(*reinterpret_cast<ProposalParamsT *>(u.value));
      break;
    }
    case SoftwareLayerParams_RegionYOLOParams: {
      value = new RegionYOLOParamsT(*reinterpret_cast<RegionYOLOParamsT *>(u.value));
      break;
    }
    case SoftwareLayerParams_ReorgYOLOParams: {
      value = new ReorgYOLOParamsT(*reinterpret_cast<ReorgYOLOParamsT *>(u.value));
      break;
    }
    case SoftwareLayerParams_ReshapeParams: {
      value = new ReshapeParamsT(*reinterpret_cast<ReshapeParamsT *>(u.value));
      break;
    }
    case SoftwareLayerParams_SoftmaxParams: {
      value = new SoftmaxParamsT(*reinterpret_cast<SoftmaxParamsT *>(u.value));
      break;
    }
    case SoftwareLayerParams_CustomLayerParams: {
      FLATBUFFERS_ASSERT(false);  // CustomLayerParamsT not copyable.
      break;
    }
    case SoftwareLayerParams_PassthroughParams: {
      value = new PassthroughParamsT(*reinterpret_cast<PassthroughParamsT *>(u.value));
      break;
    }
    case SoftwareLayerParams_LayerRecordParams: {
      value = new LayerRecordParamsT(*reinterpret_cast<LayerRecordParamsT *>(u.value));
      break;
    }
    case SoftwareLayerParams_ROIPoolingParams: {
      value = new ROIPoolingParamsT(*reinterpret_cast<ROIPoolingParamsT *>(u.value));
      break;
    }
    case SoftwareLayerParams_QuantizeParams: {
      value = new QuantizeParamsT(*reinterpret_cast<QuantizeParamsT *>(u.value));
      break;
    }
    case SoftwareLayerParams_ArgMaxParams: {
      value = new ArgMaxParamsT(*reinterpret_cast<ArgMaxParamsT *>(u.value));
      break;
    }
    case SoftwareLayerParams_NormParams: {
      value = new NormParamsT(*reinterpret_cast<NormParamsT *>(u.value));
      break;
    }
    case SoftwareLayerParams_EltwiseParams: {
      value = new EltwiseParamsT(*reinterpret_cast<EltwiseParamsT *>(u.value));
      break;
    }
    case SoftwareLayerParams_ResampleParams: {
      value = new ResampleParamsT(*reinterpret_cast<ResampleParamsT *>(u.value));
      break;
    }
    case SoftwareLayerParams_CorrelationParams: {
      value = new CorrelationParamsT(*reinterpret_cast<CorrelationParamsT *>(u.value));
      break;
    }
    case SoftwareLayerParams_MVNParams: {
      value = new MVNParamsT(*reinterpret_cast<MVNParamsT *>(u.value));
      break;
    }
    case SoftwareLayerParams_GRNParams: {
      value = new GRNParamsT(*reinterpret_cast<GRNParamsT *>(u.value));
      break;
    }
    case SoftwareLayerParams_CTCDecoderParams: {
      value = new CTCDecoderParamsT(*reinterpret_cast<CTCDecoderParamsT *>(u.value));
      break;
    }
    case SoftwareLayerParams_SpatialTransformParams: {
      value = new SpatialTransformParamsT(*reinterpret_cast<SpatialTransformParamsT *>(u.value));
      break;
    }
    case SoftwareLayerParams_FakeQuantizeParams: {
      value = new FakeQuantizeParamsT(*reinterpret_cast<FakeQuantizeParamsT *>(u.value));
      break;
    }
    case SoftwareLayerParams_PoolingParams: {
      FLATBUFFERS_ASSERT(false);  // PoolingParamsT not copyable.
      break;
    }
    case SoftwareLayerParams_EdslParams: {
      FLATBUFFERS_ASSERT(false);  // EdslParamsT not copyable.
      break;
    }
    case SoftwareLayerParams_TileParams: {
      value = new TileParamsT(*reinterpret_cast<TileParamsT *>(u.value));
      break;
    }
    case SoftwareLayerParams_PSROIPoolingParams: {
      value = new PSROIPoolingParamsT(*reinterpret_cast<PSROIPoolingParamsT *>(u.value));
      break;
    }
    case SoftwareLayerParams_DeconvolutionParams: {
      FLATBUFFERS_ASSERT(false);  // DeconvolutionParamsT not copyable.
      break;
    }
    case SoftwareLayerParams_UnaryOpParams: {
      value = new UnaryOpParamsT(*reinterpret_cast<UnaryOpParamsT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void SoftwareLayerParamsUnion::Reset() {
  switch (type) {
    case SoftwareLayerParams_DummyParams: {
      auto ptr = reinterpret_cast<DummyParamsT *>(value);
      delete ptr;
      break;
    }
    case SoftwareLayerParams_DetectionOutputParams: {
      auto ptr = reinterpret_cast<DetectionOutputParamsT *>(value);
      delete ptr;
      break;
    }
    case SoftwareLayerParams_FlattenParams: {
      auto ptr = reinterpret_cast<FlattenParamsT *>(value);
      delete ptr;
      break;
    }
    case SoftwareLayerParams_InterpParams: {
      auto ptr = reinterpret_cast<InterpParamsT *>(value);
      delete ptr;
      break;
    }
    case SoftwareLayerParams_NormalizeParams: {
      auto ptr = reinterpret_cast<NormalizeParamsT *>(value);
      delete ptr;
      break;
    }
    case SoftwareLayerParams_PermuteParams: {
      auto ptr = reinterpret_cast<PermuteParamsT *>(value);
      delete ptr;
      break;
    }
    case SoftwareLayerParams_PriorboxParams: {
      auto ptr = reinterpret_cast<PriorboxParamsT *>(value);
      delete ptr;
      break;
    }
    case SoftwareLayerParams_ProposalParams: {
      auto ptr = reinterpret_cast<ProposalParamsT *>(value);
      delete ptr;
      break;
    }
    case SoftwareLayerParams_RegionYOLOParams: {
      auto ptr = reinterpret_cast<RegionYOLOParamsT *>(value);
      delete ptr;
      break;
    }
    case SoftwareLayerParams_ReorgYOLOParams: {
      auto ptr = reinterpret_cast<ReorgYOLOParamsT *>(value);
      delete ptr;
      break;
    }
    case SoftwareLayerParams_ReshapeParams: {
      auto ptr = reinterpret_cast<ReshapeParamsT *>(value);
      delete ptr;
      break;
    }
    case SoftwareLayerParams_SoftmaxParams: {
      auto ptr = reinterpret_cast<SoftmaxParamsT *>(value);
      delete ptr;
      break;
    }
    case SoftwareLayerParams_CustomLayerParams: {
      auto ptr = reinterpret_cast<CustomLayerParamsT *>(value);
      delete ptr;
      break;
    }
    case SoftwareLayerParams_PassthroughParams: {
      auto ptr = reinterpret_cast<PassthroughParamsT *>(value);
      delete ptr;
      break;
    }
    case SoftwareLayerParams_LayerRecordParams: {
      auto ptr = reinterpret_cast<LayerRecordParamsT *>(value);
      delete ptr;
      break;
    }
    case SoftwareLayerParams_ROIPoolingParams: {
      auto ptr = reinterpret_cast<ROIPoolingParamsT *>(value);
      delete ptr;
      break;
    }
    case SoftwareLayerParams_QuantizeParams: {
      auto ptr = reinterpret_cast<QuantizeParamsT *>(value);
      delete ptr;
      break;
    }
    case SoftwareLayerParams_ArgMaxParams: {
      auto ptr = reinterpret_cast<ArgMaxParamsT *>(value);
      delete ptr;
      break;
    }
    case SoftwareLayerParams_NormParams: {
      auto ptr = reinterpret_cast<NormParamsT *>(value);
      delete ptr;
      break;
    }
    case SoftwareLayerParams_EltwiseParams: {
      auto ptr = reinterpret_cast<EltwiseParamsT *>(value);
      delete ptr;
      break;
    }
    case SoftwareLayerParams_ResampleParams: {
      auto ptr = reinterpret_cast<ResampleParamsT *>(value);
      delete ptr;
      break;
    }
    case SoftwareLayerParams_CorrelationParams: {
      auto ptr = reinterpret_cast<CorrelationParamsT *>(value);
      delete ptr;
      break;
    }
    case SoftwareLayerParams_MVNParams: {
      auto ptr = reinterpret_cast<MVNParamsT *>(value);
      delete ptr;
      break;
    }
    case SoftwareLayerParams_GRNParams: {
      auto ptr = reinterpret_cast<GRNParamsT *>(value);
      delete ptr;
      break;
    }
    case SoftwareLayerParams_CTCDecoderParams: {
      auto ptr = reinterpret_cast<CTCDecoderParamsT *>(value);
      delete ptr;
      break;
    }
    case SoftwareLayerParams_SpatialTransformParams: {
      auto ptr = reinterpret_cast<SpatialTransformParamsT *>(value);
      delete ptr;
      break;
    }
    case SoftwareLayerParams_FakeQuantizeParams: {
      auto ptr = reinterpret_cast<FakeQuantizeParamsT *>(value);
      delete ptr;
      break;
    }
    case SoftwareLayerParams_PoolingParams: {
      auto ptr = reinterpret_cast<PoolingParamsT *>(value);
      delete ptr;
      break;
    }
    case SoftwareLayerParams_EdslParams: {
      auto ptr = reinterpret_cast<EdslParamsT *>(value);
      delete ptr;
      break;
    }
    case SoftwareLayerParams_TileParams: {
      auto ptr = reinterpret_cast<TileParamsT *>(value);
      delete ptr;
      break;
    }
    case SoftwareLayerParams_PSROIPoolingParams: {
      auto ptr = reinterpret_cast<PSROIPoolingParamsT *>(value);
      delete ptr;
      break;
    }
    case SoftwareLayerParams_DeconvolutionParams: {
      auto ptr = reinterpret_cast<DeconvolutionParamsT *>(value);
      delete ptr;
      break;
    }
    case SoftwareLayerParams_UnaryOpParams: {
      auto ptr = reinterpret_cast<UnaryOpParamsT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = SoftwareLayerParams_NONE;
}

inline bool VerifySoftwareLayer(flatbuffers::Verifier &verifier, const void *obj, SoftwareLayer type) {
  switch (type) {
    case SoftwareLayer_NONE: {
      return true;
    }
    case SoftwareLayer_Conv2D: {
      auto ptr = reinterpret_cast<const Conv2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SoftwareLayer_Pooling: {
      auto ptr = reinterpret_cast<const Pooling *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SoftwareLayer_ReLU: {
      auto ptr = reinterpret_cast<const ReLU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SoftwareLayer_Passthrough: {
      auto ptr = reinterpret_cast<const Passthrough *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SoftwareLayer_Custom: {
      auto ptr = reinterpret_cast<const Custom *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifySoftwareLayerVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifySoftwareLayer(
        verifier,  values->Get(i), types->GetEnum<SoftwareLayer>(i))) {
      return false;
    }
  }
  return true;
}

inline void *SoftwareLayerUnion::UnPack(const void *obj, SoftwareLayer type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case SoftwareLayer_Conv2D: {
      auto ptr = reinterpret_cast<const Conv2D *>(obj);
      return ptr->UnPack(resolver);
    }
    case SoftwareLayer_Pooling: {
      auto ptr = reinterpret_cast<const Pooling *>(obj);
      return ptr->UnPack(resolver);
    }
    case SoftwareLayer_ReLU: {
      auto ptr = reinterpret_cast<const ReLU *>(obj);
      return ptr->UnPack(resolver);
    }
    case SoftwareLayer_Passthrough: {
      auto ptr = reinterpret_cast<const Passthrough *>(obj);
      return ptr->UnPack(resolver);
    }
    case SoftwareLayer_Custom: {
      auto ptr = reinterpret_cast<const Custom *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> SoftwareLayerUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case SoftwareLayer_Conv2D: {
      auto ptr = reinterpret_cast<const Conv2DT *>(value);
      return CreateConv2D(_fbb, ptr, _rehasher).Union();
    }
    case SoftwareLayer_Pooling: {
      auto ptr = reinterpret_cast<const PoolingT *>(value);
      return CreatePooling(_fbb, ptr, _rehasher).Union();
    }
    case SoftwareLayer_ReLU: {
      auto ptr = reinterpret_cast<const ReLUT *>(value);
      return CreateReLU(_fbb, ptr, _rehasher).Union();
    }
    case SoftwareLayer_Passthrough: {
      auto ptr = reinterpret_cast<const PassthroughT *>(value);
      return CreatePassthrough(_fbb, ptr, _rehasher).Union();
    }
    case SoftwareLayer_Custom: {
      auto ptr = reinterpret_cast<const CustomT *>(value);
      return CreateCustom(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline SoftwareLayerUnion::SoftwareLayerUnion(const SoftwareLayerUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case SoftwareLayer_Conv2D: {
      FLATBUFFERS_ASSERT(false);  // Conv2DT not copyable.
      break;
    }
    case SoftwareLayer_Pooling: {
      FLATBUFFERS_ASSERT(false);  // PoolingT not copyable.
      break;
    }
    case SoftwareLayer_ReLU: {
      FLATBUFFERS_ASSERT(false);  // ReLUT not copyable.
      break;
    }
    case SoftwareLayer_Passthrough: {
      FLATBUFFERS_ASSERT(false);  // PassthroughT not copyable.
      break;
    }
    case SoftwareLayer_Custom: {
      value = new CustomT(*reinterpret_cast<CustomT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void SoftwareLayerUnion::Reset() {
  switch (type) {
    case SoftwareLayer_Conv2D: {
      auto ptr = reinterpret_cast<Conv2DT *>(value);
      delete ptr;
      break;
    }
    case SoftwareLayer_Pooling: {
      auto ptr = reinterpret_cast<PoolingT *>(value);
      delete ptr;
      break;
    }
    case SoftwareLayer_ReLU: {
      auto ptr = reinterpret_cast<ReLUT *>(value);
      delete ptr;
      break;
    }
    case SoftwareLayer_Passthrough: {
      auto ptr = reinterpret_cast<PassthroughT *>(value);
      delete ptr;
      break;
    }
    case SoftwareLayer_Custom: {
      auto ptr = reinterpret_cast<CustomT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = SoftwareLayer_NONE;
}

inline bool VerifyNNHelper(flatbuffers::Verifier &verifier, const void *obj, NNHelper type) {
  switch (type) {
    case NNHelper_NONE: {
      return true;
    }
    case NNHelper_PPEConfigure: {
      auto ptr = reinterpret_cast<const PPEConfigure *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case NNHelper_PPEAssist: {
      auto ptr = reinterpret_cast<const PPEAssist *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyNNHelperVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyNNHelper(
        verifier,  values->Get(i), types->GetEnum<NNHelper>(i))) {
      return false;
    }
  }
  return true;
}

inline void *NNHelperUnion::UnPack(const void *obj, NNHelper type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case NNHelper_PPEConfigure: {
      auto ptr = reinterpret_cast<const PPEConfigure *>(obj);
      return ptr->UnPack(resolver);
    }
    case NNHelper_PPEAssist: {
      auto ptr = reinterpret_cast<const PPEAssist *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> NNHelperUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case NNHelper_PPEConfigure: {
      auto ptr = reinterpret_cast<const PPEConfigureT *>(value);
      return CreatePPEConfigure(_fbb, ptr, _rehasher).Union();
    }
    case NNHelper_PPEAssist: {
      auto ptr = reinterpret_cast<const PPEAssistT *>(value);
      return CreatePPEAssist(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline NNHelperUnion::NNHelperUnion(const NNHelperUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case NNHelper_PPEConfigure: {
      value = new PPEConfigureT(*reinterpret_cast<PPEConfigureT *>(u.value));
      break;
    }
    case NNHelper_PPEAssist: {
      value = new PPEAssistT(*reinterpret_cast<PPEAssistT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void NNHelperUnion::Reset() {
  switch (type) {
    case NNHelper_PPEConfigure: {
      auto ptr = reinterpret_cast<PPEConfigureT *>(value);
      delete ptr;
      break;
    }
    case NNHelper_PPEAssist: {
      auto ptr = reinterpret_cast<PPEAssistT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = NNHelper_NONE;
}

}  // namespace MVCNN

#endif  // FLATBUFFERS_GENERATED_SOFTWARE_MVCNN_H_
