// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GRAPHFILE_MVCNN_H_
#define FLATBUFFERS_GENERATED_GRAPHFILE_MVCNN_H_

#include "flatbuffers/flatbuffers.h"

#include "dma_generated.h"
#include "fileHeader_generated.h"
#include "memoryManagement_generated.h"
#include "nnController_generated.h"
#include "nnNCE2_generated.h"
#include "software_generated.h"
#include "structure_generated.h"
#include "upaNCE_generated.h"

namespace MVCNN {

struct GraphFile;
struct GraphFileT;

struct TaskList;
struct TaskListT;

struct Task;
struct TaskT;

enum SpecificTask {
  SpecificTask_NONE = 0,
  SpecificTask_MvTensorTask = 1,
  SpecificTask_UPADMATask = 2,
  SpecificTask_NNDMATask = 3,
  SpecificTask_NCE1Task = 4,
  SpecificTask_NCE2Task = 5,
  SpecificTask_NNTensorTask = 6,
  SpecificTask_ControllerTask = 7,
  SpecificTask_UPALayerTask = 8,
  SpecificTask_SNNLayerTask = 9,
  SpecificTask_MIN = SpecificTask_NONE,
  SpecificTask_MAX = SpecificTask_SNNLayerTask
};

inline const SpecificTask (&EnumValuesSpecificTask())[10] {
  static const SpecificTask values[] = {
    SpecificTask_NONE,
    SpecificTask_MvTensorTask,
    SpecificTask_UPADMATask,
    SpecificTask_NNDMATask,
    SpecificTask_NCE1Task,
    SpecificTask_NCE2Task,
    SpecificTask_NNTensorTask,
    SpecificTask_ControllerTask,
    SpecificTask_UPALayerTask,
    SpecificTask_SNNLayerTask
  };
  return values;
}

inline const char * const *EnumNamesSpecificTask() {
  static const char * const names[] = {
    "NONE",
    "MvTensorTask",
    "UPADMATask",
    "NNDMATask",
    "NCE1Task",
    "NCE2Task",
    "NNTensorTask",
    "ControllerTask",
    "UPALayerTask",
    "SNNLayerTask",
    nullptr
  };
  return names;
}

inline const char *EnumNameSpecificTask(SpecificTask e) {
  if (e < SpecificTask_NONE || e > SpecificTask_SNNLayerTask) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSpecificTask()[index];
}

template<typename T> struct SpecificTaskTraits {
  static const SpecificTask enum_value = SpecificTask_NONE;
};

template<> struct SpecificTaskTraits<MvTensorTask> {
  static const SpecificTask enum_value = SpecificTask_MvTensorTask;
};

template<> struct SpecificTaskTraits<UPADMATask> {
  static const SpecificTask enum_value = SpecificTask_UPADMATask;
};

template<> struct SpecificTaskTraits<NNDMATask> {
  static const SpecificTask enum_value = SpecificTask_NNDMATask;
};

template<> struct SpecificTaskTraits<NCE1Task> {
  static const SpecificTask enum_value = SpecificTask_NCE1Task;
};

template<> struct SpecificTaskTraits<NCE2Task> {
  static const SpecificTask enum_value = SpecificTask_NCE2Task;
};

template<> struct SpecificTaskTraits<NNTensorTask> {
  static const SpecificTask enum_value = SpecificTask_NNTensorTask;
};

template<> struct SpecificTaskTraits<ControllerTask> {
  static const SpecificTask enum_value = SpecificTask_ControllerTask;
};

template<> struct SpecificTaskTraits<UPALayerTask> {
  static const SpecificTask enum_value = SpecificTask_UPALayerTask;
};

template<> struct SpecificTaskTraits<SNNLayerTask> {
  static const SpecificTask enum_value = SpecificTask_SNNLayerTask;
};

struct SpecificTaskUnion {
  SpecificTask type;
  void *value;

  SpecificTaskUnion() : type(SpecificTask_NONE), value(nullptr) {}
  SpecificTaskUnion(SpecificTaskUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(SpecificTask_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  SpecificTaskUnion(const SpecificTaskUnion &) FLATBUFFERS_NOEXCEPT;
  SpecificTaskUnion &operator=(const SpecificTaskUnion &u) FLATBUFFERS_NOEXCEPT
    { SpecificTaskUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  SpecificTaskUnion &operator=(SpecificTaskUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~SpecificTaskUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = SpecificTaskTraits<typename RT::TableType>::enum_value;
    if (type != SpecificTask_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, SpecificTask type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  MvTensorTaskT *AsMvTensorTask() {
    return type == SpecificTask_MvTensorTask ?
      reinterpret_cast<MvTensorTaskT *>(value) : nullptr;
  }
  const MvTensorTaskT *AsMvTensorTask() const {
    return type == SpecificTask_MvTensorTask ?
      reinterpret_cast<const MvTensorTaskT *>(value) : nullptr;
  }
  UPADMATaskT *AsUPADMATask() {
    return type == SpecificTask_UPADMATask ?
      reinterpret_cast<UPADMATaskT *>(value) : nullptr;
  }
  const UPADMATaskT *AsUPADMATask() const {
    return type == SpecificTask_UPADMATask ?
      reinterpret_cast<const UPADMATaskT *>(value) : nullptr;
  }
  NNDMATaskT *AsNNDMATask() {
    return type == SpecificTask_NNDMATask ?
      reinterpret_cast<NNDMATaskT *>(value) : nullptr;
  }
  const NNDMATaskT *AsNNDMATask() const {
    return type == SpecificTask_NNDMATask ?
      reinterpret_cast<const NNDMATaskT *>(value) : nullptr;
  }
  NCE1TaskT *AsNCE1Task() {
    return type == SpecificTask_NCE1Task ?
      reinterpret_cast<NCE1TaskT *>(value) : nullptr;
  }
  const NCE1TaskT *AsNCE1Task() const {
    return type == SpecificTask_NCE1Task ?
      reinterpret_cast<const NCE1TaskT *>(value) : nullptr;
  }
  NCE2TaskT *AsNCE2Task() {
    return type == SpecificTask_NCE2Task ?
      reinterpret_cast<NCE2TaskT *>(value) : nullptr;
  }
  const NCE2TaskT *AsNCE2Task() const {
    return type == SpecificTask_NCE2Task ?
      reinterpret_cast<const NCE2TaskT *>(value) : nullptr;
  }
  NNTensorTaskT *AsNNTensorTask() {
    return type == SpecificTask_NNTensorTask ?
      reinterpret_cast<NNTensorTaskT *>(value) : nullptr;
  }
  const NNTensorTaskT *AsNNTensorTask() const {
    return type == SpecificTask_NNTensorTask ?
      reinterpret_cast<const NNTensorTaskT *>(value) : nullptr;
  }
  ControllerTaskT *AsControllerTask() {
    return type == SpecificTask_ControllerTask ?
      reinterpret_cast<ControllerTaskT *>(value) : nullptr;
  }
  const ControllerTaskT *AsControllerTask() const {
    return type == SpecificTask_ControllerTask ?
      reinterpret_cast<const ControllerTaskT *>(value) : nullptr;
  }
  UPALayerTaskT *AsUPALayerTask() {
    return type == SpecificTask_UPALayerTask ?
      reinterpret_cast<UPALayerTaskT *>(value) : nullptr;
  }
  const UPALayerTaskT *AsUPALayerTask() const {
    return type == SpecificTask_UPALayerTask ?
      reinterpret_cast<const UPALayerTaskT *>(value) : nullptr;
  }
  SNNLayerTaskT *AsSNNLayerTask() {
    return type == SpecificTask_SNNLayerTask ?
      reinterpret_cast<SNNLayerTaskT *>(value) : nullptr;
  }
  const SNNLayerTaskT *AsSNNLayerTask() const {
    return type == SpecificTask_SNNLayerTask ?
      reinterpret_cast<const SNNLayerTaskT *>(value) : nullptr;
  }
};

bool VerifySpecificTask(flatbuffers::Verifier &verifier, const void *obj, SpecificTask type);
bool VerifySpecificTaskVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct GraphFileT : public flatbuffers::NativeTable {
  typedef GraphFile TableType;
  std::unique_ptr<SummaryHeaderT> header;
  std::vector<std::unique_ptr<TaskListT>> task_lists;
  std::vector<std::unique_ptr<BarrierT>> barrier_table;
  std::vector<std::unique_ptr<BinaryDataT>> binary_data;
  GraphFileT() {
  }
};

struct GraphFile FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GraphFileT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEADER = 4,
    VT_TASK_LISTS = 6,
    VT_BARRIER_TABLE = 8,
    VT_BINARY_DATA = 10
  };
  /// Overview:
  ///    This is the "root" object of the file. Start here and traverse into different objects
  ///    while reading.
  ///
  ///
  const SummaryHeader *header() const {
    return GetPointer<const SummaryHeader *>(VT_HEADER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TaskList>> *task_lists() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TaskList>> *>(VT_TASK_LISTS);
  }
  /// A list of barriers to be consumed by the device for its own scheduling.
  /// If you are manually scheduling barriers with leon tasks, you do not need to
  /// populate this field.
  const flatbuffers::Vector<flatbuffers::Offset<Barrier>> *barrier_table() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Barrier>> *>(VT_BARRIER_TABLE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<BinaryData>> *binary_data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BinaryData>> *>(VT_BINARY_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffset(verifier, VT_TASK_LISTS) &&
           verifier.VerifyVector(task_lists()) &&
           verifier.VerifyVectorOfTables(task_lists()) &&
           VerifyOffset(verifier, VT_BARRIER_TABLE) &&
           verifier.VerifyVector(barrier_table()) &&
           verifier.VerifyVectorOfTables(barrier_table()) &&
           VerifyOffset(verifier, VT_BINARY_DATA) &&
           verifier.VerifyVector(binary_data()) &&
           verifier.VerifyVectorOfTables(binary_data()) &&
           verifier.EndTable();
  }
  GraphFileT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GraphFileT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GraphFile> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GraphFileT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GraphFileBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_header(flatbuffers::Offset<SummaryHeader> header) {
    fbb_.AddOffset(GraphFile::VT_HEADER, header);
  }
  void add_task_lists(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TaskList>>> task_lists) {
    fbb_.AddOffset(GraphFile::VT_TASK_LISTS, task_lists);
  }
  void add_barrier_table(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Barrier>>> barrier_table) {
    fbb_.AddOffset(GraphFile::VT_BARRIER_TABLE, barrier_table);
  }
  void add_binary_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BinaryData>>> binary_data) {
    fbb_.AddOffset(GraphFile::VT_BINARY_DATA, binary_data);
  }
  explicit GraphFileBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GraphFileBuilder &operator=(const GraphFileBuilder &);
  flatbuffers::Offset<GraphFile> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GraphFile>(end);
    return o;
  }
};

inline flatbuffers::Offset<GraphFile> CreateGraphFile(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<SummaryHeader> header = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TaskList>>> task_lists = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Barrier>>> barrier_table = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BinaryData>>> binary_data = 0) {
  GraphFileBuilder builder_(_fbb);
  builder_.add_binary_data(binary_data);
  builder_.add_barrier_table(barrier_table);
  builder_.add_task_lists(task_lists);
  builder_.add_header(header);
  return builder_.Finish();
}

inline flatbuffers::Offset<GraphFile> CreateGraphFileDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<SummaryHeader> header = 0,
    const std::vector<flatbuffers::Offset<TaskList>> *task_lists = nullptr,
    const std::vector<flatbuffers::Offset<Barrier>> *barrier_table = nullptr,
    const std::vector<flatbuffers::Offset<BinaryData>> *binary_data = nullptr) {
  auto task_lists__ = task_lists ? _fbb.CreateVector<flatbuffers::Offset<TaskList>>(*task_lists) : 0;
  auto barrier_table__ = barrier_table ? _fbb.CreateVector<flatbuffers::Offset<Barrier>>(*barrier_table) : 0;
  auto binary_data__ = binary_data ? _fbb.CreateVector<flatbuffers::Offset<BinaryData>>(*binary_data) : 0;
  return MVCNN::CreateGraphFile(
      _fbb,
      header,
      task_lists__,
      barrier_table__,
      binary_data__);
}

flatbuffers::Offset<GraphFile> CreateGraphFile(flatbuffers::FlatBufferBuilder &_fbb, const GraphFileT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TaskListT : public flatbuffers::NativeTable {
  typedef TaskList TableType;
  std::vector<std::unique_ptr<TaskT>> content;
  TaskListT() {
  }
};

struct TaskList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TaskListT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTENT = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Task>> *content() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Task>> *>(VT_CONTENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           verifier.VerifyVector(content()) &&
           verifier.VerifyVectorOfTables(content()) &&
           verifier.EndTable();
  }
  TaskListT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TaskListT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TaskList> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TaskListT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TaskListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_content(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Task>>> content) {
    fbb_.AddOffset(TaskList::VT_CONTENT, content);
  }
  explicit TaskListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TaskListBuilder &operator=(const TaskListBuilder &);
  flatbuffers::Offset<TaskList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TaskList>(end);
    return o;
  }
};

inline flatbuffers::Offset<TaskList> CreateTaskList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Task>>> content = 0) {
  TaskListBuilder builder_(_fbb);
  builder_.add_content(content);
  return builder_.Finish();
}

inline flatbuffers::Offset<TaskList> CreateTaskListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Task>> *content = nullptr) {
  auto content__ = content ? _fbb.CreateVector<flatbuffers::Offset<Task>>(*content) : 0;
  return MVCNN::CreateTaskList(
      _fbb,
      content__);
}

flatbuffers::Offset<TaskList> CreateTaskList(flatbuffers::FlatBufferBuilder &_fbb, const TaskListT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TaskT : public flatbuffers::NativeTable {
  typedef Task TableType;
  std::string name;
  uint32_t nodeID;
  std::vector<uint32_t> sourceTaskIDs;
  std::unique_ptr<BarrierReferenceT> associated_barriers;
  SpecificTaskUnion task;
  TaskT()
      : nodeID(0) {
  }
};

struct Task FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TaskT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_NODEID = 6,
    VT_SOURCETASKIDS = 8,
    VT_ASSOCIATED_BARRIERS = 10,
    VT_TASK_TYPE = 12,
    VT_TASK = 14
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t nodeID() const {
    return GetField<uint32_t>(VT_NODEID, 0);
  }
  const flatbuffers::Vector<uint32_t> *sourceTaskIDs() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_SOURCETASKIDS);
  }
  const BarrierReference *associated_barriers() const {
    return GetPointer<const BarrierReference *>(VT_ASSOCIATED_BARRIERS);
  }
  SpecificTask task_type() const {
    return static_cast<SpecificTask>(GetField<uint8_t>(VT_TASK_TYPE, 0));
  }
  const void *task() const {
    return GetPointer<const void *>(VT_TASK);
  }
  template<typename T> const T *task_as() const;
  const MvTensorTask *task_as_MvTensorTask() const {
    return task_type() == SpecificTask_MvTensorTask ? static_cast<const MvTensorTask *>(task()) : nullptr;
  }
  const UPADMATask *task_as_UPADMATask() const {
    return task_type() == SpecificTask_UPADMATask ? static_cast<const UPADMATask *>(task()) : nullptr;
  }
  const NNDMATask *task_as_NNDMATask() const {
    return task_type() == SpecificTask_NNDMATask ? static_cast<const NNDMATask *>(task()) : nullptr;
  }
  const NCE1Task *task_as_NCE1Task() const {
    return task_type() == SpecificTask_NCE1Task ? static_cast<const NCE1Task *>(task()) : nullptr;
  }
  const NCE2Task *task_as_NCE2Task() const {
    return task_type() == SpecificTask_NCE2Task ? static_cast<const NCE2Task *>(task()) : nullptr;
  }
  const NNTensorTask *task_as_NNTensorTask() const {
    return task_type() == SpecificTask_NNTensorTask ? static_cast<const NNTensorTask *>(task()) : nullptr;
  }
  const ControllerTask *task_as_ControllerTask() const {
    return task_type() == SpecificTask_ControllerTask ? static_cast<const ControllerTask *>(task()) : nullptr;
  }
  const UPALayerTask *task_as_UPALayerTask() const {
    return task_type() == SpecificTask_UPALayerTask ? static_cast<const UPALayerTask *>(task()) : nullptr;
  }
  const SNNLayerTask *task_as_SNNLayerTask() const {
    return task_type() == SpecificTask_SNNLayerTask ? static_cast<const SNNLayerTask *>(task()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_NODEID) &&
           VerifyOffset(verifier, VT_SOURCETASKIDS) &&
           verifier.VerifyVector(sourceTaskIDs()) &&
           VerifyOffset(verifier, VT_ASSOCIATED_BARRIERS) &&
           verifier.VerifyTable(associated_barriers()) &&
           VerifyField<uint8_t>(verifier, VT_TASK_TYPE) &&
           VerifyOffset(verifier, VT_TASK) &&
           VerifySpecificTask(verifier, task(), task_type()) &&
           verifier.EndTable();
  }
  TaskT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TaskT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Task> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TaskT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const MvTensorTask *Task::task_as<MvTensorTask>() const {
  return task_as_MvTensorTask();
}

template<> inline const UPADMATask *Task::task_as<UPADMATask>() const {
  return task_as_UPADMATask();
}

template<> inline const NNDMATask *Task::task_as<NNDMATask>() const {
  return task_as_NNDMATask();
}

template<> inline const NCE1Task *Task::task_as<NCE1Task>() const {
  return task_as_NCE1Task();
}

template<> inline const NCE2Task *Task::task_as<NCE2Task>() const {
  return task_as_NCE2Task();
}

template<> inline const NNTensorTask *Task::task_as<NNTensorTask>() const {
  return task_as_NNTensorTask();
}

template<> inline const ControllerTask *Task::task_as<ControllerTask>() const {
  return task_as_ControllerTask();
}

template<> inline const UPALayerTask *Task::task_as<UPALayerTask>() const {
  return task_as_UPALayerTask();
}

template<> inline const SNNLayerTask *Task::task_as<SNNLayerTask>() const {
  return task_as_SNNLayerTask();
}

struct TaskBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Task::VT_NAME, name);
  }
  void add_nodeID(uint32_t nodeID) {
    fbb_.AddElement<uint32_t>(Task::VT_NODEID, nodeID, 0);
  }
  void add_sourceTaskIDs(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> sourceTaskIDs) {
    fbb_.AddOffset(Task::VT_SOURCETASKIDS, sourceTaskIDs);
  }
  void add_associated_barriers(flatbuffers::Offset<BarrierReference> associated_barriers) {
    fbb_.AddOffset(Task::VT_ASSOCIATED_BARRIERS, associated_barriers);
  }
  void add_task_type(SpecificTask task_type) {
    fbb_.AddElement<uint8_t>(Task::VT_TASK_TYPE, static_cast<uint8_t>(task_type), 0);
  }
  void add_task(flatbuffers::Offset<void> task) {
    fbb_.AddOffset(Task::VT_TASK, task);
  }
  explicit TaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TaskBuilder &operator=(const TaskBuilder &);
  flatbuffers::Offset<Task> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Task>(end);
    return o;
  }
};

inline flatbuffers::Offset<Task> CreateTask(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t nodeID = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> sourceTaskIDs = 0,
    flatbuffers::Offset<BarrierReference> associated_barriers = 0,
    SpecificTask task_type = SpecificTask_NONE,
    flatbuffers::Offset<void> task = 0) {
  TaskBuilder builder_(_fbb);
  builder_.add_task(task);
  builder_.add_associated_barriers(associated_barriers);
  builder_.add_sourceTaskIDs(sourceTaskIDs);
  builder_.add_nodeID(nodeID);
  builder_.add_name(name);
  builder_.add_task_type(task_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Task> CreateTaskDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t nodeID = 0,
    const std::vector<uint32_t> *sourceTaskIDs = nullptr,
    flatbuffers::Offset<BarrierReference> associated_barriers = 0,
    SpecificTask task_type = SpecificTask_NONE,
    flatbuffers::Offset<void> task = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto sourceTaskIDs__ = sourceTaskIDs ? _fbb.CreateVector<uint32_t>(*sourceTaskIDs) : 0;
  return MVCNN::CreateTask(
      _fbb,
      name__,
      nodeID,
      sourceTaskIDs__,
      associated_barriers,
      task_type,
      task);
}

flatbuffers::Offset<Task> CreateTask(flatbuffers::FlatBufferBuilder &_fbb, const TaskT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline GraphFileT *GraphFile::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GraphFileT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GraphFile::UnPackTo(GraphFileT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = header(); if (_e) _o->header = std::unique_ptr<SummaryHeaderT>(_e->UnPack(_resolver)); };
  { auto _e = task_lists(); if (_e) { _o->task_lists.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->task_lists[_i] = std::unique_ptr<TaskListT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = barrier_table(); if (_e) { _o->barrier_table.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->barrier_table[_i] = std::unique_ptr<BarrierT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = binary_data(); if (_e) { _o->binary_data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->binary_data[_i] = std::unique_ptr<BinaryDataT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<GraphFile> GraphFile::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GraphFileT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGraphFile(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GraphFile> CreateGraphFile(flatbuffers::FlatBufferBuilder &_fbb, const GraphFileT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GraphFileT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _header = _o->header ? CreateSummaryHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _task_lists = _fbb.CreateVector<flatbuffers::Offset<TaskList>> (_o->task_lists.size(), [](size_t i, _VectorArgs *__va) { return CreateTaskList(*__va->__fbb, __va->__o->task_lists[i].get(), __va->__rehasher); }, &_va );
  auto _barrier_table = _fbb.CreateVector<flatbuffers::Offset<Barrier>> (_o->barrier_table.size(), [](size_t i, _VectorArgs *__va) { return CreateBarrier(*__va->__fbb, __va->__o->barrier_table[i].get(), __va->__rehasher); }, &_va );
  auto _binary_data = _fbb.CreateVector<flatbuffers::Offset<BinaryData>> (_o->binary_data.size(), [](size_t i, _VectorArgs *__va) { return CreateBinaryData(*__va->__fbb, __va->__o->binary_data[i].get(), __va->__rehasher); }, &_va );
  return MVCNN::CreateGraphFile(
      _fbb,
      _header,
      _task_lists,
      _barrier_table,
      _binary_data);
}

inline TaskListT *TaskList::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TaskListT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TaskList::UnPackTo(TaskListT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = content(); if (_e) { _o->content.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->content[_i] = std::unique_ptr<TaskT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<TaskList> TaskList::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TaskListT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTaskList(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TaskList> CreateTaskList(flatbuffers::FlatBufferBuilder &_fbb, const TaskListT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TaskListT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _content = _fbb.CreateVector<flatbuffers::Offset<Task>> (_o->content.size(), [](size_t i, _VectorArgs *__va) { return CreateTask(*__va->__fbb, __va->__o->content[i].get(), __va->__rehasher); }, &_va );
  return MVCNN::CreateTaskList(
      _fbb,
      _content);
}

inline TaskT *Task::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TaskT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Task::UnPackTo(TaskT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = nodeID(); _o->nodeID = _e; };
  { auto _e = sourceTaskIDs(); if (_e) { _o->sourceTaskIDs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->sourceTaskIDs[_i] = _e->Get(_i); } } };
  { auto _e = associated_barriers(); if (_e) _o->associated_barriers = std::unique_ptr<BarrierReferenceT>(_e->UnPack(_resolver)); };
  { auto _e = task_type(); _o->task.type = _e; };
  { auto _e = task(); if (_e) _o->task.value = SpecificTaskUnion::UnPack(_e, task_type(), _resolver); };
}

inline flatbuffers::Offset<Task> Task::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TaskT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTask(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Task> CreateTask(flatbuffers::FlatBufferBuilder &_fbb, const TaskT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TaskT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->name);
  auto _nodeID = _o->nodeID;
  auto _sourceTaskIDs = _fbb.CreateVector(_o->sourceTaskIDs);
  auto _associated_barriers = _o->associated_barriers ? CreateBarrierReference(_fbb, _o->associated_barriers.get(), _rehasher) : 0;
  auto _task_type = _o->task.type;
  auto _task = _o->task.Pack(_fbb);
  return MVCNN::CreateTask(
      _fbb,
      _name,
      _nodeID,
      _sourceTaskIDs,
      _associated_barriers,
      _task_type,
      _task);
}

inline bool VerifySpecificTask(flatbuffers::Verifier &verifier, const void *obj, SpecificTask type) {
  switch (type) {
    case SpecificTask_NONE: {
      return true;
    }
    case SpecificTask_MvTensorTask: {
      auto ptr = reinterpret_cast<const MvTensorTask *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SpecificTask_UPADMATask: {
      auto ptr = reinterpret_cast<const UPADMATask *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SpecificTask_NNDMATask: {
      auto ptr = reinterpret_cast<const NNDMATask *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SpecificTask_NCE1Task: {
      auto ptr = reinterpret_cast<const NCE1Task *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SpecificTask_NCE2Task: {
      auto ptr = reinterpret_cast<const NCE2Task *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SpecificTask_NNTensorTask: {
      auto ptr = reinterpret_cast<const NNTensorTask *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SpecificTask_ControllerTask: {
      auto ptr = reinterpret_cast<const ControllerTask *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SpecificTask_UPALayerTask: {
      auto ptr = reinterpret_cast<const UPALayerTask *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SpecificTask_SNNLayerTask: {
      auto ptr = reinterpret_cast<const SNNLayerTask *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifySpecificTaskVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifySpecificTask(
        verifier,  values->Get(i), types->GetEnum<SpecificTask>(i))) {
      return false;
    }
  }
  return true;
}

inline void *SpecificTaskUnion::UnPack(const void *obj, SpecificTask type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case SpecificTask_MvTensorTask: {
      auto ptr = reinterpret_cast<const MvTensorTask *>(obj);
      return ptr->UnPack(resolver);
    }
    case SpecificTask_UPADMATask: {
      auto ptr = reinterpret_cast<const UPADMATask *>(obj);
      return ptr->UnPack(resolver);
    }
    case SpecificTask_NNDMATask: {
      auto ptr = reinterpret_cast<const NNDMATask *>(obj);
      return ptr->UnPack(resolver);
    }
    case SpecificTask_NCE1Task: {
      auto ptr = reinterpret_cast<const NCE1Task *>(obj);
      return ptr->UnPack(resolver);
    }
    case SpecificTask_NCE2Task: {
      auto ptr = reinterpret_cast<const NCE2Task *>(obj);
      return ptr->UnPack(resolver);
    }
    case SpecificTask_NNTensorTask: {
      auto ptr = reinterpret_cast<const NNTensorTask *>(obj);
      return ptr->UnPack(resolver);
    }
    case SpecificTask_ControllerTask: {
      auto ptr = reinterpret_cast<const ControllerTask *>(obj);
      return ptr->UnPack(resolver);
    }
    case SpecificTask_UPALayerTask: {
      auto ptr = reinterpret_cast<const UPALayerTask *>(obj);
      return ptr->UnPack(resolver);
    }
    case SpecificTask_SNNLayerTask: {
      auto ptr = reinterpret_cast<const SNNLayerTask *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> SpecificTaskUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case SpecificTask_MvTensorTask: {
      auto ptr = reinterpret_cast<const MvTensorTaskT *>(value);
      return CreateMvTensorTask(_fbb, ptr, _rehasher).Union();
    }
    case SpecificTask_UPADMATask: {
      auto ptr = reinterpret_cast<const UPADMATaskT *>(value);
      return CreateUPADMATask(_fbb, ptr, _rehasher).Union();
    }
    case SpecificTask_NNDMATask: {
      auto ptr = reinterpret_cast<const NNDMATaskT *>(value);
      return CreateNNDMATask(_fbb, ptr, _rehasher).Union();
    }
    case SpecificTask_NCE1Task: {
      auto ptr = reinterpret_cast<const NCE1TaskT *>(value);
      return CreateNCE1Task(_fbb, ptr, _rehasher).Union();
    }
    case SpecificTask_NCE2Task: {
      auto ptr = reinterpret_cast<const NCE2TaskT *>(value);
      return CreateNCE2Task(_fbb, ptr, _rehasher).Union();
    }
    case SpecificTask_NNTensorTask: {
      auto ptr = reinterpret_cast<const NNTensorTaskT *>(value);
      return CreateNNTensorTask(_fbb, ptr, _rehasher).Union();
    }
    case SpecificTask_ControllerTask: {
      auto ptr = reinterpret_cast<const ControllerTaskT *>(value);
      return CreateControllerTask(_fbb, ptr, _rehasher).Union();
    }
    case SpecificTask_UPALayerTask: {
      auto ptr = reinterpret_cast<const UPALayerTaskT *>(value);
      return CreateUPALayerTask(_fbb, ptr, _rehasher).Union();
    }
    case SpecificTask_SNNLayerTask: {
      auto ptr = reinterpret_cast<const SNNLayerTaskT *>(value);
      return CreateSNNLayerTask(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline SpecificTaskUnion::SpecificTaskUnion(const SpecificTaskUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case SpecificTask_MvTensorTask: {
      value = new MvTensorTaskT(*reinterpret_cast<MvTensorTaskT *>(u.value));
      break;
    }
    case SpecificTask_UPADMATask: {
      FLATBUFFERS_ASSERT(false);  // UPADMATaskT not copyable.
      break;
    }
    case SpecificTask_NNDMATask: {
      FLATBUFFERS_ASSERT(false);  // NNDMATaskT not copyable.
      break;
    }
    case SpecificTask_NCE1Task: {
      value = new NCE1TaskT(*reinterpret_cast<NCE1TaskT *>(u.value));
      break;
    }
    case SpecificTask_NCE2Task: {
      FLATBUFFERS_ASSERT(false);  // NCE2TaskT not copyable.
      break;
    }
    case SpecificTask_NNTensorTask: {
      value = new NNTensorTaskT(*reinterpret_cast<NNTensorTaskT *>(u.value));
      break;
    }
    case SpecificTask_ControllerTask: {
      value = new ControllerTaskT(*reinterpret_cast<ControllerTaskT *>(u.value));
      break;
    }
    case SpecificTask_UPALayerTask: {
      FLATBUFFERS_ASSERT(false);  // UPALayerTaskT not copyable.
      break;
    }
    case SpecificTask_SNNLayerTask: {
      value = new SNNLayerTaskT(*reinterpret_cast<SNNLayerTaskT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void SpecificTaskUnion::Reset() {
  switch (type) {
    case SpecificTask_MvTensorTask: {
      auto ptr = reinterpret_cast<MvTensorTaskT *>(value);
      delete ptr;
      break;
    }
    case SpecificTask_UPADMATask: {
      auto ptr = reinterpret_cast<UPADMATaskT *>(value);
      delete ptr;
      break;
    }
    case SpecificTask_NNDMATask: {
      auto ptr = reinterpret_cast<NNDMATaskT *>(value);
      delete ptr;
      break;
    }
    case SpecificTask_NCE1Task: {
      auto ptr = reinterpret_cast<NCE1TaskT *>(value);
      delete ptr;
      break;
    }
    case SpecificTask_NCE2Task: {
      auto ptr = reinterpret_cast<NCE2TaskT *>(value);
      delete ptr;
      break;
    }
    case SpecificTask_NNTensorTask: {
      auto ptr = reinterpret_cast<NNTensorTaskT *>(value);
      delete ptr;
      break;
    }
    case SpecificTask_ControllerTask: {
      auto ptr = reinterpret_cast<ControllerTaskT *>(value);
      delete ptr;
      break;
    }
    case SpecificTask_UPALayerTask: {
      auto ptr = reinterpret_cast<UPALayerTaskT *>(value);
      delete ptr;
      break;
    }
    case SpecificTask_SNNLayerTask: {
      auto ptr = reinterpret_cast<SNNLayerTaskT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = SpecificTask_NONE;
}

inline const MVCNN::GraphFile *GetGraphFile(const void *buf) {
  return flatbuffers::GetRoot<MVCNN::GraphFile>(buf);
}

inline const MVCNN::GraphFile *GetSizePrefixedGraphFile(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<MVCNN::GraphFile>(buf);
}

inline const char *GraphFileIdentifier() {
  return "BLOB";
}

inline bool GraphFileBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, GraphFileIdentifier());
}

inline bool VerifyGraphFileBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<MVCNN::GraphFile>(GraphFileIdentifier());
}

inline bool VerifySizePrefixedGraphFileBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<MVCNN::GraphFile>(GraphFileIdentifier());
}

inline const char *GraphFileExtension() {
  return "blob";
}

inline void FinishGraphFileBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<MVCNN::GraphFile> root) {
  fbb.Finish(root, GraphFileIdentifier());
}

inline void FinishSizePrefixedGraphFileBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<MVCNN::GraphFile> root) {
  fbb.FinishSizePrefixed(root, GraphFileIdentifier());
}

inline std::unique_ptr<GraphFileT> UnPackGraphFile(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<GraphFileT>(GetGraphFile(buf)->UnPack(res));
}

}  // namespace MVCNN

#endif  // FLATBUFFERS_GENERATED_GRAPHFILE_MVCNN_H_
