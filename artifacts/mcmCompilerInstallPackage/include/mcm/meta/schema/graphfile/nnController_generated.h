// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_NNCONTROLLER_MVCNN_H_
#define FLATBUFFERS_GENERATED_NNCONTROLLER_MVCNN_H_

#include "flatbuffers/flatbuffers.h"

#include "memoryManagement_generated.h"
#include "structure_generated.h"

namespace MVCNN {

struct TimerTask;
struct TimerTaskT;

struct BarrierConfigurationTask;
struct BarrierConfigurationTaskT;

struct AddToNCE2CMXBacklogTask;
struct AddToNCE2CMXBacklogTaskT;

struct AddToNNDMABacklogTask;
struct AddToNNDMABacklogTaskT;

struct EmptyTask;
struct EmptyTaskT;

struct UPAStartSHVTask;
struct UPAStartSHVTaskT;

struct UPAEndSHVTask;
struct UPAEndSHVTaskT;

struct NNStartSHVTask;
struct NNStartSHVTaskT;

struct NNEndSHVTask;
struct NNEndSHVTaskT;

struct ControllerTask;
struct ControllerTaskT;

enum ControllerSubTask {
  ControllerSubTask_NONE = 0,
  ControllerSubTask_TimerTask = 1,
  ControllerSubTask_BarrierConfigurationTask = 2,
  ControllerSubTask_AddToNCE2CMXBacklogTask = 3,
  ControllerSubTask_AddToNNDMABacklogTask = 4,
  ControllerSubTask_UPAStartSHVTask = 5,
  ControllerSubTask_UPAEndSHVTask = 6,
  ControllerSubTask_NNStartSHVTask = 7,
  ControllerSubTask_NNEndSHVTask = 8,
  ControllerSubTask_EmptyTask = 9,
  ControllerSubTask_MIN = ControllerSubTask_NONE,
  ControllerSubTask_MAX = ControllerSubTask_EmptyTask
};

inline const ControllerSubTask (&EnumValuesControllerSubTask())[10] {
  static const ControllerSubTask values[] = {
    ControllerSubTask_NONE,
    ControllerSubTask_TimerTask,
    ControllerSubTask_BarrierConfigurationTask,
    ControllerSubTask_AddToNCE2CMXBacklogTask,
    ControllerSubTask_AddToNNDMABacklogTask,
    ControllerSubTask_UPAStartSHVTask,
    ControllerSubTask_UPAEndSHVTask,
    ControllerSubTask_NNStartSHVTask,
    ControllerSubTask_NNEndSHVTask,
    ControllerSubTask_EmptyTask
  };
  return values;
}

inline const char * const *EnumNamesControllerSubTask() {
  static const char * const names[] = {
    "NONE",
    "TimerTask",
    "BarrierConfigurationTask",
    "AddToNCE2CMXBacklogTask",
    "AddToNNDMABacklogTask",
    "UPAStartSHVTask",
    "UPAEndSHVTask",
    "NNStartSHVTask",
    "NNEndSHVTask",
    "EmptyTask",
    nullptr
  };
  return names;
}

inline const char *EnumNameControllerSubTask(ControllerSubTask e) {
  if (e < ControllerSubTask_NONE || e > ControllerSubTask_EmptyTask) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesControllerSubTask()[index];
}

template<typename T> struct ControllerSubTaskTraits {
  static const ControllerSubTask enum_value = ControllerSubTask_NONE;
};

template<> struct ControllerSubTaskTraits<TimerTask> {
  static const ControllerSubTask enum_value = ControllerSubTask_TimerTask;
};

template<> struct ControllerSubTaskTraits<BarrierConfigurationTask> {
  static const ControllerSubTask enum_value = ControllerSubTask_BarrierConfigurationTask;
};

template<> struct ControllerSubTaskTraits<AddToNCE2CMXBacklogTask> {
  static const ControllerSubTask enum_value = ControllerSubTask_AddToNCE2CMXBacklogTask;
};

template<> struct ControllerSubTaskTraits<AddToNNDMABacklogTask> {
  static const ControllerSubTask enum_value = ControllerSubTask_AddToNNDMABacklogTask;
};

template<> struct ControllerSubTaskTraits<UPAStartSHVTask> {
  static const ControllerSubTask enum_value = ControllerSubTask_UPAStartSHVTask;
};

template<> struct ControllerSubTaskTraits<UPAEndSHVTask> {
  static const ControllerSubTask enum_value = ControllerSubTask_UPAEndSHVTask;
};

template<> struct ControllerSubTaskTraits<NNStartSHVTask> {
  static const ControllerSubTask enum_value = ControllerSubTask_NNStartSHVTask;
};

template<> struct ControllerSubTaskTraits<NNEndSHVTask> {
  static const ControllerSubTask enum_value = ControllerSubTask_NNEndSHVTask;
};

template<> struct ControllerSubTaskTraits<EmptyTask> {
  static const ControllerSubTask enum_value = ControllerSubTask_EmptyTask;
};

struct ControllerSubTaskUnion {
  ControllerSubTask type;
  void *value;

  ControllerSubTaskUnion() : type(ControllerSubTask_NONE), value(nullptr) {}
  ControllerSubTaskUnion(ControllerSubTaskUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(ControllerSubTask_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ControllerSubTaskUnion(const ControllerSubTaskUnion &) FLATBUFFERS_NOEXCEPT;
  ControllerSubTaskUnion &operator=(const ControllerSubTaskUnion &u) FLATBUFFERS_NOEXCEPT
    { ControllerSubTaskUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ControllerSubTaskUnion &operator=(ControllerSubTaskUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ControllerSubTaskUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = ControllerSubTaskTraits<typename RT::TableType>::enum_value;
    if (type != ControllerSubTask_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, ControllerSubTask type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  TimerTaskT *AsTimerTask() {
    return type == ControllerSubTask_TimerTask ?
      reinterpret_cast<TimerTaskT *>(value) : nullptr;
  }
  const TimerTaskT *AsTimerTask() const {
    return type == ControllerSubTask_TimerTask ?
      reinterpret_cast<const TimerTaskT *>(value) : nullptr;
  }
  BarrierConfigurationTaskT *AsBarrierConfigurationTask() {
    return type == ControllerSubTask_BarrierConfigurationTask ?
      reinterpret_cast<BarrierConfigurationTaskT *>(value) : nullptr;
  }
  const BarrierConfigurationTaskT *AsBarrierConfigurationTask() const {
    return type == ControllerSubTask_BarrierConfigurationTask ?
      reinterpret_cast<const BarrierConfigurationTaskT *>(value) : nullptr;
  }
  AddToNCE2CMXBacklogTaskT *AsAddToNCE2CMXBacklogTask() {
    return type == ControllerSubTask_AddToNCE2CMXBacklogTask ?
      reinterpret_cast<AddToNCE2CMXBacklogTaskT *>(value) : nullptr;
  }
  const AddToNCE2CMXBacklogTaskT *AsAddToNCE2CMXBacklogTask() const {
    return type == ControllerSubTask_AddToNCE2CMXBacklogTask ?
      reinterpret_cast<const AddToNCE2CMXBacklogTaskT *>(value) : nullptr;
  }
  AddToNNDMABacklogTaskT *AsAddToNNDMABacklogTask() {
    return type == ControllerSubTask_AddToNNDMABacklogTask ?
      reinterpret_cast<AddToNNDMABacklogTaskT *>(value) : nullptr;
  }
  const AddToNNDMABacklogTaskT *AsAddToNNDMABacklogTask() const {
    return type == ControllerSubTask_AddToNNDMABacklogTask ?
      reinterpret_cast<const AddToNNDMABacklogTaskT *>(value) : nullptr;
  }
  UPAStartSHVTaskT *AsUPAStartSHVTask() {
    return type == ControllerSubTask_UPAStartSHVTask ?
      reinterpret_cast<UPAStartSHVTaskT *>(value) : nullptr;
  }
  const UPAStartSHVTaskT *AsUPAStartSHVTask() const {
    return type == ControllerSubTask_UPAStartSHVTask ?
      reinterpret_cast<const UPAStartSHVTaskT *>(value) : nullptr;
  }
  UPAEndSHVTaskT *AsUPAEndSHVTask() {
    return type == ControllerSubTask_UPAEndSHVTask ?
      reinterpret_cast<UPAEndSHVTaskT *>(value) : nullptr;
  }
  const UPAEndSHVTaskT *AsUPAEndSHVTask() const {
    return type == ControllerSubTask_UPAEndSHVTask ?
      reinterpret_cast<const UPAEndSHVTaskT *>(value) : nullptr;
  }
  NNStartSHVTaskT *AsNNStartSHVTask() {
    return type == ControllerSubTask_NNStartSHVTask ?
      reinterpret_cast<NNStartSHVTaskT *>(value) : nullptr;
  }
  const NNStartSHVTaskT *AsNNStartSHVTask() const {
    return type == ControllerSubTask_NNStartSHVTask ?
      reinterpret_cast<const NNStartSHVTaskT *>(value) : nullptr;
  }
  NNEndSHVTaskT *AsNNEndSHVTask() {
    return type == ControllerSubTask_NNEndSHVTask ?
      reinterpret_cast<NNEndSHVTaskT *>(value) : nullptr;
  }
  const NNEndSHVTaskT *AsNNEndSHVTask() const {
    return type == ControllerSubTask_NNEndSHVTask ?
      reinterpret_cast<const NNEndSHVTaskT *>(value) : nullptr;
  }
  EmptyTaskT *AsEmptyTask() {
    return type == ControllerSubTask_EmptyTask ?
      reinterpret_cast<EmptyTaskT *>(value) : nullptr;
  }
  const EmptyTaskT *AsEmptyTask() const {
    return type == ControllerSubTask_EmptyTask ?
      reinterpret_cast<const EmptyTaskT *>(value) : nullptr;
  }
};

bool VerifyControllerSubTask(flatbuffers::Verifier &verifier, const void *obj, ControllerSubTask type);
bool VerifyControllerSubTaskVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct TimerTaskT : public flatbuffers::NativeTable {
  typedef TimerTask TableType;
  uint32_t id;
  std::unique_ptr<TensorReferenceT> write_location;
  TimerTaskT()
      : id(0) {
  }
};

struct TimerTask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TimerTaskT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_WRITE_LOCATION = 6
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  const TensorReference *write_location() const {
    return GetPointer<const TensorReference *>(VT_WRITE_LOCATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_WRITE_LOCATION) &&
           verifier.VerifyTable(write_location()) &&
           verifier.EndTable();
  }
  TimerTaskT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TimerTaskT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TimerTask> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TimerTaskT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TimerTaskBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(TimerTask::VT_ID, id, 0);
  }
  void add_write_location(flatbuffers::Offset<TensorReference> write_location) {
    fbb_.AddOffset(TimerTask::VT_WRITE_LOCATION, write_location);
  }
  explicit TimerTaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TimerTaskBuilder &operator=(const TimerTaskBuilder &);
  flatbuffers::Offset<TimerTask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TimerTask>(end);
    return o;
  }
};

inline flatbuffers::Offset<TimerTask> CreateTimerTask(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    flatbuffers::Offset<TensorReference> write_location = 0) {
  TimerTaskBuilder builder_(_fbb);
  builder_.add_write_location(write_location);
  builder_.add_id(id);
  return builder_.Finish();
}

flatbuffers::Offset<TimerTask> CreateTimerTask(flatbuffers::FlatBufferBuilder &_fbb, const TimerTaskT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BarrierConfigurationTaskT : public flatbuffers::NativeTable {
  typedef BarrierConfigurationTask TableType;
  std::unique_ptr<BarrierT> target;
  BarrierConfigurationTaskT() {
  }
};

struct BarrierConfigurationTask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BarrierConfigurationTaskT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TARGET = 4
  };
  const Barrier *target() const {
    return GetPointer<const Barrier *>(VT_TARGET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TARGET) &&
           verifier.VerifyTable(target()) &&
           verifier.EndTable();
  }
  BarrierConfigurationTaskT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BarrierConfigurationTaskT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BarrierConfigurationTask> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BarrierConfigurationTaskT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BarrierConfigurationTaskBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_target(flatbuffers::Offset<Barrier> target) {
    fbb_.AddOffset(BarrierConfigurationTask::VT_TARGET, target);
  }
  explicit BarrierConfigurationTaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BarrierConfigurationTaskBuilder &operator=(const BarrierConfigurationTaskBuilder &);
  flatbuffers::Offset<BarrierConfigurationTask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BarrierConfigurationTask>(end);
    return o;
  }
};

inline flatbuffers::Offset<BarrierConfigurationTask> CreateBarrierConfigurationTask(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Barrier> target = 0) {
  BarrierConfigurationTaskBuilder builder_(_fbb);
  builder_.add_target(target);
  return builder_.Finish();
}

flatbuffers::Offset<BarrierConfigurationTask> CreateBarrierConfigurationTask(flatbuffers::FlatBufferBuilder &_fbb, const BarrierConfigurationTaskT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AddToNCE2CMXBacklogTaskT : public flatbuffers::NativeTable {
  typedef AddToNCE2CMXBacklogTask TableType;
  uint32_t id;
  std::vector<uint32_t> tasks;
  AddToNCE2CMXBacklogTaskT()
      : id(0) {
  }
};

struct AddToNCE2CMXBacklogTask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AddToNCE2CMXBacklogTaskT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TASKS = 6
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  const flatbuffers::Vector<uint32_t> *tasks() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_TASKS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_TASKS) &&
           verifier.VerifyVector(tasks()) &&
           verifier.EndTable();
  }
  AddToNCE2CMXBacklogTaskT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AddToNCE2CMXBacklogTaskT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AddToNCE2CMXBacklogTask> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddToNCE2CMXBacklogTaskT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AddToNCE2CMXBacklogTaskBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(AddToNCE2CMXBacklogTask::VT_ID, id, 0);
  }
  void add_tasks(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> tasks) {
    fbb_.AddOffset(AddToNCE2CMXBacklogTask::VT_TASKS, tasks);
  }
  explicit AddToNCE2CMXBacklogTaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddToNCE2CMXBacklogTaskBuilder &operator=(const AddToNCE2CMXBacklogTaskBuilder &);
  flatbuffers::Offset<AddToNCE2CMXBacklogTask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddToNCE2CMXBacklogTask>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddToNCE2CMXBacklogTask> CreateAddToNCE2CMXBacklogTask(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> tasks = 0) {
  AddToNCE2CMXBacklogTaskBuilder builder_(_fbb);
  builder_.add_tasks(tasks);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<AddToNCE2CMXBacklogTask> CreateAddToNCE2CMXBacklogTaskDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    const std::vector<uint32_t> *tasks = nullptr) {
  auto tasks__ = tasks ? _fbb.CreateVector<uint32_t>(*tasks) : 0;
  return MVCNN::CreateAddToNCE2CMXBacklogTask(
      _fbb,
      id,
      tasks__);
}

flatbuffers::Offset<AddToNCE2CMXBacklogTask> CreateAddToNCE2CMXBacklogTask(flatbuffers::FlatBufferBuilder &_fbb, const AddToNCE2CMXBacklogTaskT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AddToNNDMABacklogTaskT : public flatbuffers::NativeTable {
  typedef AddToNNDMABacklogTask TableType;
  uint32_t id;
  std::vector<uint32_t> tasks;
  AddToNNDMABacklogTaskT()
      : id(0) {
  }
};

struct AddToNNDMABacklogTask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AddToNNDMABacklogTaskT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TASKS = 6
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  const flatbuffers::Vector<uint32_t> *tasks() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_TASKS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_TASKS) &&
           verifier.VerifyVector(tasks()) &&
           verifier.EndTable();
  }
  AddToNNDMABacklogTaskT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AddToNNDMABacklogTaskT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AddToNNDMABacklogTask> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddToNNDMABacklogTaskT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AddToNNDMABacklogTaskBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(AddToNNDMABacklogTask::VT_ID, id, 0);
  }
  void add_tasks(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> tasks) {
    fbb_.AddOffset(AddToNNDMABacklogTask::VT_TASKS, tasks);
  }
  explicit AddToNNDMABacklogTaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddToNNDMABacklogTaskBuilder &operator=(const AddToNNDMABacklogTaskBuilder &);
  flatbuffers::Offset<AddToNNDMABacklogTask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddToNNDMABacklogTask>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddToNNDMABacklogTask> CreateAddToNNDMABacklogTask(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> tasks = 0) {
  AddToNNDMABacklogTaskBuilder builder_(_fbb);
  builder_.add_tasks(tasks);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<AddToNNDMABacklogTask> CreateAddToNNDMABacklogTaskDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    const std::vector<uint32_t> *tasks = nullptr) {
  auto tasks__ = tasks ? _fbb.CreateVector<uint32_t>(*tasks) : 0;
  return MVCNN::CreateAddToNNDMABacklogTask(
      _fbb,
      id,
      tasks__);
}

flatbuffers::Offset<AddToNNDMABacklogTask> CreateAddToNNDMABacklogTask(flatbuffers::FlatBufferBuilder &_fbb, const AddToNNDMABacklogTaskT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EmptyTaskT : public flatbuffers::NativeTable {
  typedef EmptyTask TableType;
  uint32_t id;
  EmptyTaskT()
      : id(0) {
  }
};

struct EmptyTask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EmptyTaskT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
  EmptyTaskT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EmptyTaskT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EmptyTask> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EmptyTaskT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EmptyTaskBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(EmptyTask::VT_ID, id, 0);
  }
  explicit EmptyTaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EmptyTaskBuilder &operator=(const EmptyTaskBuilder &);
  flatbuffers::Offset<EmptyTask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EmptyTask>(end);
    return o;
  }
};

inline flatbuffers::Offset<EmptyTask> CreateEmptyTask(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0) {
  EmptyTaskBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

flatbuffers::Offset<EmptyTask> CreateEmptyTask(flatbuffers::FlatBufferBuilder &_fbb, const EmptyTaskT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UPAStartSHVTaskT : public flatbuffers::NativeTable {
  typedef UPAStartSHVTask TableType;
  uint32_t id;
  UPAStartSHVTaskT()
      : id(0) {
  }
};

struct UPAStartSHVTask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UPAStartSHVTaskT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
  UPAStartSHVTaskT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UPAStartSHVTaskT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UPAStartSHVTask> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UPAStartSHVTaskT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UPAStartSHVTaskBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(UPAStartSHVTask::VT_ID, id, 0);
  }
  explicit UPAStartSHVTaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UPAStartSHVTaskBuilder &operator=(const UPAStartSHVTaskBuilder &);
  flatbuffers::Offset<UPAStartSHVTask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UPAStartSHVTask>(end);
    return o;
  }
};

inline flatbuffers::Offset<UPAStartSHVTask> CreateUPAStartSHVTask(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0) {
  UPAStartSHVTaskBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

flatbuffers::Offset<UPAStartSHVTask> CreateUPAStartSHVTask(flatbuffers::FlatBufferBuilder &_fbb, const UPAStartSHVTaskT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UPAEndSHVTaskT : public flatbuffers::NativeTable {
  typedef UPAEndSHVTask TableType;
  uint32_t id;
  UPAEndSHVTaskT()
      : id(0) {
  }
};

struct UPAEndSHVTask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UPAEndSHVTaskT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
  UPAEndSHVTaskT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UPAEndSHVTaskT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UPAEndSHVTask> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UPAEndSHVTaskT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UPAEndSHVTaskBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(UPAEndSHVTask::VT_ID, id, 0);
  }
  explicit UPAEndSHVTaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UPAEndSHVTaskBuilder &operator=(const UPAEndSHVTaskBuilder &);
  flatbuffers::Offset<UPAEndSHVTask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UPAEndSHVTask>(end);
    return o;
  }
};

inline flatbuffers::Offset<UPAEndSHVTask> CreateUPAEndSHVTask(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0) {
  UPAEndSHVTaskBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

flatbuffers::Offset<UPAEndSHVTask> CreateUPAEndSHVTask(flatbuffers::FlatBufferBuilder &_fbb, const UPAEndSHVTaskT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NNStartSHVTaskT : public flatbuffers::NativeTable {
  typedef NNStartSHVTask TableType;
  uint32_t id;
  NNStartSHVTaskT()
      : id(0) {
  }
};

struct NNStartSHVTask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NNStartSHVTaskT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
  NNStartSHVTaskT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NNStartSHVTaskT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NNStartSHVTask> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NNStartSHVTaskT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NNStartSHVTaskBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(NNStartSHVTask::VT_ID, id, 0);
  }
  explicit NNStartSHVTaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NNStartSHVTaskBuilder &operator=(const NNStartSHVTaskBuilder &);
  flatbuffers::Offset<NNStartSHVTask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NNStartSHVTask>(end);
    return o;
  }
};

inline flatbuffers::Offset<NNStartSHVTask> CreateNNStartSHVTask(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0) {
  NNStartSHVTaskBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

flatbuffers::Offset<NNStartSHVTask> CreateNNStartSHVTask(flatbuffers::FlatBufferBuilder &_fbb, const NNStartSHVTaskT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NNEndSHVTaskT : public flatbuffers::NativeTable {
  typedef NNEndSHVTask TableType;
  uint32_t id;
  NNEndSHVTaskT()
      : id(0) {
  }
};

struct NNEndSHVTask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NNEndSHVTaskT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
  NNEndSHVTaskT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NNEndSHVTaskT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NNEndSHVTask> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NNEndSHVTaskT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NNEndSHVTaskBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(NNEndSHVTask::VT_ID, id, 0);
  }
  explicit NNEndSHVTaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NNEndSHVTaskBuilder &operator=(const NNEndSHVTaskBuilder &);
  flatbuffers::Offset<NNEndSHVTask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NNEndSHVTask>(end);
    return o;
  }
};

inline flatbuffers::Offset<NNEndSHVTask> CreateNNEndSHVTask(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0) {
  NNEndSHVTaskBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

flatbuffers::Offset<NNEndSHVTask> CreateNNEndSHVTask(flatbuffers::FlatBufferBuilder &_fbb, const NNEndSHVTaskT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ControllerTaskT : public flatbuffers::NativeTable {
  typedef ControllerTask TableType;
  ControllerSubTaskUnion task;
  ControllerTaskT() {
  }
};

struct ControllerTask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ControllerTaskT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TASK_TYPE = 4,
    VT_TASK = 6
  };
  ControllerSubTask task_type() const {
    return static_cast<ControllerSubTask>(GetField<uint8_t>(VT_TASK_TYPE, 0));
  }
  const void *task() const {
    return GetPointer<const void *>(VT_TASK);
  }
  template<typename T> const T *task_as() const;
  const TimerTask *task_as_TimerTask() const {
    return task_type() == ControllerSubTask_TimerTask ? static_cast<const TimerTask *>(task()) : nullptr;
  }
  const BarrierConfigurationTask *task_as_BarrierConfigurationTask() const {
    return task_type() == ControllerSubTask_BarrierConfigurationTask ? static_cast<const BarrierConfigurationTask *>(task()) : nullptr;
  }
  const AddToNCE2CMXBacklogTask *task_as_AddToNCE2CMXBacklogTask() const {
    return task_type() == ControllerSubTask_AddToNCE2CMXBacklogTask ? static_cast<const AddToNCE2CMXBacklogTask *>(task()) : nullptr;
  }
  const AddToNNDMABacklogTask *task_as_AddToNNDMABacklogTask() const {
    return task_type() == ControllerSubTask_AddToNNDMABacklogTask ? static_cast<const AddToNNDMABacklogTask *>(task()) : nullptr;
  }
  const UPAStartSHVTask *task_as_UPAStartSHVTask() const {
    return task_type() == ControllerSubTask_UPAStartSHVTask ? static_cast<const UPAStartSHVTask *>(task()) : nullptr;
  }
  const UPAEndSHVTask *task_as_UPAEndSHVTask() const {
    return task_type() == ControllerSubTask_UPAEndSHVTask ? static_cast<const UPAEndSHVTask *>(task()) : nullptr;
  }
  const NNStartSHVTask *task_as_NNStartSHVTask() const {
    return task_type() == ControllerSubTask_NNStartSHVTask ? static_cast<const NNStartSHVTask *>(task()) : nullptr;
  }
  const NNEndSHVTask *task_as_NNEndSHVTask() const {
    return task_type() == ControllerSubTask_NNEndSHVTask ? static_cast<const NNEndSHVTask *>(task()) : nullptr;
  }
  const EmptyTask *task_as_EmptyTask() const {
    return task_type() == ControllerSubTask_EmptyTask ? static_cast<const EmptyTask *>(task()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TASK_TYPE) &&
           VerifyOffset(verifier, VT_TASK) &&
           VerifyControllerSubTask(verifier, task(), task_type()) &&
           verifier.EndTable();
  }
  ControllerTaskT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ControllerTaskT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ControllerTask> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ControllerTaskT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const TimerTask *ControllerTask::task_as<TimerTask>() const {
  return task_as_TimerTask();
}

template<> inline const BarrierConfigurationTask *ControllerTask::task_as<BarrierConfigurationTask>() const {
  return task_as_BarrierConfigurationTask();
}

template<> inline const AddToNCE2CMXBacklogTask *ControllerTask::task_as<AddToNCE2CMXBacklogTask>() const {
  return task_as_AddToNCE2CMXBacklogTask();
}

template<> inline const AddToNNDMABacklogTask *ControllerTask::task_as<AddToNNDMABacklogTask>() const {
  return task_as_AddToNNDMABacklogTask();
}

template<> inline const UPAStartSHVTask *ControllerTask::task_as<UPAStartSHVTask>() const {
  return task_as_UPAStartSHVTask();
}

template<> inline const UPAEndSHVTask *ControllerTask::task_as<UPAEndSHVTask>() const {
  return task_as_UPAEndSHVTask();
}

template<> inline const NNStartSHVTask *ControllerTask::task_as<NNStartSHVTask>() const {
  return task_as_NNStartSHVTask();
}

template<> inline const NNEndSHVTask *ControllerTask::task_as<NNEndSHVTask>() const {
  return task_as_NNEndSHVTask();
}

template<> inline const EmptyTask *ControllerTask::task_as<EmptyTask>() const {
  return task_as_EmptyTask();
}

struct ControllerTaskBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_task_type(ControllerSubTask task_type) {
    fbb_.AddElement<uint8_t>(ControllerTask::VT_TASK_TYPE, static_cast<uint8_t>(task_type), 0);
  }
  void add_task(flatbuffers::Offset<void> task) {
    fbb_.AddOffset(ControllerTask::VT_TASK, task);
  }
  explicit ControllerTaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ControllerTaskBuilder &operator=(const ControllerTaskBuilder &);
  flatbuffers::Offset<ControllerTask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ControllerTask>(end);
    return o;
  }
};

inline flatbuffers::Offset<ControllerTask> CreateControllerTask(
    flatbuffers::FlatBufferBuilder &_fbb,
    ControllerSubTask task_type = ControllerSubTask_NONE,
    flatbuffers::Offset<void> task = 0) {
  ControllerTaskBuilder builder_(_fbb);
  builder_.add_task(task);
  builder_.add_task_type(task_type);
  return builder_.Finish();
}

flatbuffers::Offset<ControllerTask> CreateControllerTask(flatbuffers::FlatBufferBuilder &_fbb, const ControllerTaskT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline TimerTaskT *TimerTask::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TimerTaskT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TimerTask::UnPackTo(TimerTaskT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; };
  { auto _e = write_location(); if (_e) _o->write_location = std::unique_ptr<TensorReferenceT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<TimerTask> TimerTask::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TimerTaskT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTimerTask(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TimerTask> CreateTimerTask(flatbuffers::FlatBufferBuilder &_fbb, const TimerTaskT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TimerTaskT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _write_location = _o->write_location ? CreateTensorReference(_fbb, _o->write_location.get(), _rehasher) : 0;
  return MVCNN::CreateTimerTask(
      _fbb,
      _id,
      _write_location);
}

inline BarrierConfigurationTaskT *BarrierConfigurationTask::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BarrierConfigurationTaskT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BarrierConfigurationTask::UnPackTo(BarrierConfigurationTaskT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = target(); if (_e) _o->target = std::unique_ptr<BarrierT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<BarrierConfigurationTask> BarrierConfigurationTask::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BarrierConfigurationTaskT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBarrierConfigurationTask(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BarrierConfigurationTask> CreateBarrierConfigurationTask(flatbuffers::FlatBufferBuilder &_fbb, const BarrierConfigurationTaskT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BarrierConfigurationTaskT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _target = _o->target ? CreateBarrier(_fbb, _o->target.get(), _rehasher) : 0;
  return MVCNN::CreateBarrierConfigurationTask(
      _fbb,
      _target);
}

inline AddToNCE2CMXBacklogTaskT *AddToNCE2CMXBacklogTask::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AddToNCE2CMXBacklogTaskT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AddToNCE2CMXBacklogTask::UnPackTo(AddToNCE2CMXBacklogTaskT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; };
  { auto _e = tasks(); if (_e) { _o->tasks.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tasks[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<AddToNCE2CMXBacklogTask> AddToNCE2CMXBacklogTask::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddToNCE2CMXBacklogTaskT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAddToNCE2CMXBacklogTask(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AddToNCE2CMXBacklogTask> CreateAddToNCE2CMXBacklogTask(flatbuffers::FlatBufferBuilder &_fbb, const AddToNCE2CMXBacklogTaskT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AddToNCE2CMXBacklogTaskT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _tasks = _fbb.CreateVector(_o->tasks);
  return MVCNN::CreateAddToNCE2CMXBacklogTask(
      _fbb,
      _id,
      _tasks);
}

inline AddToNNDMABacklogTaskT *AddToNNDMABacklogTask::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AddToNNDMABacklogTaskT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AddToNNDMABacklogTask::UnPackTo(AddToNNDMABacklogTaskT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; };
  { auto _e = tasks(); if (_e) { _o->tasks.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tasks[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<AddToNNDMABacklogTask> AddToNNDMABacklogTask::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddToNNDMABacklogTaskT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAddToNNDMABacklogTask(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AddToNNDMABacklogTask> CreateAddToNNDMABacklogTask(flatbuffers::FlatBufferBuilder &_fbb, const AddToNNDMABacklogTaskT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AddToNNDMABacklogTaskT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _tasks = _fbb.CreateVector(_o->tasks);
  return MVCNN::CreateAddToNNDMABacklogTask(
      _fbb,
      _id,
      _tasks);
}

inline EmptyTaskT *EmptyTask::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new EmptyTaskT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void EmptyTask::UnPackTo(EmptyTaskT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; };
}

inline flatbuffers::Offset<EmptyTask> EmptyTask::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EmptyTaskT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEmptyTask(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EmptyTask> CreateEmptyTask(flatbuffers::FlatBufferBuilder &_fbb, const EmptyTaskT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EmptyTaskT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  return MVCNN::CreateEmptyTask(
      _fbb,
      _id);
}

inline UPAStartSHVTaskT *UPAStartSHVTask::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UPAStartSHVTaskT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void UPAStartSHVTask::UnPackTo(UPAStartSHVTaskT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; };
}

inline flatbuffers::Offset<UPAStartSHVTask> UPAStartSHVTask::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UPAStartSHVTaskT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUPAStartSHVTask(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UPAStartSHVTask> CreateUPAStartSHVTask(flatbuffers::FlatBufferBuilder &_fbb, const UPAStartSHVTaskT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UPAStartSHVTaskT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  return MVCNN::CreateUPAStartSHVTask(
      _fbb,
      _id);
}

inline UPAEndSHVTaskT *UPAEndSHVTask::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UPAEndSHVTaskT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void UPAEndSHVTask::UnPackTo(UPAEndSHVTaskT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; };
}

inline flatbuffers::Offset<UPAEndSHVTask> UPAEndSHVTask::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UPAEndSHVTaskT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUPAEndSHVTask(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UPAEndSHVTask> CreateUPAEndSHVTask(flatbuffers::FlatBufferBuilder &_fbb, const UPAEndSHVTaskT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UPAEndSHVTaskT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  return MVCNN::CreateUPAEndSHVTask(
      _fbb,
      _id);
}

inline NNStartSHVTaskT *NNStartSHVTask::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NNStartSHVTaskT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void NNStartSHVTask::UnPackTo(NNStartSHVTaskT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; };
}

inline flatbuffers::Offset<NNStartSHVTask> NNStartSHVTask::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NNStartSHVTaskT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNNStartSHVTask(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NNStartSHVTask> CreateNNStartSHVTask(flatbuffers::FlatBufferBuilder &_fbb, const NNStartSHVTaskT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NNStartSHVTaskT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  return MVCNN::CreateNNStartSHVTask(
      _fbb,
      _id);
}

inline NNEndSHVTaskT *NNEndSHVTask::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NNEndSHVTaskT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void NNEndSHVTask::UnPackTo(NNEndSHVTaskT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; };
}

inline flatbuffers::Offset<NNEndSHVTask> NNEndSHVTask::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NNEndSHVTaskT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNNEndSHVTask(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NNEndSHVTask> CreateNNEndSHVTask(flatbuffers::FlatBufferBuilder &_fbb, const NNEndSHVTaskT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NNEndSHVTaskT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  return MVCNN::CreateNNEndSHVTask(
      _fbb,
      _id);
}

inline ControllerTaskT *ControllerTask::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ControllerTaskT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ControllerTask::UnPackTo(ControllerTaskT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = task_type(); _o->task.type = _e; };
  { auto _e = task(); if (_e) _o->task.value = ControllerSubTaskUnion::UnPack(_e, task_type(), _resolver); };
}

inline flatbuffers::Offset<ControllerTask> ControllerTask::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ControllerTaskT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateControllerTask(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ControllerTask> CreateControllerTask(flatbuffers::FlatBufferBuilder &_fbb, const ControllerTaskT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ControllerTaskT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _task_type = _o->task.type;
  auto _task = _o->task.Pack(_fbb);
  return MVCNN::CreateControllerTask(
      _fbb,
      _task_type,
      _task);
}

inline bool VerifyControllerSubTask(flatbuffers::Verifier &verifier, const void *obj, ControllerSubTask type) {
  switch (type) {
    case ControllerSubTask_NONE: {
      return true;
    }
    case ControllerSubTask_TimerTask: {
      auto ptr = reinterpret_cast<const TimerTask *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ControllerSubTask_BarrierConfigurationTask: {
      auto ptr = reinterpret_cast<const BarrierConfigurationTask *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ControllerSubTask_AddToNCE2CMXBacklogTask: {
      auto ptr = reinterpret_cast<const AddToNCE2CMXBacklogTask *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ControllerSubTask_AddToNNDMABacklogTask: {
      auto ptr = reinterpret_cast<const AddToNNDMABacklogTask *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ControllerSubTask_UPAStartSHVTask: {
      auto ptr = reinterpret_cast<const UPAStartSHVTask *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ControllerSubTask_UPAEndSHVTask: {
      auto ptr = reinterpret_cast<const UPAEndSHVTask *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ControllerSubTask_NNStartSHVTask: {
      auto ptr = reinterpret_cast<const NNStartSHVTask *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ControllerSubTask_NNEndSHVTask: {
      auto ptr = reinterpret_cast<const NNEndSHVTask *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ControllerSubTask_EmptyTask: {
      auto ptr = reinterpret_cast<const EmptyTask *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyControllerSubTaskVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyControllerSubTask(
        verifier,  values->Get(i), types->GetEnum<ControllerSubTask>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ControllerSubTaskUnion::UnPack(const void *obj, ControllerSubTask type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case ControllerSubTask_TimerTask: {
      auto ptr = reinterpret_cast<const TimerTask *>(obj);
      return ptr->UnPack(resolver);
    }
    case ControllerSubTask_BarrierConfigurationTask: {
      auto ptr = reinterpret_cast<const BarrierConfigurationTask *>(obj);
      return ptr->UnPack(resolver);
    }
    case ControllerSubTask_AddToNCE2CMXBacklogTask: {
      auto ptr = reinterpret_cast<const AddToNCE2CMXBacklogTask *>(obj);
      return ptr->UnPack(resolver);
    }
    case ControllerSubTask_AddToNNDMABacklogTask: {
      auto ptr = reinterpret_cast<const AddToNNDMABacklogTask *>(obj);
      return ptr->UnPack(resolver);
    }
    case ControllerSubTask_UPAStartSHVTask: {
      auto ptr = reinterpret_cast<const UPAStartSHVTask *>(obj);
      return ptr->UnPack(resolver);
    }
    case ControllerSubTask_UPAEndSHVTask: {
      auto ptr = reinterpret_cast<const UPAEndSHVTask *>(obj);
      return ptr->UnPack(resolver);
    }
    case ControllerSubTask_NNStartSHVTask: {
      auto ptr = reinterpret_cast<const NNStartSHVTask *>(obj);
      return ptr->UnPack(resolver);
    }
    case ControllerSubTask_NNEndSHVTask: {
      auto ptr = reinterpret_cast<const NNEndSHVTask *>(obj);
      return ptr->UnPack(resolver);
    }
    case ControllerSubTask_EmptyTask: {
      auto ptr = reinterpret_cast<const EmptyTask *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> ControllerSubTaskUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case ControllerSubTask_TimerTask: {
      auto ptr = reinterpret_cast<const TimerTaskT *>(value);
      return CreateTimerTask(_fbb, ptr, _rehasher).Union();
    }
    case ControllerSubTask_BarrierConfigurationTask: {
      auto ptr = reinterpret_cast<const BarrierConfigurationTaskT *>(value);
      return CreateBarrierConfigurationTask(_fbb, ptr, _rehasher).Union();
    }
    case ControllerSubTask_AddToNCE2CMXBacklogTask: {
      auto ptr = reinterpret_cast<const AddToNCE2CMXBacklogTaskT *>(value);
      return CreateAddToNCE2CMXBacklogTask(_fbb, ptr, _rehasher).Union();
    }
    case ControllerSubTask_AddToNNDMABacklogTask: {
      auto ptr = reinterpret_cast<const AddToNNDMABacklogTaskT *>(value);
      return CreateAddToNNDMABacklogTask(_fbb, ptr, _rehasher).Union();
    }
    case ControllerSubTask_UPAStartSHVTask: {
      auto ptr = reinterpret_cast<const UPAStartSHVTaskT *>(value);
      return CreateUPAStartSHVTask(_fbb, ptr, _rehasher).Union();
    }
    case ControllerSubTask_UPAEndSHVTask: {
      auto ptr = reinterpret_cast<const UPAEndSHVTaskT *>(value);
      return CreateUPAEndSHVTask(_fbb, ptr, _rehasher).Union();
    }
    case ControllerSubTask_NNStartSHVTask: {
      auto ptr = reinterpret_cast<const NNStartSHVTaskT *>(value);
      return CreateNNStartSHVTask(_fbb, ptr, _rehasher).Union();
    }
    case ControllerSubTask_NNEndSHVTask: {
      auto ptr = reinterpret_cast<const NNEndSHVTaskT *>(value);
      return CreateNNEndSHVTask(_fbb, ptr, _rehasher).Union();
    }
    case ControllerSubTask_EmptyTask: {
      auto ptr = reinterpret_cast<const EmptyTaskT *>(value);
      return CreateEmptyTask(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ControllerSubTaskUnion::ControllerSubTaskUnion(const ControllerSubTaskUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case ControllerSubTask_TimerTask: {
      FLATBUFFERS_ASSERT(false);  // TimerTaskT not copyable.
      break;
    }
    case ControllerSubTask_BarrierConfigurationTask: {
      FLATBUFFERS_ASSERT(false);  // BarrierConfigurationTaskT not copyable.
      break;
    }
    case ControllerSubTask_AddToNCE2CMXBacklogTask: {
      value = new AddToNCE2CMXBacklogTaskT(*reinterpret_cast<AddToNCE2CMXBacklogTaskT *>(u.value));
      break;
    }
    case ControllerSubTask_AddToNNDMABacklogTask: {
      value = new AddToNNDMABacklogTaskT(*reinterpret_cast<AddToNNDMABacklogTaskT *>(u.value));
      break;
    }
    case ControllerSubTask_UPAStartSHVTask: {
      value = new UPAStartSHVTaskT(*reinterpret_cast<UPAStartSHVTaskT *>(u.value));
      break;
    }
    case ControllerSubTask_UPAEndSHVTask: {
      value = new UPAEndSHVTaskT(*reinterpret_cast<UPAEndSHVTaskT *>(u.value));
      break;
    }
    case ControllerSubTask_NNStartSHVTask: {
      value = new NNStartSHVTaskT(*reinterpret_cast<NNStartSHVTaskT *>(u.value));
      break;
    }
    case ControllerSubTask_NNEndSHVTask: {
      value = new NNEndSHVTaskT(*reinterpret_cast<NNEndSHVTaskT *>(u.value));
      break;
    }
    case ControllerSubTask_EmptyTask: {
      value = new EmptyTaskT(*reinterpret_cast<EmptyTaskT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void ControllerSubTaskUnion::Reset() {
  switch (type) {
    case ControllerSubTask_TimerTask: {
      auto ptr = reinterpret_cast<TimerTaskT *>(value);
      delete ptr;
      break;
    }
    case ControllerSubTask_BarrierConfigurationTask: {
      auto ptr = reinterpret_cast<BarrierConfigurationTaskT *>(value);
      delete ptr;
      break;
    }
    case ControllerSubTask_AddToNCE2CMXBacklogTask: {
      auto ptr = reinterpret_cast<AddToNCE2CMXBacklogTaskT *>(value);
      delete ptr;
      break;
    }
    case ControllerSubTask_AddToNNDMABacklogTask: {
      auto ptr = reinterpret_cast<AddToNNDMABacklogTaskT *>(value);
      delete ptr;
      break;
    }
    case ControllerSubTask_UPAStartSHVTask: {
      auto ptr = reinterpret_cast<UPAStartSHVTaskT *>(value);
      delete ptr;
      break;
    }
    case ControllerSubTask_UPAEndSHVTask: {
      auto ptr = reinterpret_cast<UPAEndSHVTaskT *>(value);
      delete ptr;
      break;
    }
    case ControllerSubTask_NNStartSHVTask: {
      auto ptr = reinterpret_cast<NNStartSHVTaskT *>(value);
      delete ptr;
      break;
    }
    case ControllerSubTask_NNEndSHVTask: {
      auto ptr = reinterpret_cast<NNEndSHVTaskT *>(value);
      delete ptr;
      break;
    }
    case ControllerSubTask_EmptyTask: {
      auto ptr = reinterpret_cast<EmptyTaskT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = ControllerSubTask_NONE;
}

}  // namespace MVCNN

#endif  // FLATBUFFERS_GENERATED_NNCONTROLLER_MVCNN_H_
