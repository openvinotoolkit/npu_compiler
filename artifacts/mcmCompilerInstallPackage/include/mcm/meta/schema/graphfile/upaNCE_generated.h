// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_UPANCE_MVCNN_H_
#define FLATBUFFERS_GENERATED_UPANCE_MVCNN_H_

#include "flatbuffers/flatbuffers.h"

#include "dma_generated.h"
#include "memoryManagement_generated.h"
#include "software_generated.h"

namespace MVCNN {

struct NCE1Task;
struct NCE1TaskT;

struct NCE1Conv;
struct NCE1ConvT;

struct NCE1Pool;
struct NCE1PoolT;

struct NCE1FCL;
struct NCE1FCLT;

/// Note: This file is not well-defined.
/// Generally modelled around v2 infrastructure for software layers.
enum NCE1Layer {
  NCE1Layer_NONE = 0,
  NCE1Layer_NCE1Conv = 1,
  NCE1Layer_NCE1Pool = 2,
  NCE1Layer_NCE1FCL = 3,
  NCE1Layer_MIN = NCE1Layer_NONE,
  NCE1Layer_MAX = NCE1Layer_NCE1FCL
};

inline const NCE1Layer (&EnumValuesNCE1Layer())[4] {
  static const NCE1Layer values[] = {
    NCE1Layer_NONE,
    NCE1Layer_NCE1Conv,
    NCE1Layer_NCE1Pool,
    NCE1Layer_NCE1FCL
  };
  return values;
}

inline const char * const *EnumNamesNCE1Layer() {
  static const char * const names[] = {
    "NONE",
    "NCE1Conv",
    "NCE1Pool",
    "NCE1FCL",
    nullptr
  };
  return names;
}

inline const char *EnumNameNCE1Layer(NCE1Layer e) {
  if (e < NCE1Layer_NONE || e > NCE1Layer_NCE1FCL) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNCE1Layer()[index];
}

template<typename T> struct NCE1LayerTraits {
  static const NCE1Layer enum_value = NCE1Layer_NONE;
};

template<> struct NCE1LayerTraits<NCE1Conv> {
  static const NCE1Layer enum_value = NCE1Layer_NCE1Conv;
};

template<> struct NCE1LayerTraits<NCE1Pool> {
  static const NCE1Layer enum_value = NCE1Layer_NCE1Pool;
};

template<> struct NCE1LayerTraits<NCE1FCL> {
  static const NCE1Layer enum_value = NCE1Layer_NCE1FCL;
};

struct NCE1LayerUnion {
  NCE1Layer type;
  void *value;

  NCE1LayerUnion() : type(NCE1Layer_NONE), value(nullptr) {}
  NCE1LayerUnion(NCE1LayerUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(NCE1Layer_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  NCE1LayerUnion(const NCE1LayerUnion &) FLATBUFFERS_NOEXCEPT;
  NCE1LayerUnion &operator=(const NCE1LayerUnion &u) FLATBUFFERS_NOEXCEPT
    { NCE1LayerUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  NCE1LayerUnion &operator=(NCE1LayerUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~NCE1LayerUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = NCE1LayerTraits<typename RT::TableType>::enum_value;
    if (type != NCE1Layer_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, NCE1Layer type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  NCE1ConvT *AsNCE1Conv() {
    return type == NCE1Layer_NCE1Conv ?
      reinterpret_cast<NCE1ConvT *>(value) : nullptr;
  }
  const NCE1ConvT *AsNCE1Conv() const {
    return type == NCE1Layer_NCE1Conv ?
      reinterpret_cast<const NCE1ConvT *>(value) : nullptr;
  }
  NCE1PoolT *AsNCE1Pool() {
    return type == NCE1Layer_NCE1Pool ?
      reinterpret_cast<NCE1PoolT *>(value) : nullptr;
  }
  const NCE1PoolT *AsNCE1Pool() const {
    return type == NCE1Layer_NCE1Pool ?
      reinterpret_cast<const NCE1PoolT *>(value) : nullptr;
  }
  NCE1FCLT *AsNCE1FCL() {
    return type == NCE1Layer_NCE1FCL ?
      reinterpret_cast<NCE1FCLT *>(value) : nullptr;
  }
  const NCE1FCLT *AsNCE1FCL() const {
    return type == NCE1Layer_NCE1FCL ?
      reinterpret_cast<const NCE1FCLT *>(value) : nullptr;
  }
};

bool VerifyNCE1Layer(flatbuffers::Verifier &verifier, const void *obj, NCE1Layer type);
bool VerifyNCE1LayerVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct NCE1TaskT : public flatbuffers::NativeTable {
  typedef NCE1Task TableType;
  NCE1LayerUnion layer;
  NCE1TaskT() {
  }
};

struct NCE1Task FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NCE1TaskT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LAYER_TYPE = 4,
    VT_LAYER = 6
  };
  NCE1Layer layer_type() const {
    return static_cast<NCE1Layer>(GetField<uint8_t>(VT_LAYER_TYPE, 0));
  }
  const void *layer() const {
    return GetPointer<const void *>(VT_LAYER);
  }
  template<typename T> const T *layer_as() const;
  const NCE1Conv *layer_as_NCE1Conv() const {
    return layer_type() == NCE1Layer_NCE1Conv ? static_cast<const NCE1Conv *>(layer()) : nullptr;
  }
  const NCE1Pool *layer_as_NCE1Pool() const {
    return layer_type() == NCE1Layer_NCE1Pool ? static_cast<const NCE1Pool *>(layer()) : nullptr;
  }
  const NCE1FCL *layer_as_NCE1FCL() const {
    return layer_type() == NCE1Layer_NCE1FCL ? static_cast<const NCE1FCL *>(layer()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_LAYER_TYPE) &&
           VerifyOffset(verifier, VT_LAYER) &&
           VerifyNCE1Layer(verifier, layer(), layer_type()) &&
           verifier.EndTable();
  }
  NCE1TaskT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NCE1TaskT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NCE1Task> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NCE1TaskT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const NCE1Conv *NCE1Task::layer_as<NCE1Conv>() const {
  return layer_as_NCE1Conv();
}

template<> inline const NCE1Pool *NCE1Task::layer_as<NCE1Pool>() const {
  return layer_as_NCE1Pool();
}

template<> inline const NCE1FCL *NCE1Task::layer_as<NCE1FCL>() const {
  return layer_as_NCE1FCL();
}

struct NCE1TaskBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_layer_type(NCE1Layer layer_type) {
    fbb_.AddElement<uint8_t>(NCE1Task::VT_LAYER_TYPE, static_cast<uint8_t>(layer_type), 0);
  }
  void add_layer(flatbuffers::Offset<void> layer) {
    fbb_.AddOffset(NCE1Task::VT_LAYER, layer);
  }
  explicit NCE1TaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NCE1TaskBuilder &operator=(const NCE1TaskBuilder &);
  flatbuffers::Offset<NCE1Task> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NCE1Task>(end);
    return o;
  }
};

inline flatbuffers::Offset<NCE1Task> CreateNCE1Task(
    flatbuffers::FlatBufferBuilder &_fbb,
    NCE1Layer layer_type = NCE1Layer_NONE,
    flatbuffers::Offset<void> layer = 0) {
  NCE1TaskBuilder builder_(_fbb);
  builder_.add_layer(layer);
  builder_.add_layer_type(layer_type);
  return builder_.Finish();
}

flatbuffers::Offset<NCE1Task> CreateNCE1Task(flatbuffers::FlatBufferBuilder &_fbb, const NCE1TaskT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NCE1ConvT : public flatbuffers::NativeTable {
  typedef NCE1Conv TableType;
  uint32_t streamingMask;
  uint32_t inputSize;
  uint32_t outputSize;
  uint32_t concatOffset;
  uint32_t unloadCMX;
  uint32_t overwriteInput;
  uint32_t CMXSize;
  uint32_t reluSHVAcc;
  uint32_t shvNegSlope;
  uint32_t shvPosSlope;
  uint32_t desc_count;
  std::vector<int8_t> descriptors;
  std::unique_ptr<TensorT> input;
  std::unique_ptr<TensorT> output;
  std::unique_ptr<TensorT> weight;
  std::unique_ptr<TensorT> bias;
  NCE1ConvT()
      : streamingMask(0),
        inputSize(0),
        outputSize(0),
        concatOffset(0),
        unloadCMX(0),
        overwriteInput(0),
        CMXSize(0),
        reluSHVAcc(0),
        shvNegSlope(0),
        shvPosSlope(0),
        desc_count(0) {
  }
};

struct NCE1Conv FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NCE1ConvT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAMINGMASK = 4,
    VT_INPUTSIZE = 6,
    VT_OUTPUTSIZE = 8,
    VT_CONCATOFFSET = 10,
    VT_UNLOADCMX = 12,
    VT_OVERWRITEINPUT = 14,
    VT_CMXSIZE = 16,
    VT_RELUSHVACC = 18,
    VT_SHVNEGSLOPE = 20,
    VT_SHVPOSSLOPE = 22,
    VT_DESC_COUNT = 24,
    VT_DESCRIPTORS = 26,
    VT_INPUT = 28,
    VT_OUTPUT = 30,
    VT_WEIGHT = 32,
    VT_BIAS = 34
  };
  uint32_t streamingMask() const {
    return GetField<uint32_t>(VT_STREAMINGMASK, 0);
  }
  uint32_t inputSize() const {
    return GetField<uint32_t>(VT_INPUTSIZE, 0);
  }
  uint32_t outputSize() const {
    return GetField<uint32_t>(VT_OUTPUTSIZE, 0);
  }
  uint32_t concatOffset() const {
    return GetField<uint32_t>(VT_CONCATOFFSET, 0);
  }
  uint32_t unloadCMX() const {
    return GetField<uint32_t>(VT_UNLOADCMX, 0);
  }
  uint32_t overwriteInput() const {
    return GetField<uint32_t>(VT_OVERWRITEINPUT, 0);
  }
  uint32_t CMXSize() const {
    return GetField<uint32_t>(VT_CMXSIZE, 0);
  }
  uint32_t reluSHVAcc() const {
    return GetField<uint32_t>(VT_RELUSHVACC, 0);
  }
  uint32_t shvNegSlope() const {
    return GetField<uint32_t>(VT_SHVNEGSLOPE, 0);
  }
  uint32_t shvPosSlope() const {
    return GetField<uint32_t>(VT_SHVPOSSLOPE, 0);
  }
  uint32_t desc_count() const {
    return GetField<uint32_t>(VT_DESC_COUNT, 0);
  }
  const flatbuffers::Vector<int8_t> *descriptors() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_DESCRIPTORS);
  }
  const Tensor *input() const {
    return GetPointer<const Tensor *>(VT_INPUT);
  }
  const Tensor *output() const {
    return GetPointer<const Tensor *>(VT_OUTPUT);
  }
  const Tensor *weight() const {
    return GetPointer<const Tensor *>(VT_WEIGHT);
  }
  const Tensor *bias() const {
    return GetPointer<const Tensor *>(VT_BIAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_STREAMINGMASK) &&
           VerifyField<uint32_t>(verifier, VT_INPUTSIZE) &&
           VerifyField<uint32_t>(verifier, VT_OUTPUTSIZE) &&
           VerifyField<uint32_t>(verifier, VT_CONCATOFFSET) &&
           VerifyField<uint32_t>(verifier, VT_UNLOADCMX) &&
           VerifyField<uint32_t>(verifier, VT_OVERWRITEINPUT) &&
           VerifyField<uint32_t>(verifier, VT_CMXSIZE) &&
           VerifyField<uint32_t>(verifier, VT_RELUSHVACC) &&
           VerifyField<uint32_t>(verifier, VT_SHVNEGSLOPE) &&
           VerifyField<uint32_t>(verifier, VT_SHVPOSSLOPE) &&
           VerifyField<uint32_t>(verifier, VT_DESC_COUNT) &&
           VerifyOffset(verifier, VT_DESCRIPTORS) &&
           verifier.VerifyVector(descriptors()) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyTable(input()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyTable(output()) &&
           VerifyOffset(verifier, VT_WEIGHT) &&
           verifier.VerifyTable(weight()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyTable(bias()) &&
           verifier.EndTable();
  }
  NCE1ConvT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NCE1ConvT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NCE1Conv> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NCE1ConvT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NCE1ConvBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_streamingMask(uint32_t streamingMask) {
    fbb_.AddElement<uint32_t>(NCE1Conv::VT_STREAMINGMASK, streamingMask, 0);
  }
  void add_inputSize(uint32_t inputSize) {
    fbb_.AddElement<uint32_t>(NCE1Conv::VT_INPUTSIZE, inputSize, 0);
  }
  void add_outputSize(uint32_t outputSize) {
    fbb_.AddElement<uint32_t>(NCE1Conv::VT_OUTPUTSIZE, outputSize, 0);
  }
  void add_concatOffset(uint32_t concatOffset) {
    fbb_.AddElement<uint32_t>(NCE1Conv::VT_CONCATOFFSET, concatOffset, 0);
  }
  void add_unloadCMX(uint32_t unloadCMX) {
    fbb_.AddElement<uint32_t>(NCE1Conv::VT_UNLOADCMX, unloadCMX, 0);
  }
  void add_overwriteInput(uint32_t overwriteInput) {
    fbb_.AddElement<uint32_t>(NCE1Conv::VT_OVERWRITEINPUT, overwriteInput, 0);
  }
  void add_CMXSize(uint32_t CMXSize) {
    fbb_.AddElement<uint32_t>(NCE1Conv::VT_CMXSIZE, CMXSize, 0);
  }
  void add_reluSHVAcc(uint32_t reluSHVAcc) {
    fbb_.AddElement<uint32_t>(NCE1Conv::VT_RELUSHVACC, reluSHVAcc, 0);
  }
  void add_shvNegSlope(uint32_t shvNegSlope) {
    fbb_.AddElement<uint32_t>(NCE1Conv::VT_SHVNEGSLOPE, shvNegSlope, 0);
  }
  void add_shvPosSlope(uint32_t shvPosSlope) {
    fbb_.AddElement<uint32_t>(NCE1Conv::VT_SHVPOSSLOPE, shvPosSlope, 0);
  }
  void add_desc_count(uint32_t desc_count) {
    fbb_.AddElement<uint32_t>(NCE1Conv::VT_DESC_COUNT, desc_count, 0);
  }
  void add_descriptors(flatbuffers::Offset<flatbuffers::Vector<int8_t>> descriptors) {
    fbb_.AddOffset(NCE1Conv::VT_DESCRIPTORS, descriptors);
  }
  void add_input(flatbuffers::Offset<Tensor> input) {
    fbb_.AddOffset(NCE1Conv::VT_INPUT, input);
  }
  void add_output(flatbuffers::Offset<Tensor> output) {
    fbb_.AddOffset(NCE1Conv::VT_OUTPUT, output);
  }
  void add_weight(flatbuffers::Offset<Tensor> weight) {
    fbb_.AddOffset(NCE1Conv::VT_WEIGHT, weight);
  }
  void add_bias(flatbuffers::Offset<Tensor> bias) {
    fbb_.AddOffset(NCE1Conv::VT_BIAS, bias);
  }
  explicit NCE1ConvBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NCE1ConvBuilder &operator=(const NCE1ConvBuilder &);
  flatbuffers::Offset<NCE1Conv> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NCE1Conv>(end);
    return o;
  }
};

inline flatbuffers::Offset<NCE1Conv> CreateNCE1Conv(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t streamingMask = 0,
    uint32_t inputSize = 0,
    uint32_t outputSize = 0,
    uint32_t concatOffset = 0,
    uint32_t unloadCMX = 0,
    uint32_t overwriteInput = 0,
    uint32_t CMXSize = 0,
    uint32_t reluSHVAcc = 0,
    uint32_t shvNegSlope = 0,
    uint32_t shvPosSlope = 0,
    uint32_t desc_count = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> descriptors = 0,
    flatbuffers::Offset<Tensor> input = 0,
    flatbuffers::Offset<Tensor> output = 0,
    flatbuffers::Offset<Tensor> weight = 0,
    flatbuffers::Offset<Tensor> bias = 0) {
  NCE1ConvBuilder builder_(_fbb);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_output(output);
  builder_.add_input(input);
  builder_.add_descriptors(descriptors);
  builder_.add_desc_count(desc_count);
  builder_.add_shvPosSlope(shvPosSlope);
  builder_.add_shvNegSlope(shvNegSlope);
  builder_.add_reluSHVAcc(reluSHVAcc);
  builder_.add_CMXSize(CMXSize);
  builder_.add_overwriteInput(overwriteInput);
  builder_.add_unloadCMX(unloadCMX);
  builder_.add_concatOffset(concatOffset);
  builder_.add_outputSize(outputSize);
  builder_.add_inputSize(inputSize);
  builder_.add_streamingMask(streamingMask);
  return builder_.Finish();
}

inline flatbuffers::Offset<NCE1Conv> CreateNCE1ConvDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t streamingMask = 0,
    uint32_t inputSize = 0,
    uint32_t outputSize = 0,
    uint32_t concatOffset = 0,
    uint32_t unloadCMX = 0,
    uint32_t overwriteInput = 0,
    uint32_t CMXSize = 0,
    uint32_t reluSHVAcc = 0,
    uint32_t shvNegSlope = 0,
    uint32_t shvPosSlope = 0,
    uint32_t desc_count = 0,
    const std::vector<int8_t> *descriptors = nullptr,
    flatbuffers::Offset<Tensor> input = 0,
    flatbuffers::Offset<Tensor> output = 0,
    flatbuffers::Offset<Tensor> weight = 0,
    flatbuffers::Offset<Tensor> bias = 0) {
  auto descriptors__ = descriptors ? _fbb.CreateVector<int8_t>(*descriptors) : 0;
  return MVCNN::CreateNCE1Conv(
      _fbb,
      streamingMask,
      inputSize,
      outputSize,
      concatOffset,
      unloadCMX,
      overwriteInput,
      CMXSize,
      reluSHVAcc,
      shvNegSlope,
      shvPosSlope,
      desc_count,
      descriptors__,
      input,
      output,
      weight,
      bias);
}

flatbuffers::Offset<NCE1Conv> CreateNCE1Conv(flatbuffers::FlatBufferBuilder &_fbb, const NCE1ConvT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NCE1PoolT : public flatbuffers::NativeTable {
  typedef NCE1Pool TableType;
  uint32_t streamingMask;
  uint32_t inputSize;
  uint32_t outputSize;
  uint32_t concatOffset;
  uint32_t unloadCMX;
  uint32_t overwriteInput;
  uint32_t CMXSize;
  uint32_t reluSHVAcc;
  uint32_t shvNegSlope;
  uint32_t shvPosSlope;
  uint32_t desc_count;
  std::vector<int8_t> descriptors;
  std::unique_ptr<TensorT> input;
  std::unique_ptr<TensorT> output;
  std::unique_ptr<TensorT> weight;
  std::unique_ptr<TensorT> bias;
  NCE1PoolT()
      : streamingMask(0),
        inputSize(0),
        outputSize(0),
        concatOffset(0),
        unloadCMX(0),
        overwriteInput(0),
        CMXSize(0),
        reluSHVAcc(0),
        shvNegSlope(0),
        shvPosSlope(0),
        desc_count(0) {
  }
};

struct NCE1Pool FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NCE1PoolT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAMINGMASK = 4,
    VT_INPUTSIZE = 6,
    VT_OUTPUTSIZE = 8,
    VT_CONCATOFFSET = 10,
    VT_UNLOADCMX = 12,
    VT_OVERWRITEINPUT = 14,
    VT_CMXSIZE = 16,
    VT_RELUSHVACC = 18,
    VT_SHVNEGSLOPE = 20,
    VT_SHVPOSSLOPE = 22,
    VT_DESC_COUNT = 24,
    VT_DESCRIPTORS = 26,
    VT_INPUT = 28,
    VT_OUTPUT = 30,
    VT_WEIGHT = 32,
    VT_BIAS = 34
  };
  uint32_t streamingMask() const {
    return GetField<uint32_t>(VT_STREAMINGMASK, 0);
  }
  uint32_t inputSize() const {
    return GetField<uint32_t>(VT_INPUTSIZE, 0);
  }
  uint32_t outputSize() const {
    return GetField<uint32_t>(VT_OUTPUTSIZE, 0);
  }
  uint32_t concatOffset() const {
    return GetField<uint32_t>(VT_CONCATOFFSET, 0);
  }
  uint32_t unloadCMX() const {
    return GetField<uint32_t>(VT_UNLOADCMX, 0);
  }
  uint32_t overwriteInput() const {
    return GetField<uint32_t>(VT_OVERWRITEINPUT, 0);
  }
  uint32_t CMXSize() const {
    return GetField<uint32_t>(VT_CMXSIZE, 0);
  }
  uint32_t reluSHVAcc() const {
    return GetField<uint32_t>(VT_RELUSHVACC, 0);
  }
  uint32_t shvNegSlope() const {
    return GetField<uint32_t>(VT_SHVNEGSLOPE, 0);
  }
  uint32_t shvPosSlope() const {
    return GetField<uint32_t>(VT_SHVPOSSLOPE, 0);
  }
  uint32_t desc_count() const {
    return GetField<uint32_t>(VT_DESC_COUNT, 0);
  }
  const flatbuffers::Vector<int8_t> *descriptors() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_DESCRIPTORS);
  }
  const Tensor *input() const {
    return GetPointer<const Tensor *>(VT_INPUT);
  }
  const Tensor *output() const {
    return GetPointer<const Tensor *>(VT_OUTPUT);
  }
  const Tensor *weight() const {
    return GetPointer<const Tensor *>(VT_WEIGHT);
  }
  const Tensor *bias() const {
    return GetPointer<const Tensor *>(VT_BIAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_STREAMINGMASK) &&
           VerifyField<uint32_t>(verifier, VT_INPUTSIZE) &&
           VerifyField<uint32_t>(verifier, VT_OUTPUTSIZE) &&
           VerifyField<uint32_t>(verifier, VT_CONCATOFFSET) &&
           VerifyField<uint32_t>(verifier, VT_UNLOADCMX) &&
           VerifyField<uint32_t>(verifier, VT_OVERWRITEINPUT) &&
           VerifyField<uint32_t>(verifier, VT_CMXSIZE) &&
           VerifyField<uint32_t>(verifier, VT_RELUSHVACC) &&
           VerifyField<uint32_t>(verifier, VT_SHVNEGSLOPE) &&
           VerifyField<uint32_t>(verifier, VT_SHVPOSSLOPE) &&
           VerifyField<uint32_t>(verifier, VT_DESC_COUNT) &&
           VerifyOffset(verifier, VT_DESCRIPTORS) &&
           verifier.VerifyVector(descriptors()) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyTable(input()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyTable(output()) &&
           VerifyOffset(verifier, VT_WEIGHT) &&
           verifier.VerifyTable(weight()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyTable(bias()) &&
           verifier.EndTable();
  }
  NCE1PoolT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NCE1PoolT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NCE1Pool> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NCE1PoolT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NCE1PoolBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_streamingMask(uint32_t streamingMask) {
    fbb_.AddElement<uint32_t>(NCE1Pool::VT_STREAMINGMASK, streamingMask, 0);
  }
  void add_inputSize(uint32_t inputSize) {
    fbb_.AddElement<uint32_t>(NCE1Pool::VT_INPUTSIZE, inputSize, 0);
  }
  void add_outputSize(uint32_t outputSize) {
    fbb_.AddElement<uint32_t>(NCE1Pool::VT_OUTPUTSIZE, outputSize, 0);
  }
  void add_concatOffset(uint32_t concatOffset) {
    fbb_.AddElement<uint32_t>(NCE1Pool::VT_CONCATOFFSET, concatOffset, 0);
  }
  void add_unloadCMX(uint32_t unloadCMX) {
    fbb_.AddElement<uint32_t>(NCE1Pool::VT_UNLOADCMX, unloadCMX, 0);
  }
  void add_overwriteInput(uint32_t overwriteInput) {
    fbb_.AddElement<uint32_t>(NCE1Pool::VT_OVERWRITEINPUT, overwriteInput, 0);
  }
  void add_CMXSize(uint32_t CMXSize) {
    fbb_.AddElement<uint32_t>(NCE1Pool::VT_CMXSIZE, CMXSize, 0);
  }
  void add_reluSHVAcc(uint32_t reluSHVAcc) {
    fbb_.AddElement<uint32_t>(NCE1Pool::VT_RELUSHVACC, reluSHVAcc, 0);
  }
  void add_shvNegSlope(uint32_t shvNegSlope) {
    fbb_.AddElement<uint32_t>(NCE1Pool::VT_SHVNEGSLOPE, shvNegSlope, 0);
  }
  void add_shvPosSlope(uint32_t shvPosSlope) {
    fbb_.AddElement<uint32_t>(NCE1Pool::VT_SHVPOSSLOPE, shvPosSlope, 0);
  }
  void add_desc_count(uint32_t desc_count) {
    fbb_.AddElement<uint32_t>(NCE1Pool::VT_DESC_COUNT, desc_count, 0);
  }
  void add_descriptors(flatbuffers::Offset<flatbuffers::Vector<int8_t>> descriptors) {
    fbb_.AddOffset(NCE1Pool::VT_DESCRIPTORS, descriptors);
  }
  void add_input(flatbuffers::Offset<Tensor> input) {
    fbb_.AddOffset(NCE1Pool::VT_INPUT, input);
  }
  void add_output(flatbuffers::Offset<Tensor> output) {
    fbb_.AddOffset(NCE1Pool::VT_OUTPUT, output);
  }
  void add_weight(flatbuffers::Offset<Tensor> weight) {
    fbb_.AddOffset(NCE1Pool::VT_WEIGHT, weight);
  }
  void add_bias(flatbuffers::Offset<Tensor> bias) {
    fbb_.AddOffset(NCE1Pool::VT_BIAS, bias);
  }
  explicit NCE1PoolBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NCE1PoolBuilder &operator=(const NCE1PoolBuilder &);
  flatbuffers::Offset<NCE1Pool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NCE1Pool>(end);
    return o;
  }
};

inline flatbuffers::Offset<NCE1Pool> CreateNCE1Pool(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t streamingMask = 0,
    uint32_t inputSize = 0,
    uint32_t outputSize = 0,
    uint32_t concatOffset = 0,
    uint32_t unloadCMX = 0,
    uint32_t overwriteInput = 0,
    uint32_t CMXSize = 0,
    uint32_t reluSHVAcc = 0,
    uint32_t shvNegSlope = 0,
    uint32_t shvPosSlope = 0,
    uint32_t desc_count = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> descriptors = 0,
    flatbuffers::Offset<Tensor> input = 0,
    flatbuffers::Offset<Tensor> output = 0,
    flatbuffers::Offset<Tensor> weight = 0,
    flatbuffers::Offset<Tensor> bias = 0) {
  NCE1PoolBuilder builder_(_fbb);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_output(output);
  builder_.add_input(input);
  builder_.add_descriptors(descriptors);
  builder_.add_desc_count(desc_count);
  builder_.add_shvPosSlope(shvPosSlope);
  builder_.add_shvNegSlope(shvNegSlope);
  builder_.add_reluSHVAcc(reluSHVAcc);
  builder_.add_CMXSize(CMXSize);
  builder_.add_overwriteInput(overwriteInput);
  builder_.add_unloadCMX(unloadCMX);
  builder_.add_concatOffset(concatOffset);
  builder_.add_outputSize(outputSize);
  builder_.add_inputSize(inputSize);
  builder_.add_streamingMask(streamingMask);
  return builder_.Finish();
}

inline flatbuffers::Offset<NCE1Pool> CreateNCE1PoolDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t streamingMask = 0,
    uint32_t inputSize = 0,
    uint32_t outputSize = 0,
    uint32_t concatOffset = 0,
    uint32_t unloadCMX = 0,
    uint32_t overwriteInput = 0,
    uint32_t CMXSize = 0,
    uint32_t reluSHVAcc = 0,
    uint32_t shvNegSlope = 0,
    uint32_t shvPosSlope = 0,
    uint32_t desc_count = 0,
    const std::vector<int8_t> *descriptors = nullptr,
    flatbuffers::Offset<Tensor> input = 0,
    flatbuffers::Offset<Tensor> output = 0,
    flatbuffers::Offset<Tensor> weight = 0,
    flatbuffers::Offset<Tensor> bias = 0) {
  auto descriptors__ = descriptors ? _fbb.CreateVector<int8_t>(*descriptors) : 0;
  return MVCNN::CreateNCE1Pool(
      _fbb,
      streamingMask,
      inputSize,
      outputSize,
      concatOffset,
      unloadCMX,
      overwriteInput,
      CMXSize,
      reluSHVAcc,
      shvNegSlope,
      shvPosSlope,
      desc_count,
      descriptors__,
      input,
      output,
      weight,
      bias);
}

flatbuffers::Offset<NCE1Pool> CreateNCE1Pool(flatbuffers::FlatBufferBuilder &_fbb, const NCE1PoolT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NCE1FCLT : public flatbuffers::NativeTable {
  typedef NCE1FCL TableType;
  uint32_t streamingMask;
  uint32_t inputSize;
  uint32_t outputSize;
  uint32_t concatOffset;
  uint32_t unloadCMX;
  uint32_t overwriteInput;
  uint32_t CMXSize;
  uint32_t reluSHVAcc;
  uint32_t shvNegSlope;
  uint32_t shvPosSlope;
  uint32_t desc_count;
  std::vector<int8_t> descriptors;
  std::unique_ptr<TensorT> input;
  std::unique_ptr<TensorT> output;
  std::unique_ptr<TensorT> weight;
  std::unique_ptr<TensorT> bias;
  NCE1FCLT()
      : streamingMask(0),
        inputSize(0),
        outputSize(0),
        concatOffset(0),
        unloadCMX(0),
        overwriteInput(0),
        CMXSize(0),
        reluSHVAcc(0),
        shvNegSlope(0),
        shvPosSlope(0),
        desc_count(0) {
  }
};

struct NCE1FCL FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NCE1FCLT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAMINGMASK = 4,
    VT_INPUTSIZE = 6,
    VT_OUTPUTSIZE = 8,
    VT_CONCATOFFSET = 10,
    VT_UNLOADCMX = 12,
    VT_OVERWRITEINPUT = 14,
    VT_CMXSIZE = 16,
    VT_RELUSHVACC = 18,
    VT_SHVNEGSLOPE = 20,
    VT_SHVPOSSLOPE = 22,
    VT_DESC_COUNT = 24,
    VT_DESCRIPTORS = 26,
    VT_INPUT = 28,
    VT_OUTPUT = 30,
    VT_WEIGHT = 32,
    VT_BIAS = 34
  };
  uint32_t streamingMask() const {
    return GetField<uint32_t>(VT_STREAMINGMASK, 0);
  }
  uint32_t inputSize() const {
    return GetField<uint32_t>(VT_INPUTSIZE, 0);
  }
  uint32_t outputSize() const {
    return GetField<uint32_t>(VT_OUTPUTSIZE, 0);
  }
  uint32_t concatOffset() const {
    return GetField<uint32_t>(VT_CONCATOFFSET, 0);
  }
  uint32_t unloadCMX() const {
    return GetField<uint32_t>(VT_UNLOADCMX, 0);
  }
  uint32_t overwriteInput() const {
    return GetField<uint32_t>(VT_OVERWRITEINPUT, 0);
  }
  uint32_t CMXSize() const {
    return GetField<uint32_t>(VT_CMXSIZE, 0);
  }
  uint32_t reluSHVAcc() const {
    return GetField<uint32_t>(VT_RELUSHVACC, 0);
  }
  uint32_t shvNegSlope() const {
    return GetField<uint32_t>(VT_SHVNEGSLOPE, 0);
  }
  uint32_t shvPosSlope() const {
    return GetField<uint32_t>(VT_SHVPOSSLOPE, 0);
  }
  uint32_t desc_count() const {
    return GetField<uint32_t>(VT_DESC_COUNT, 0);
  }
  const flatbuffers::Vector<int8_t> *descriptors() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_DESCRIPTORS);
  }
  const Tensor *input() const {
    return GetPointer<const Tensor *>(VT_INPUT);
  }
  const Tensor *output() const {
    return GetPointer<const Tensor *>(VT_OUTPUT);
  }
  const Tensor *weight() const {
    return GetPointer<const Tensor *>(VT_WEIGHT);
  }
  const Tensor *bias() const {
    return GetPointer<const Tensor *>(VT_BIAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_STREAMINGMASK) &&
           VerifyField<uint32_t>(verifier, VT_INPUTSIZE) &&
           VerifyField<uint32_t>(verifier, VT_OUTPUTSIZE) &&
           VerifyField<uint32_t>(verifier, VT_CONCATOFFSET) &&
           VerifyField<uint32_t>(verifier, VT_UNLOADCMX) &&
           VerifyField<uint32_t>(verifier, VT_OVERWRITEINPUT) &&
           VerifyField<uint32_t>(verifier, VT_CMXSIZE) &&
           VerifyField<uint32_t>(verifier, VT_RELUSHVACC) &&
           VerifyField<uint32_t>(verifier, VT_SHVNEGSLOPE) &&
           VerifyField<uint32_t>(verifier, VT_SHVPOSSLOPE) &&
           VerifyField<uint32_t>(verifier, VT_DESC_COUNT) &&
           VerifyOffset(verifier, VT_DESCRIPTORS) &&
           verifier.VerifyVector(descriptors()) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyTable(input()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyTable(output()) &&
           VerifyOffset(verifier, VT_WEIGHT) &&
           verifier.VerifyTable(weight()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyTable(bias()) &&
           verifier.EndTable();
  }
  NCE1FCLT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NCE1FCLT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NCE1FCL> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NCE1FCLT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NCE1FCLBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_streamingMask(uint32_t streamingMask) {
    fbb_.AddElement<uint32_t>(NCE1FCL::VT_STREAMINGMASK, streamingMask, 0);
  }
  void add_inputSize(uint32_t inputSize) {
    fbb_.AddElement<uint32_t>(NCE1FCL::VT_INPUTSIZE, inputSize, 0);
  }
  void add_outputSize(uint32_t outputSize) {
    fbb_.AddElement<uint32_t>(NCE1FCL::VT_OUTPUTSIZE, outputSize, 0);
  }
  void add_concatOffset(uint32_t concatOffset) {
    fbb_.AddElement<uint32_t>(NCE1FCL::VT_CONCATOFFSET, concatOffset, 0);
  }
  void add_unloadCMX(uint32_t unloadCMX) {
    fbb_.AddElement<uint32_t>(NCE1FCL::VT_UNLOADCMX, unloadCMX, 0);
  }
  void add_overwriteInput(uint32_t overwriteInput) {
    fbb_.AddElement<uint32_t>(NCE1FCL::VT_OVERWRITEINPUT, overwriteInput, 0);
  }
  void add_CMXSize(uint32_t CMXSize) {
    fbb_.AddElement<uint32_t>(NCE1FCL::VT_CMXSIZE, CMXSize, 0);
  }
  void add_reluSHVAcc(uint32_t reluSHVAcc) {
    fbb_.AddElement<uint32_t>(NCE1FCL::VT_RELUSHVACC, reluSHVAcc, 0);
  }
  void add_shvNegSlope(uint32_t shvNegSlope) {
    fbb_.AddElement<uint32_t>(NCE1FCL::VT_SHVNEGSLOPE, shvNegSlope, 0);
  }
  void add_shvPosSlope(uint32_t shvPosSlope) {
    fbb_.AddElement<uint32_t>(NCE1FCL::VT_SHVPOSSLOPE, shvPosSlope, 0);
  }
  void add_desc_count(uint32_t desc_count) {
    fbb_.AddElement<uint32_t>(NCE1FCL::VT_DESC_COUNT, desc_count, 0);
  }
  void add_descriptors(flatbuffers::Offset<flatbuffers::Vector<int8_t>> descriptors) {
    fbb_.AddOffset(NCE1FCL::VT_DESCRIPTORS, descriptors);
  }
  void add_input(flatbuffers::Offset<Tensor> input) {
    fbb_.AddOffset(NCE1FCL::VT_INPUT, input);
  }
  void add_output(flatbuffers::Offset<Tensor> output) {
    fbb_.AddOffset(NCE1FCL::VT_OUTPUT, output);
  }
  void add_weight(flatbuffers::Offset<Tensor> weight) {
    fbb_.AddOffset(NCE1FCL::VT_WEIGHT, weight);
  }
  void add_bias(flatbuffers::Offset<Tensor> bias) {
    fbb_.AddOffset(NCE1FCL::VT_BIAS, bias);
  }
  explicit NCE1FCLBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NCE1FCLBuilder &operator=(const NCE1FCLBuilder &);
  flatbuffers::Offset<NCE1FCL> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NCE1FCL>(end);
    return o;
  }
};

inline flatbuffers::Offset<NCE1FCL> CreateNCE1FCL(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t streamingMask = 0,
    uint32_t inputSize = 0,
    uint32_t outputSize = 0,
    uint32_t concatOffset = 0,
    uint32_t unloadCMX = 0,
    uint32_t overwriteInput = 0,
    uint32_t CMXSize = 0,
    uint32_t reluSHVAcc = 0,
    uint32_t shvNegSlope = 0,
    uint32_t shvPosSlope = 0,
    uint32_t desc_count = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> descriptors = 0,
    flatbuffers::Offset<Tensor> input = 0,
    flatbuffers::Offset<Tensor> output = 0,
    flatbuffers::Offset<Tensor> weight = 0,
    flatbuffers::Offset<Tensor> bias = 0) {
  NCE1FCLBuilder builder_(_fbb);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_output(output);
  builder_.add_input(input);
  builder_.add_descriptors(descriptors);
  builder_.add_desc_count(desc_count);
  builder_.add_shvPosSlope(shvPosSlope);
  builder_.add_shvNegSlope(shvNegSlope);
  builder_.add_reluSHVAcc(reluSHVAcc);
  builder_.add_CMXSize(CMXSize);
  builder_.add_overwriteInput(overwriteInput);
  builder_.add_unloadCMX(unloadCMX);
  builder_.add_concatOffset(concatOffset);
  builder_.add_outputSize(outputSize);
  builder_.add_inputSize(inputSize);
  builder_.add_streamingMask(streamingMask);
  return builder_.Finish();
}

inline flatbuffers::Offset<NCE1FCL> CreateNCE1FCLDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t streamingMask = 0,
    uint32_t inputSize = 0,
    uint32_t outputSize = 0,
    uint32_t concatOffset = 0,
    uint32_t unloadCMX = 0,
    uint32_t overwriteInput = 0,
    uint32_t CMXSize = 0,
    uint32_t reluSHVAcc = 0,
    uint32_t shvNegSlope = 0,
    uint32_t shvPosSlope = 0,
    uint32_t desc_count = 0,
    const std::vector<int8_t> *descriptors = nullptr,
    flatbuffers::Offset<Tensor> input = 0,
    flatbuffers::Offset<Tensor> output = 0,
    flatbuffers::Offset<Tensor> weight = 0,
    flatbuffers::Offset<Tensor> bias = 0) {
  auto descriptors__ = descriptors ? _fbb.CreateVector<int8_t>(*descriptors) : 0;
  return MVCNN::CreateNCE1FCL(
      _fbb,
      streamingMask,
      inputSize,
      outputSize,
      concatOffset,
      unloadCMX,
      overwriteInput,
      CMXSize,
      reluSHVAcc,
      shvNegSlope,
      shvPosSlope,
      desc_count,
      descriptors__,
      input,
      output,
      weight,
      bias);
}

flatbuffers::Offset<NCE1FCL> CreateNCE1FCL(flatbuffers::FlatBufferBuilder &_fbb, const NCE1FCLT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline NCE1TaskT *NCE1Task::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NCE1TaskT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void NCE1Task::UnPackTo(NCE1TaskT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = layer_type(); _o->layer.type = _e; };
  { auto _e = layer(); if (_e) _o->layer.value = NCE1LayerUnion::UnPack(_e, layer_type(), _resolver); };
}

inline flatbuffers::Offset<NCE1Task> NCE1Task::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NCE1TaskT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNCE1Task(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NCE1Task> CreateNCE1Task(flatbuffers::FlatBufferBuilder &_fbb, const NCE1TaskT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NCE1TaskT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _layer_type = _o->layer.type;
  auto _layer = _o->layer.Pack(_fbb);
  return MVCNN::CreateNCE1Task(
      _fbb,
      _layer_type,
      _layer);
}

inline NCE1ConvT *NCE1Conv::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NCE1ConvT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void NCE1Conv::UnPackTo(NCE1ConvT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = streamingMask(); _o->streamingMask = _e; };
  { auto _e = inputSize(); _o->inputSize = _e; };
  { auto _e = outputSize(); _o->outputSize = _e; };
  { auto _e = concatOffset(); _o->concatOffset = _e; };
  { auto _e = unloadCMX(); _o->unloadCMX = _e; };
  { auto _e = overwriteInput(); _o->overwriteInput = _e; };
  { auto _e = CMXSize(); _o->CMXSize = _e; };
  { auto _e = reluSHVAcc(); _o->reluSHVAcc = _e; };
  { auto _e = shvNegSlope(); _o->shvNegSlope = _e; };
  { auto _e = shvPosSlope(); _o->shvPosSlope = _e; };
  { auto _e = desc_count(); _o->desc_count = _e; };
  { auto _e = descriptors(); if (_e) { _o->descriptors.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->descriptors[_i] = _e->Get(_i); } } };
  { auto _e = input(); if (_e) _o->input = std::unique_ptr<TensorT>(_e->UnPack(_resolver)); };
  { auto _e = output(); if (_e) _o->output = std::unique_ptr<TensorT>(_e->UnPack(_resolver)); };
  { auto _e = weight(); if (_e) _o->weight = std::unique_ptr<TensorT>(_e->UnPack(_resolver)); };
  { auto _e = bias(); if (_e) _o->bias = std::unique_ptr<TensorT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<NCE1Conv> NCE1Conv::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NCE1ConvT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNCE1Conv(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NCE1Conv> CreateNCE1Conv(flatbuffers::FlatBufferBuilder &_fbb, const NCE1ConvT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NCE1ConvT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _streamingMask = _o->streamingMask;
  auto _inputSize = _o->inputSize;
  auto _outputSize = _o->outputSize;
  auto _concatOffset = _o->concatOffset;
  auto _unloadCMX = _o->unloadCMX;
  auto _overwriteInput = _o->overwriteInput;
  auto _CMXSize = _o->CMXSize;
  auto _reluSHVAcc = _o->reluSHVAcc;
  auto _shvNegSlope = _o->shvNegSlope;
  auto _shvPosSlope = _o->shvPosSlope;
  auto _desc_count = _o->desc_count;
  auto _descriptors = _fbb.CreateVector(_o->descriptors);
  auto _input = _o->input ? CreateTensor(_fbb, _o->input.get(), _rehasher) : 0;
  auto _output = _o->output ? CreateTensor(_fbb, _o->output.get(), _rehasher) : 0;
  auto _weight = _o->weight ? CreateTensor(_fbb, _o->weight.get(), _rehasher) : 0;
  auto _bias = _o->bias ? CreateTensor(_fbb, _o->bias.get(), _rehasher) : 0;
  return MVCNN::CreateNCE1Conv(
      _fbb,
      _streamingMask,
      _inputSize,
      _outputSize,
      _concatOffset,
      _unloadCMX,
      _overwriteInput,
      _CMXSize,
      _reluSHVAcc,
      _shvNegSlope,
      _shvPosSlope,
      _desc_count,
      _descriptors,
      _input,
      _output,
      _weight,
      _bias);
}

inline NCE1PoolT *NCE1Pool::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NCE1PoolT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void NCE1Pool::UnPackTo(NCE1PoolT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = streamingMask(); _o->streamingMask = _e; };
  { auto _e = inputSize(); _o->inputSize = _e; };
  { auto _e = outputSize(); _o->outputSize = _e; };
  { auto _e = concatOffset(); _o->concatOffset = _e; };
  { auto _e = unloadCMX(); _o->unloadCMX = _e; };
  { auto _e = overwriteInput(); _o->overwriteInput = _e; };
  { auto _e = CMXSize(); _o->CMXSize = _e; };
  { auto _e = reluSHVAcc(); _o->reluSHVAcc = _e; };
  { auto _e = shvNegSlope(); _o->shvNegSlope = _e; };
  { auto _e = shvPosSlope(); _o->shvPosSlope = _e; };
  { auto _e = desc_count(); _o->desc_count = _e; };
  { auto _e = descriptors(); if (_e) { _o->descriptors.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->descriptors[_i] = _e->Get(_i); } } };
  { auto _e = input(); if (_e) _o->input = std::unique_ptr<TensorT>(_e->UnPack(_resolver)); };
  { auto _e = output(); if (_e) _o->output = std::unique_ptr<TensorT>(_e->UnPack(_resolver)); };
  { auto _e = weight(); if (_e) _o->weight = std::unique_ptr<TensorT>(_e->UnPack(_resolver)); };
  { auto _e = bias(); if (_e) _o->bias = std::unique_ptr<TensorT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<NCE1Pool> NCE1Pool::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NCE1PoolT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNCE1Pool(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NCE1Pool> CreateNCE1Pool(flatbuffers::FlatBufferBuilder &_fbb, const NCE1PoolT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NCE1PoolT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _streamingMask = _o->streamingMask;
  auto _inputSize = _o->inputSize;
  auto _outputSize = _o->outputSize;
  auto _concatOffset = _o->concatOffset;
  auto _unloadCMX = _o->unloadCMX;
  auto _overwriteInput = _o->overwriteInput;
  auto _CMXSize = _o->CMXSize;
  auto _reluSHVAcc = _o->reluSHVAcc;
  auto _shvNegSlope = _o->shvNegSlope;
  auto _shvPosSlope = _o->shvPosSlope;
  auto _desc_count = _o->desc_count;
  auto _descriptors = _fbb.CreateVector(_o->descriptors);
  auto _input = _o->input ? CreateTensor(_fbb, _o->input.get(), _rehasher) : 0;
  auto _output = _o->output ? CreateTensor(_fbb, _o->output.get(), _rehasher) : 0;
  auto _weight = _o->weight ? CreateTensor(_fbb, _o->weight.get(), _rehasher) : 0;
  auto _bias = _o->bias ? CreateTensor(_fbb, _o->bias.get(), _rehasher) : 0;
  return MVCNN::CreateNCE1Pool(
      _fbb,
      _streamingMask,
      _inputSize,
      _outputSize,
      _concatOffset,
      _unloadCMX,
      _overwriteInput,
      _CMXSize,
      _reluSHVAcc,
      _shvNegSlope,
      _shvPosSlope,
      _desc_count,
      _descriptors,
      _input,
      _output,
      _weight,
      _bias);
}

inline NCE1FCLT *NCE1FCL::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NCE1FCLT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void NCE1FCL::UnPackTo(NCE1FCLT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = streamingMask(); _o->streamingMask = _e; };
  { auto _e = inputSize(); _o->inputSize = _e; };
  { auto _e = outputSize(); _o->outputSize = _e; };
  { auto _e = concatOffset(); _o->concatOffset = _e; };
  { auto _e = unloadCMX(); _o->unloadCMX = _e; };
  { auto _e = overwriteInput(); _o->overwriteInput = _e; };
  { auto _e = CMXSize(); _o->CMXSize = _e; };
  { auto _e = reluSHVAcc(); _o->reluSHVAcc = _e; };
  { auto _e = shvNegSlope(); _o->shvNegSlope = _e; };
  { auto _e = shvPosSlope(); _o->shvPosSlope = _e; };
  { auto _e = desc_count(); _o->desc_count = _e; };
  { auto _e = descriptors(); if (_e) { _o->descriptors.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->descriptors[_i] = _e->Get(_i); } } };
  { auto _e = input(); if (_e) _o->input = std::unique_ptr<TensorT>(_e->UnPack(_resolver)); };
  { auto _e = output(); if (_e) _o->output = std::unique_ptr<TensorT>(_e->UnPack(_resolver)); };
  { auto _e = weight(); if (_e) _o->weight = std::unique_ptr<TensorT>(_e->UnPack(_resolver)); };
  { auto _e = bias(); if (_e) _o->bias = std::unique_ptr<TensorT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<NCE1FCL> NCE1FCL::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NCE1FCLT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNCE1FCL(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NCE1FCL> CreateNCE1FCL(flatbuffers::FlatBufferBuilder &_fbb, const NCE1FCLT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NCE1FCLT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _streamingMask = _o->streamingMask;
  auto _inputSize = _o->inputSize;
  auto _outputSize = _o->outputSize;
  auto _concatOffset = _o->concatOffset;
  auto _unloadCMX = _o->unloadCMX;
  auto _overwriteInput = _o->overwriteInput;
  auto _CMXSize = _o->CMXSize;
  auto _reluSHVAcc = _o->reluSHVAcc;
  auto _shvNegSlope = _o->shvNegSlope;
  auto _shvPosSlope = _o->shvPosSlope;
  auto _desc_count = _o->desc_count;
  auto _descriptors = _fbb.CreateVector(_o->descriptors);
  auto _input = _o->input ? CreateTensor(_fbb, _o->input.get(), _rehasher) : 0;
  auto _output = _o->output ? CreateTensor(_fbb, _o->output.get(), _rehasher) : 0;
  auto _weight = _o->weight ? CreateTensor(_fbb, _o->weight.get(), _rehasher) : 0;
  auto _bias = _o->bias ? CreateTensor(_fbb, _o->bias.get(), _rehasher) : 0;
  return MVCNN::CreateNCE1FCL(
      _fbb,
      _streamingMask,
      _inputSize,
      _outputSize,
      _concatOffset,
      _unloadCMX,
      _overwriteInput,
      _CMXSize,
      _reluSHVAcc,
      _shvNegSlope,
      _shvPosSlope,
      _desc_count,
      _descriptors,
      _input,
      _output,
      _weight,
      _bias);
}

inline bool VerifyNCE1Layer(flatbuffers::Verifier &verifier, const void *obj, NCE1Layer type) {
  switch (type) {
    case NCE1Layer_NONE: {
      return true;
    }
    case NCE1Layer_NCE1Conv: {
      auto ptr = reinterpret_cast<const NCE1Conv *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case NCE1Layer_NCE1Pool: {
      auto ptr = reinterpret_cast<const NCE1Pool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case NCE1Layer_NCE1FCL: {
      auto ptr = reinterpret_cast<const NCE1FCL *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyNCE1LayerVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyNCE1Layer(
        verifier,  values->Get(i), types->GetEnum<NCE1Layer>(i))) {
      return false;
    }
  }
  return true;
}

inline void *NCE1LayerUnion::UnPack(const void *obj, NCE1Layer type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case NCE1Layer_NCE1Conv: {
      auto ptr = reinterpret_cast<const NCE1Conv *>(obj);
      return ptr->UnPack(resolver);
    }
    case NCE1Layer_NCE1Pool: {
      auto ptr = reinterpret_cast<const NCE1Pool *>(obj);
      return ptr->UnPack(resolver);
    }
    case NCE1Layer_NCE1FCL: {
      auto ptr = reinterpret_cast<const NCE1FCL *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> NCE1LayerUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case NCE1Layer_NCE1Conv: {
      auto ptr = reinterpret_cast<const NCE1ConvT *>(value);
      return CreateNCE1Conv(_fbb, ptr, _rehasher).Union();
    }
    case NCE1Layer_NCE1Pool: {
      auto ptr = reinterpret_cast<const NCE1PoolT *>(value);
      return CreateNCE1Pool(_fbb, ptr, _rehasher).Union();
    }
    case NCE1Layer_NCE1FCL: {
      auto ptr = reinterpret_cast<const NCE1FCLT *>(value);
      return CreateNCE1FCL(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline NCE1LayerUnion::NCE1LayerUnion(const NCE1LayerUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case NCE1Layer_NCE1Conv: {
      FLATBUFFERS_ASSERT(false);  // NCE1ConvT not copyable.
      break;
    }
    case NCE1Layer_NCE1Pool: {
      FLATBUFFERS_ASSERT(false);  // NCE1PoolT not copyable.
      break;
    }
    case NCE1Layer_NCE1FCL: {
      FLATBUFFERS_ASSERT(false);  // NCE1FCLT not copyable.
      break;
    }
    default:
      break;
  }
}

inline void NCE1LayerUnion::Reset() {
  switch (type) {
    case NCE1Layer_NCE1Conv: {
      auto ptr = reinterpret_cast<NCE1ConvT *>(value);
      delete ptr;
      break;
    }
    case NCE1Layer_NCE1Pool: {
      auto ptr = reinterpret_cast<NCE1PoolT *>(value);
      delete ptr;
      break;
    }
    case NCE1Layer_NCE1FCL: {
      auto ptr = reinterpret_cast<NCE1FCLT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = NCE1Layer_NONE;
}

}  // namespace MVCNN

#endif  // FLATBUFFERS_GENERATED_UPANCE_MVCNN_H_
