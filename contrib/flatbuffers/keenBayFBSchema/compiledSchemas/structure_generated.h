// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_STRUCTURE_MVCNN_H_
#define FLATBUFFERS_GENERATED_STRUCTURE_MVCNN_H_

#include "flatbuffers/flatbuffers.h"

#include "memoryManagement_generated.h"

namespace MVCNN {

struct SourceStructure;

struct Link;

struct Barrier;

struct BarrierReference;

struct SourceStructure FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINKS = 4,
    VT_FIRST_ID = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<Link>> *links() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Link>> *>(VT_LINKS);
  }
  const flatbuffers::Vector<uint32_t> *first_ID() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_FIRST_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LINKS) &&
           verifier.VerifyVector(links()) &&
           verifier.VerifyVectorOfTables(links()) &&
           VerifyOffset(verifier, VT_FIRST_ID) &&
           verifier.VerifyVector(first_ID()) &&
           verifier.EndTable();
  }
};

struct SourceStructureBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_links(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Link>>> links) {
    fbb_.AddOffset(SourceStructure::VT_LINKS, links);
  }
  void add_first_ID(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> first_ID) {
    fbb_.AddOffset(SourceStructure::VT_FIRST_ID, first_ID);
  }
  explicit SourceStructureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SourceStructureBuilder &operator=(const SourceStructureBuilder &);
  flatbuffers::Offset<SourceStructure> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SourceStructure>(end);
    return o;
  }
};

inline flatbuffers::Offset<SourceStructure> CreateSourceStructure(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Link>>> links = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> first_ID = 0) {
  SourceStructureBuilder builder_(_fbb);
  builder_.add_first_ID(first_ID);
  builder_.add_links(links);
  return builder_.Finish();
}

inline flatbuffers::Offset<SourceStructure> CreateSourceStructureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Link>> *links = nullptr,
    const std::vector<uint32_t> *first_ID = nullptr) {
  auto links__ = links ? _fbb.CreateVector<flatbuffers::Offset<Link>>(*links) : 0;
  auto first_ID__ = first_ID ? _fbb.CreateVector<uint32_t>(*first_ID) : 0;
  return MVCNN::CreateSourceStructure(
      _fbb,
      links__,
      first_ID__);
}

struct Link FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_THISID = 4,
    VT_NAME = 6,
    VT_SOURCEID = 8,
    VT_SINKID = 10
  };
  uint32_t thisID() const {
    return GetField<uint32_t>(VT_THISID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<uint32_t> *sourceID() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_SOURCEID);
  }
  const flatbuffers::Vector<uint32_t> *sinkID() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_SINKID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_THISID) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_SOURCEID) &&
           verifier.VerifyVector(sourceID()) &&
           VerifyOffset(verifier, VT_SINKID) &&
           verifier.VerifyVector(sinkID()) &&
           verifier.EndTable();
  }
};

struct LinkBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_thisID(uint32_t thisID) {
    fbb_.AddElement<uint32_t>(Link::VT_THISID, thisID, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Link::VT_NAME, name);
  }
  void add_sourceID(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> sourceID) {
    fbb_.AddOffset(Link::VT_SOURCEID, sourceID);
  }
  void add_sinkID(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> sinkID) {
    fbb_.AddOffset(Link::VT_SINKID, sinkID);
  }
  explicit LinkBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LinkBuilder &operator=(const LinkBuilder &);
  flatbuffers::Offset<Link> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Link>(end);
    return o;
  }
};

inline flatbuffers::Offset<Link> CreateLink(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t thisID = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> sourceID = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> sinkID = 0) {
  LinkBuilder builder_(_fbb);
  builder_.add_sinkID(sinkID);
  builder_.add_sourceID(sourceID);
  builder_.add_name(name);
  builder_.add_thisID(thisID);
  return builder_.Finish();
}

inline flatbuffers::Offset<Link> CreateLinkDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t thisID = 0,
    const char *name = nullptr,
    const std::vector<uint32_t> *sourceID = nullptr,
    const std::vector<uint32_t> *sinkID = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto sourceID__ = sourceID ? _fbb.CreateVector<uint32_t>(*sourceID) : 0;
  auto sinkID__ = sinkID ? _fbb.CreateVector<uint32_t>(*sinkID) : 0;
  return MVCNN::CreateLink(
      _fbb,
      thisID,
      name__,
      sourceID__,
      sinkID__);
}

struct Barrier FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BARRIER_ID = 4,
    VT_CONSUMER_COUNT = 6,
    VT_PRODUCER_COUNT = 8
  };
  /// Overview:
  /// This object represents closely a Barrier in the device.
  /// Details of exact consumers and producers are delegated to those same
  /// producers and consumers.
  ///
  /// @field barrier_id - This is an optional field to force a barrier to use
  /// a specific barrier (note: a value given here only guarantees that any other
  /// barrier with that ID will run on the same unit, it does not guarantee a particular
  /// unit)
  int16_t barrier_id() const {
    return GetField<int16_t>(VT_BARRIER_ID, 0);
  }
  int16_t consumer_count() const {
    return GetField<int16_t>(VT_CONSUMER_COUNT, 0);
  }
  int16_t producer_count() const {
    return GetField<int16_t>(VT_PRODUCER_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_BARRIER_ID) &&
           VerifyField<int16_t>(verifier, VT_CONSUMER_COUNT) &&
           VerifyField<int16_t>(verifier, VT_PRODUCER_COUNT) &&
           verifier.EndTable();
  }
};

struct BarrierBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_barrier_id(int16_t barrier_id) {
    fbb_.AddElement<int16_t>(Barrier::VT_BARRIER_ID, barrier_id, 0);
  }
  void add_consumer_count(int16_t consumer_count) {
    fbb_.AddElement<int16_t>(Barrier::VT_CONSUMER_COUNT, consumer_count, 0);
  }
  void add_producer_count(int16_t producer_count) {
    fbb_.AddElement<int16_t>(Barrier::VT_PRODUCER_COUNT, producer_count, 0);
  }
  explicit BarrierBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BarrierBuilder &operator=(const BarrierBuilder &);
  flatbuffers::Offset<Barrier> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Barrier>(end);
    return o;
  }
};

inline flatbuffers::Offset<Barrier> CreateBarrier(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t barrier_id = 0,
    int16_t consumer_count = 0,
    int16_t producer_count = 0) {
  BarrierBuilder builder_(_fbb);
  builder_.add_producer_count(producer_count);
  builder_.add_consumer_count(consumer_count);
  builder_.add_barrier_id(barrier_id);
  return builder_.Finish();
}

struct BarrierReference FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WAIT_BARRIER = 4,
    VT_UPDATE_BARRIERS = 6
  };
  /// Overview:
  /// A BarrierReference is a tasks' accessor into it's barrier
  /// dependency and influence.
  ///
  /// @field wait_barrier - An Id of the barrier that will free this
  /// task to run. You should always only need to wait on one barrier
  /// as they support multiple references.
  /// Because there is only one, we cannot have an empty value.
  /// Therefore indexing should start at 1, with a value of 0 indicating
  /// that there is no blocking barrier (for example at the start of a network)
  ///
  /// @field update_barriers - Ids of barriers that will be at least partially
  /// unlocked when this task is complete.
  /// An empty list indicates that no barriers are reliant on this task.
  ///
  uint32_t wait_barrier() const {
    return GetField<uint32_t>(VT_WAIT_BARRIER, 0);
  }
  const flatbuffers::Vector<uint32_t> *update_barriers() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_UPDATE_BARRIERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_WAIT_BARRIER) &&
           VerifyOffset(verifier, VT_UPDATE_BARRIERS) &&
           verifier.VerifyVector(update_barriers()) &&
           verifier.EndTable();
  }
};

struct BarrierReferenceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_wait_barrier(uint32_t wait_barrier) {
    fbb_.AddElement<uint32_t>(BarrierReference::VT_WAIT_BARRIER, wait_barrier, 0);
  }
  void add_update_barriers(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> update_barriers) {
    fbb_.AddOffset(BarrierReference::VT_UPDATE_BARRIERS, update_barriers);
  }
  explicit BarrierReferenceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BarrierReferenceBuilder &operator=(const BarrierReferenceBuilder &);
  flatbuffers::Offset<BarrierReference> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BarrierReference>(end);
    return o;
  }
};

inline flatbuffers::Offset<BarrierReference> CreateBarrierReference(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t wait_barrier = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> update_barriers = 0) {
  BarrierReferenceBuilder builder_(_fbb);
  builder_.add_update_barriers(update_barriers);
  builder_.add_wait_barrier(wait_barrier);
  return builder_.Finish();
}

inline flatbuffers::Offset<BarrierReference> CreateBarrierReferenceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t wait_barrier = 0,
    const std::vector<uint32_t> *update_barriers = nullptr) {
  auto update_barriers__ = update_barriers ? _fbb.CreateVector<uint32_t>(*update_barriers) : 0;
  return MVCNN::CreateBarrierReference(
      _fbb,
      wait_barrier,
      update_barriers__);
}

}  // namespace MVCNN

#endif  // FLATBUFFERS_GENERATED_STRUCTURE_MVCNN_H_
