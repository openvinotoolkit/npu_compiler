// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FILEHEADER_MVCNN_H_
#define FLATBUFFERS_GENERATED_FILEHEADER_MVCNN_H_

#include "flatbuffers/flatbuffers.h"

#include "memoryManagement_generated.h"
#include "structure_generated.h"

namespace MVCNN {

struct Version;

struct Resources;

struct SummaryHeader;

struct Version FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAJORV = 4,
    VT_MINORV = 6,
    VT_PATCHV = 8,
    VT_HASH = 10
  };
  uint32_t majorV() const {
    return GetField<uint32_t>(VT_MAJORV, 0);
  }
  uint32_t minorV() const {
    return GetField<uint32_t>(VT_MINORV, 0);
  }
  uint32_t patchV() const {
    return GetField<uint32_t>(VT_PATCHV, 0);
  }
  const flatbuffers::String *hash() const {
    return GetPointer<const flatbuffers::String *>(VT_HASH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_MAJORV) &&
           VerifyField<uint32_t>(verifier, VT_MINORV) &&
           VerifyField<uint32_t>(verifier, VT_PATCHV) &&
           VerifyOffset(verifier, VT_HASH) &&
           verifier.VerifyString(hash()) &&
           verifier.EndTable();
  }
};

struct VersionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_majorV(uint32_t majorV) {
    fbb_.AddElement<uint32_t>(Version::VT_MAJORV, majorV, 0);
  }
  void add_minorV(uint32_t minorV) {
    fbb_.AddElement<uint32_t>(Version::VT_MINORV, minorV, 0);
  }
  void add_patchV(uint32_t patchV) {
    fbb_.AddElement<uint32_t>(Version::VT_PATCHV, patchV, 0);
  }
  void add_hash(flatbuffers::Offset<flatbuffers::String> hash) {
    fbb_.AddOffset(Version::VT_HASH, hash);
  }
  explicit VersionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VersionBuilder &operator=(const VersionBuilder &);
  flatbuffers::Offset<Version> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Version>(end);
    return o;
  }
};

inline flatbuffers::Offset<Version> CreateVersion(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t majorV = 0,
    uint32_t minorV = 0,
    uint32_t patchV = 0,
    flatbuffers::Offset<flatbuffers::String> hash = 0) {
  VersionBuilder builder_(_fbb);
  builder_.add_hash(hash);
  builder_.add_patchV(patchV);
  builder_.add_minorV(minorV);
  builder_.add_majorV(majorV);
  return builder_.Finish();
}

inline flatbuffers::Offset<Version> CreateVersionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t majorV = 0,
    uint32_t minorV = 0,
    uint32_t patchV = 0,
    const char *hash = nullptr) {
  auto hash__ = hash ? _fbb.CreateString(hash) : 0;
  return MVCNN::CreateVersion(
      _fbb,
      majorV,
      minorV,
      patchV,
      hash__);
}

struct Resources FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHAVE_MASK = 4,
    VT_NCE1_MASK = 6,
    VT_DPU_MASK = 8,
    VT_LEON_CMX = 10,
    VT_NN_CMX = 12,
    VT_DDR_SCRATCH = 14
  };
  uint32_t shave_mask() const {
    return GetField<uint32_t>(VT_SHAVE_MASK, 0);
  }
  int8_t nce1_mask() const {
    return GetField<int8_t>(VT_NCE1_MASK, 0);
  }
  uint32_t dpu_mask() const {
    return GetField<uint32_t>(VT_DPU_MASK, 0);
  }
  uint32_t leon_cmx() const {
    return GetField<uint32_t>(VT_LEON_CMX, 0);
  }
  uint32_t nn_cmx() const {
    return GetField<uint32_t>(VT_NN_CMX, 0);
  }
  uint32_t ddr_scratch() const {
    return GetField<uint32_t>(VT_DDR_SCRATCH, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SHAVE_MASK) &&
           VerifyField<int8_t>(verifier, VT_NCE1_MASK) &&
           VerifyField<uint32_t>(verifier, VT_DPU_MASK) &&
           VerifyField<uint32_t>(verifier, VT_LEON_CMX) &&
           VerifyField<uint32_t>(verifier, VT_NN_CMX) &&
           VerifyField<uint32_t>(verifier, VT_DDR_SCRATCH) &&
           verifier.EndTable();
  }
};

struct ResourcesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_shave_mask(uint32_t shave_mask) {
    fbb_.AddElement<uint32_t>(Resources::VT_SHAVE_MASK, shave_mask, 0);
  }
  void add_nce1_mask(int8_t nce1_mask) {
    fbb_.AddElement<int8_t>(Resources::VT_NCE1_MASK, nce1_mask, 0);
  }
  void add_dpu_mask(uint32_t dpu_mask) {
    fbb_.AddElement<uint32_t>(Resources::VT_DPU_MASK, dpu_mask, 0);
  }
  void add_leon_cmx(uint32_t leon_cmx) {
    fbb_.AddElement<uint32_t>(Resources::VT_LEON_CMX, leon_cmx, 0);
  }
  void add_nn_cmx(uint32_t nn_cmx) {
    fbb_.AddElement<uint32_t>(Resources::VT_NN_CMX, nn_cmx, 0);
  }
  void add_ddr_scratch(uint32_t ddr_scratch) {
    fbb_.AddElement<uint32_t>(Resources::VT_DDR_SCRATCH, ddr_scratch, 0);
  }
  explicit ResourcesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResourcesBuilder &operator=(const ResourcesBuilder &);
  flatbuffers::Offset<Resources> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Resources>(end);
    return o;
  }
};

inline flatbuffers::Offset<Resources> CreateResources(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t shave_mask = 0,
    int8_t nce1_mask = 0,
    uint32_t dpu_mask = 0,
    uint32_t leon_cmx = 0,
    uint32_t nn_cmx = 0,
    uint32_t ddr_scratch = 0) {
  ResourcesBuilder builder_(_fbb);
  builder_.add_ddr_scratch(ddr_scratch);
  builder_.add_nn_cmx(nn_cmx);
  builder_.add_leon_cmx(leon_cmx);
  builder_.add_dpu_mask(dpu_mask);
  builder_.add_shave_mask(shave_mask);
  builder_.add_nce1_mask(nce1_mask);
  return builder_.Finish();
}

struct SummaryHeader FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_NET_INPUT = 6,
    VT_NET_OUTPUT = 8,
    VT_TASK_COUNT = 10,
    VT_LAYER_COUNT = 12,
    VT_RESOURCES = 14,
    VT_ORIGINAL_STRUCTURE = 16
  };
  const Version *version() const {
    return GetPointer<const Version *>(VT_VERSION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TensorReference>> *net_input() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TensorReference>> *>(VT_NET_INPUT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TensorReference>> *net_output() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TensorReference>> *>(VT_NET_OUTPUT);
  }
  uint32_t task_count() const {
    return GetField<uint32_t>(VT_TASK_COUNT, 0);
  }
  uint32_t layer_count() const {
    return GetField<uint32_t>(VT_LAYER_COUNT, 0);
  }
  const Resources *resources() const {
    return GetPointer<const Resources *>(VT_RESOURCES);
  }
  const SourceStructure *original_structure() const {
    return GetPointer<const SourceStructure *>(VT_ORIGINAL_STRUCTURE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyTable(version()) &&
           VerifyOffset(verifier, VT_NET_INPUT) &&
           verifier.VerifyVector(net_input()) &&
           verifier.VerifyVectorOfTables(net_input()) &&
           VerifyOffset(verifier, VT_NET_OUTPUT) &&
           verifier.VerifyVector(net_output()) &&
           verifier.VerifyVectorOfTables(net_output()) &&
           VerifyField<uint32_t>(verifier, VT_TASK_COUNT) &&
           VerifyField<uint32_t>(verifier, VT_LAYER_COUNT) &&
           VerifyOffset(verifier, VT_RESOURCES) &&
           verifier.VerifyTable(resources()) &&
           VerifyOffset(verifier, VT_ORIGINAL_STRUCTURE) &&
           verifier.VerifyTable(original_structure()) &&
           verifier.EndTable();
  }
};

struct SummaryHeaderBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(flatbuffers::Offset<Version> version) {
    fbb_.AddOffset(SummaryHeader::VT_VERSION, version);
  }
  void add_net_input(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TensorReference>>> net_input) {
    fbb_.AddOffset(SummaryHeader::VT_NET_INPUT, net_input);
  }
  void add_net_output(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TensorReference>>> net_output) {
    fbb_.AddOffset(SummaryHeader::VT_NET_OUTPUT, net_output);
  }
  void add_task_count(uint32_t task_count) {
    fbb_.AddElement<uint32_t>(SummaryHeader::VT_TASK_COUNT, task_count, 0);
  }
  void add_layer_count(uint32_t layer_count) {
    fbb_.AddElement<uint32_t>(SummaryHeader::VT_LAYER_COUNT, layer_count, 0);
  }
  void add_resources(flatbuffers::Offset<Resources> resources) {
    fbb_.AddOffset(SummaryHeader::VT_RESOURCES, resources);
  }
  void add_original_structure(flatbuffers::Offset<SourceStructure> original_structure) {
    fbb_.AddOffset(SummaryHeader::VT_ORIGINAL_STRUCTURE, original_structure);
  }
  explicit SummaryHeaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SummaryHeaderBuilder &operator=(const SummaryHeaderBuilder &);
  flatbuffers::Offset<SummaryHeader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SummaryHeader>(end);
    return o;
  }
};

inline flatbuffers::Offset<SummaryHeader> CreateSummaryHeader(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Version> version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TensorReference>>> net_input = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TensorReference>>> net_output = 0,
    uint32_t task_count = 0,
    uint32_t layer_count = 0,
    flatbuffers::Offset<Resources> resources = 0,
    flatbuffers::Offset<SourceStructure> original_structure = 0) {
  SummaryHeaderBuilder builder_(_fbb);
  builder_.add_original_structure(original_structure);
  builder_.add_resources(resources);
  builder_.add_layer_count(layer_count);
  builder_.add_task_count(task_count);
  builder_.add_net_output(net_output);
  builder_.add_net_input(net_input);
  builder_.add_version(version);
  return builder_.Finish();
}

inline flatbuffers::Offset<SummaryHeader> CreateSummaryHeaderDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Version> version = 0,
    const std::vector<flatbuffers::Offset<TensorReference>> *net_input = nullptr,
    const std::vector<flatbuffers::Offset<TensorReference>> *net_output = nullptr,
    uint32_t task_count = 0,
    uint32_t layer_count = 0,
    flatbuffers::Offset<Resources> resources = 0,
    flatbuffers::Offset<SourceStructure> original_structure = 0) {
  auto net_input__ = net_input ? _fbb.CreateVector<flatbuffers::Offset<TensorReference>>(*net_input) : 0;
  auto net_output__ = net_output ? _fbb.CreateVector<flatbuffers::Offset<TensorReference>>(*net_output) : 0;
  return MVCNN::CreateSummaryHeader(
      _fbb,
      version,
      net_input__,
      net_output__,
      task_count,
      layer_count,
      resources,
      original_structure);
}

}  // namespace MVCNN

#endif  // FLATBUFFERS_GENERATED_FILEHEADER_MVCNN_H_
