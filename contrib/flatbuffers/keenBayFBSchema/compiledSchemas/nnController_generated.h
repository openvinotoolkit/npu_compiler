// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_NNCONTROLLER_MVCNN_H_
#define FLATBUFFERS_GENERATED_NNCONTROLLER_MVCNN_H_

#include "flatbuffers/flatbuffers.h"

#include "memoryManagement_generated.h"
#include "structure_generated.h"

namespace MVCNN {

struct timerTask;

struct memoryTask;

struct barrierConfigurationTask;

struct ControllerTask;

enum ControllerSubTask {
  ControllerSubTask_NONE = 0,
  ControllerSubTask_timerTask = 1,
  ControllerSubTask_memoryTask = 2,
  ControllerSubTask_barrierConfigurationTask = 3,
  ControllerSubTask_MIN = ControllerSubTask_NONE,
  ControllerSubTask_MAX = ControllerSubTask_barrierConfigurationTask
};

inline const ControllerSubTask (&EnumValuesControllerSubTask())[4] {
  static const ControllerSubTask values[] = {
    ControllerSubTask_NONE,
    ControllerSubTask_timerTask,
    ControllerSubTask_memoryTask,
    ControllerSubTask_barrierConfigurationTask
  };
  return values;
}

inline const char * const *EnumNamesControllerSubTask() {
  static const char * const names[] = {
    "NONE",
    "timerTask",
    "memoryTask",
    "barrierConfigurationTask",
    nullptr
  };
  return names;
}

inline const char *EnumNameControllerSubTask(ControllerSubTask e) {
  if (e < ControllerSubTask_NONE || e > ControllerSubTask_barrierConfigurationTask) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesControllerSubTask()[index];
}

template<typename T> struct ControllerSubTaskTraits {
  static const ControllerSubTask enum_value = ControllerSubTask_NONE;
};

template<> struct ControllerSubTaskTraits<timerTask> {
  static const ControllerSubTask enum_value = ControllerSubTask_timerTask;
};

template<> struct ControllerSubTaskTraits<memoryTask> {
  static const ControllerSubTask enum_value = ControllerSubTask_memoryTask;
};

template<> struct ControllerSubTaskTraits<barrierConfigurationTask> {
  static const ControllerSubTask enum_value = ControllerSubTask_barrierConfigurationTask;
};

bool VerifyControllerSubTask(flatbuffers::Verifier &verifier, const void *obj, ControllerSubTask type);
bool VerifyControllerSubTaskVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct timerTask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_WRITE_LOCATION = 6
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  const TensorReference *write_location() const {
    return GetPointer<const TensorReference *>(VT_WRITE_LOCATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_WRITE_LOCATION) &&
           verifier.VerifyTable(write_location()) &&
           verifier.EndTable();
  }
};

struct timerTaskBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(timerTask::VT_ID, id, 0);
  }
  void add_write_location(flatbuffers::Offset<TensorReference> write_location) {
    fbb_.AddOffset(timerTask::VT_WRITE_LOCATION, write_location);
  }
  explicit timerTaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  timerTaskBuilder &operator=(const timerTaskBuilder &);
  flatbuffers::Offset<timerTask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<timerTask>(end);
    return o;
  }
};

inline flatbuffers::Offset<timerTask> CreatetimerTask(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    flatbuffers::Offset<TensorReference> write_location = 0) {
  timerTaskBuilder builder_(_fbb);
  builder_.add_write_location(write_location);
  builder_.add_id(id);
  return builder_.Finish();
}

struct memoryTask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
};

struct memoryTaskBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(memoryTask::VT_ID, id, 0);
  }
  explicit memoryTaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  memoryTaskBuilder &operator=(const memoryTaskBuilder &);
  flatbuffers::Offset<memoryTask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<memoryTask>(end);
    return o;
  }
};

inline flatbuffers::Offset<memoryTask> CreatememoryTask(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0) {
  memoryTaskBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct barrierConfigurationTask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TARGET = 4
  };
  const Barrier *target() const {
    return GetPointer<const Barrier *>(VT_TARGET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TARGET) &&
           verifier.VerifyTable(target()) &&
           verifier.EndTable();
  }
};

struct barrierConfigurationTaskBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_target(flatbuffers::Offset<Barrier> target) {
    fbb_.AddOffset(barrierConfigurationTask::VT_TARGET, target);
  }
  explicit barrierConfigurationTaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  barrierConfigurationTaskBuilder &operator=(const barrierConfigurationTaskBuilder &);
  flatbuffers::Offset<barrierConfigurationTask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<barrierConfigurationTask>(end);
    return o;
  }
};

inline flatbuffers::Offset<barrierConfigurationTask> CreatebarrierConfigurationTask(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Barrier> target = 0) {
  barrierConfigurationTaskBuilder builder_(_fbb);
  builder_.add_target(target);
  return builder_.Finish();
}

struct ControllerTask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TASK_TYPE = 4,
    VT_TASK = 6
  };
  ControllerSubTask task_type() const {
    return static_cast<ControllerSubTask>(GetField<uint8_t>(VT_TASK_TYPE, 0));
  }
  const void *task() const {
    return GetPointer<const void *>(VT_TASK);
  }
  template<typename T> const T *task_as() const;
  const timerTask *task_as_timerTask() const {
    return task_type() == ControllerSubTask_timerTask ? static_cast<const timerTask *>(task()) : nullptr;
  }
  const memoryTask *task_as_memoryTask() const {
    return task_type() == ControllerSubTask_memoryTask ? static_cast<const memoryTask *>(task()) : nullptr;
  }
  const barrierConfigurationTask *task_as_barrierConfigurationTask() const {
    return task_type() == ControllerSubTask_barrierConfigurationTask ? static_cast<const barrierConfigurationTask *>(task()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TASK_TYPE) &&
           VerifyOffset(verifier, VT_TASK) &&
           VerifyControllerSubTask(verifier, task(), task_type()) &&
           verifier.EndTable();
  }
};

template<> inline const timerTask *ControllerTask::task_as<timerTask>() const {
  return task_as_timerTask();
}

template<> inline const memoryTask *ControllerTask::task_as<memoryTask>() const {
  return task_as_memoryTask();
}

template<> inline const barrierConfigurationTask *ControllerTask::task_as<barrierConfigurationTask>() const {
  return task_as_barrierConfigurationTask();
}

struct ControllerTaskBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_task_type(ControllerSubTask task_type) {
    fbb_.AddElement<uint8_t>(ControllerTask::VT_TASK_TYPE, static_cast<uint8_t>(task_type), 0);
  }
  void add_task(flatbuffers::Offset<void> task) {
    fbb_.AddOffset(ControllerTask::VT_TASK, task);
  }
  explicit ControllerTaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ControllerTaskBuilder &operator=(const ControllerTaskBuilder &);
  flatbuffers::Offset<ControllerTask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ControllerTask>(end);
    return o;
  }
};

inline flatbuffers::Offset<ControllerTask> CreateControllerTask(
    flatbuffers::FlatBufferBuilder &_fbb,
    ControllerSubTask task_type = ControllerSubTask_NONE,
    flatbuffers::Offset<void> task = 0) {
  ControllerTaskBuilder builder_(_fbb);
  builder_.add_task(task);
  builder_.add_task_type(task_type);
  return builder_.Finish();
}

inline bool VerifyControllerSubTask(flatbuffers::Verifier &verifier, const void *obj, ControllerSubTask type) {
  switch (type) {
    case ControllerSubTask_NONE: {
      return true;
    }
    case ControllerSubTask_timerTask: {
      auto ptr = reinterpret_cast<const timerTask *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ControllerSubTask_memoryTask: {
      auto ptr = reinterpret_cast<const memoryTask *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ControllerSubTask_barrierConfigurationTask: {
      auto ptr = reinterpret_cast<const barrierConfigurationTask *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyControllerSubTaskVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyControllerSubTask(
        verifier,  values->Get(i), types->GetEnum<ControllerSubTask>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace MVCNN

#endif  // FLATBUFFERS_GENERATED_NNCONTROLLER_MVCNN_H_
