<!-- Autogenerated by mlir-tblgen; don't manually edit -->
# 'const' Dialect

Const Dialect
The **VPUX NN Compiler** uses lazy constant folding approach to reduce memory footprint
for large constant values (like dense tensors).

The **Const Dialect** provides utilities for that lazy constant folding support.

It defines a special attribute `Const::ContentAttr` to hold original constant data
and the transformations applied to it.
The `Const::ContentAttr` provides an API to apply the transformations on-the-fly,
when accessing the data.

The **Const Dialect** supports the following transformations:

* Broadcast
* Precision conversion
* Quantization types casting from raw storage
* Dequantization
* Rescale
* Add
* Reshape
* Reverse
* Reorder
* Padding
* SubView
* BitPack
* Transpose
* ExpandDilated
* GetSparsityMap
* Sparsify

The transformations are stored as separate attributes, which implemented specific Attribute Interface.
The interface allows to extend the set of transformations outside of the **Const Dialect** implementation.

Initial non-transformed constant should be created via `Const::DeclareOp` and `Const::ContentAttr`:

```C++
mlir::ElementsAttr baseValue = ...;
Const::ConstOp constOp = builder.create<Const::DeclareOp>(loc, resultType, Const::ContentAttr::get(baseValue));
```

In assembly code it will be represented as:

```MLIR
%0 = const.Declare tensor<1x2x3x4xf32> = dense<...> : tensor<1x2x3x4xf32>>
```

The content is accessed from `Const::DeclareOp` via `content()` method.
The method returns special `Const::Content` object, which allows to access underlying values as range.
The `Const::Content` object must be stored in separate variable, since it might contain temporal buffer,
which will be freed at object destruction.

```C++
Const::DeclareOp constOp = ...;
Const::Content content = constOp.content(); // This call will apply all transformations
const auto valsRange = content.getValues<float>(); // Access the values via range-like class
for (auto val : valsRange) { ... }
```

Note: the `getValues` allows to specify desired type for elements and will perform conversion from underlying storage type on-the-fly.

To perform tranformations on constant data, the new `Const::ContentAttr` must be created on top of existed with specified transformation:

```C++
Const::DeclareOp origConstOp = ...;
Const::ConstContentAttr origConstAttr = origConstOp.contentAttr();
Const::ConstContentAttr newConstAttr = origConstAttr.convertElemType(mlir::Float16Type::get(ctx));
Const::ConstOp newConstOp = builder.create<Const::DeclareOp>(loc, newConstAttr.getType(), newConstAttr);
```

In assembly code it will be represented as:

```MLIR
%0 = const.Declare tensor<1x2x3x4xf16> = dense<...> : tensor<1x2x3x4xf32>, [#const.ConvertElemType<f16>]
```

The `Const::ConstContentAttr` might hold a list of transformations, they will be applied in the order:

```MLIR
%0 = const.Declare memref<1x2x3x4xf16, #NHWC, #strides> =
        dense<...> : tensor<2x3x4xf32>,
        [
            #const.ConvertElemType<f16>,
            #const.Reshape<[1, 2, 3, 4]>,
            #const.Reorder<#NHWC>
        ]
```

Note: the tensor-related type attributes (shape, layout, element type) for the `Const::DeclareOp` result value
and for `Const::ConstContentAttr` final infered type must match.

The quantized constant is represented via special `#const.QuantCast` transformation, which casts raw integer storage representation
to quantized type with quantization parameters:

```MLIR
%0 = const.Declare tensor<1x16x1x1x!quant.uniform<u8:f16, ...>> =
        dense<...> : tensor<1x16x1x1xui8>,
        [
            #const.QuantCast<!quant.uniform<u8:f16, ...>>
        ]
```

Some transformations have a requirement to be applied before or after other transformations.
To ensure this requirement is met, each transformation has a `PositionRequirement` attached.
The available PositionRequirements are:

```
- NONE            // can be anywhere in the list
- PREFERRED_LAST  // will be last unless a transformation with LAST requirement is present
- LAST            // will be the last transformation in the list
```

The position of the transformations in the list will be:

```
[NONE]* -> [PREFERRED_LAST]* -> LAST
```

No two transformations with the LAST requirement can exist. The order of transformations with the same requirement is stable
(i.e. the insertion order is maintained).

To set the requirement for a transformation, override the default implementation for the `getPositionRequirement` method for
`Const_TransformAttrInterface`:

```
def Const_BitPackAttr : Const_Attr<"BitPack",
        [DeclareAttrInterfaceMethods<Const_TransformAttrInterface, ["getPositionRequirement"]>
```

In the source file for your transformation, implement the `getPositionRequirement` method:

```C++
//
// BitPackAttr::getPositionRequirement
//

Const::details::PositionRequirement Const::BitPackAttr::getPositionRequirement() const {
    return Const::details::PositionRequirement::LAST;
}
```

[./const/_attr_interfaces.md]

[TOC]

## Attribute definition

### AddAttr

Add constant content


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| bias | `mlir::FloatAttr` |  |

### BitPackAttr

Pack sub-byte constant content


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| width | `mlir::IntegerAttr` |  |

### BroadcastAttr

Broadcast axis by value of constant content


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| axis | `mlir::IntegerAttr` |  |
| value | `mlir::IntegerAttr` |  |

### ContentAttr

Lazy folded constant content

This attribute holds base constant and transformation applied to it.
It provides and API to get transformed values on the fly.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| baseContent | `mlir::ElementsAttr` |  |
| transformations | `mlir::ArrayAttr` |  |
| finalType | `vpux::NDTypeInterface` |  |

### ConvertElemTypeAttr

Convert constant content element type


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| elemType | `mlir::Type` |  |

### DequantizeAttr

Dequantize constant content


### ExpandDilatedAttr

Expand constant content with zeros according to dilations


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| dilations | `mlir::ArrayAttr` |  |

### GetSparsityMapAttr

Generate sparsity map


### PadWithZeroAttr

Pad constant content with zeros


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| padBefore | `mlir::ArrayAttr` |  |
| padAfter | `mlir::ArrayAttr` |  |

### QuantCastAttr

Cast element type from raw integer to quantized type


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| elemType | `mlir::quant::QuantizedType` |  |

### RelocateWeightsTableAttr

Patches offsets in the weights table


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| weightsPtr | `mlir::IntegerAttr` |  |
| sparsityPtr | `mlir::IntegerAttr` |  |
| offsets | `mlir::ArrayAttr` |  |
| weightsElemByteSize | `mlir::IntegerAttr` |  |
| weightsCompression | `VPUIP::CompressionSchemeAttr` |  |

### ReorderAttr

Reorder constant content


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| order | `mlir::AffineMapAttr` |  |

### RescaleAttr

Rescale constant content


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| scale | `mlir::FloatAttr` |  |

### ReshapeAttr

Reshape constant content


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| shape | `mlir::ArrayAttr` |  |

### ReverseAttr

Reverse constant content on specified axis

This transformation reverses content on a specified axis.
For example, considering an input with dimensions (d0, d1, d2, d3),
reversing on axis d1 will result in the data of every subpart (d2, d3)
being reversed.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| axis | `mlir::IntegerAttr` |  |

### SparsifyAttr

Remove zeros / zero-points from constant


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| compressOutputType | `mlir::BoolAttr` |  |
| numActualElements | `mlir::ElementsAttr` |  |

### SubViewAttr

Extract subview from constant content


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| offset | `mlir::ArrayAttr` |  |
| shape | `mlir::ArrayAttr` |  |

### SwizzleConstantAttr

Swizzles the constant based on swizzle key

This transformation applies swizzling transformation to a constant content.
Configuration of transformation depends on architecture and swizzleKey.
Constant content will be size aligned (alignSize flag) if its default size
does not meet HW requirements for this transformation.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| swizzleKey | `mlir::IntegerAttr` |  |
| arch | `mlir::IntegerAttr` |  |
| alignSize | `mlir::BoolAttr` |  |

### TransposeAttr

Transpose constant content


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| order | `mlir::AffineMapAttr` |  |

## Operation definition

### `const.Declare` (vpux::Const::DeclareOp)

Constant tensor/buffer declaration


Syntax:

```
operation ::= `const.Declare` attr-dict type($output) `=` $content
```

This operation can perform extra lazy constant folding transformations for constant content.

Traits: ConstantLike, DeclarationOp

Interfaces: BinaryOpInterface, DotInterface, NoSideEffect (MemoryEffectOpInterface), OpAsmOpInterface

Effects: MemoryEffects::Effect{}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `content` | vpux::Const::ContentAttr | Lazy folded constant content

#### Results:

| Result | Description |
| :----: | ----------- |
| `output` | statically shaped tensor of any type values or statically shaped memref of any type values

