<!-- Autogenerated by mlir-tblgen; don't manually edit -->
### `-break-data-flow`: Breaks data flow in the graph
This pass breaks data flow in the graph. It is required for the VPURT dialect for correct task creation
because all VPUIP dialect tasks will be inside body of the TaskOp and it is impossible to use operation results inside another body of TaskOp.
### `-cmx-concat`: Tries to CMX a concat
This pass checks a concat can be in CMX and removes all the spills to DDR and creates a shared memref buffer
### `-convert-scalar-to-tensor`: Convert the second scalar input to tensor for Gather
Gather doesn't support scalar inputs (input is scalar if `rank == 0`). But the second Gather input (indices) could be scalar.
This pass convert indices to tensor with `rank == 1` and the same content.
### `-copy-op-hoisting`: Update location of CopyOps in the block
This pass checks all CopyOps and updates their position in the parent block to be close to source op
that generates the copy op source buffer
### `-dma-task-profiling`: DMA task profiling using DMA-Timestamps
This pass add DMA task profiling.
### `-dpu-profiling`: DPU task profiling
This pass allocate required memory for DPU profiling and perform buffer spilling
### `-feasible-allocation`: Feasible Memory Scheduling Pass
Schedule async.execute opeations based on their dependecies and CMX memory availability

#### Options
```
-memory-space              : Memory space to perform allocation
-second-level-memory-space : Second level memory space to perform spilling
```
### `-group-async-execute-ops`: Reduces number of async.execute operations
Groups consecutive operations which utilizes the same executor and max resources into same async.execute region
### `-legalize-copies`: Legalizes Copy Ops which do not fit hardware capabilities
This pass checks if Copy Op can be executed at target hardware and splits it into a few tiles if necessary.
### `-linearization`: Perform linearization of the IR
Perform linearization of the IR with fully sequential execution.
### `-move-view-ops-into-async-regions`: Moves view-like Operations inside the asynchronous regions which depends on them
### `-move-wait-result-to-async-block-args`: Moves 'async.await' result usage from 'async.execute' body to it's operands
### `-optimize-async-deps`: Optimizes dependencies between 'async.execute' operations
The pass tries to remove extra explicit `!async.token` based dependencies,
if they are represented implicitly (as a result of transitive dependencies).
### `-optimize-copies`: Removes Copy Ops which are unnecessary
This pass checks if Copy Op can be optimized out to reduce the amount of unnecessary DMAs and intermediate buffers.
### `-optimize-parallel-copies`: Copy the data only once for all the tiles that share the same data
This pass checks all the CopyOps consumed by tiles of one tiling subgraph.
If the CopyOps operate on the same weight or activation, merge the parallel copies into one.
### `-patch-weight-table`: Adjusts weights and sparsity pointers after memory scheduling and unroll cluster tiling pass
This pass adds RelocateWeightsTable transformation to weights table constants. The transformation adds weights and sparsity base pointers
et that are already filled in the weights table constants.
This pass is used twice. The pass is first called after memory scheduling to compute the pointer offsets. But for the case of a "SEGMENTED"
r (i.e. Split over Kernel) the weight table would contain incorrect offsets. The pass is called again after the NCEClusterTiling operations
 been unrolled. At this point the correct offsets can be computed for this mode.
### `-set-internal-memory-space`: Set specific memory space for all internal memory buffers
This pass updates all Types for internal memory buffers and sets the specified memory space for them.

#### Options
```
-memory-space : Memory space to perform allocation
```
### `-split-by-planes`: Legalizes Copy Ops which have more than 255 planes
A tensor may have more than 255 planes, causing the hardware to malfunction. This pass checks if Copy Op has
less than 256 planes and splits it into several tiles if necessary. The number of planes is defined by the
outermost dimension in the tensor (except for N - batch). Depending on the order of the data in memory, there
may be several options for what to count as the number of planes. For example, if the dimension order (from the
outermost to the innermost) is NCHW, then HW (height-width) is considered a plane, and the number of planes
equals to the value of dimension C. The number of planes for different dimension orders:
* For NHWC - H
* For NCHW - C
* For NWCH - W
### `-static-allocation`: Replace dynamic allocations with static
This pass replaces all dynamic `alloc`/`dealloc` Operations with `IERT.StaticAlloc`.
It uses simple LinearScan algorithm.

#### Options
```
-memory-space : Memory space to perform allocation
```
### `-wrap-into-async-regions`: Wraps layer operations into asynchronous regions
This pass wraps each IERT layer operation into async region preserving linear execution.
