# M2I (Media to Inference)

## Introduction

M2I is a HW block available on VPU4000, which is capable of doing things like:
- image color conversion (e.g. NV12->RGB)
- image rescale
- data type conversion (e.g. u8 input, fp16 output)
- data permutation (e.g. interleaved-input, planar-output)

The main usecase for this block is to perform Pre/Post image processing, in order to adapt IO data to networks requirements.

### Abbreviations

| Abbreviation | Description               |
| :----------  | :-------------------------|
| csc          | Color Space Conversion    |
| norm         | Normalization             |
| perm         | Permute (IE::MemPermuteOp)|
| convertU8F16 | (IE::ConvertOp)           |
| PL           | Planar                    |
| IL           | Interleaved               |


### Target OpenVINO ops

Above functionality naturally maps on following OpenVINO ops:
1. **Interpolate** : <br/>
https://docs.openvino.ai/latest/openvino_docs_ops_image_Interpolate_4.html

2. **ColorConvert** : <br/>
https://docs.openvino.ai/latest/openvino_docs_ops_image_NV12toBGR_8.html <br/>
https://docs.openvino.ai/latest/openvino_docs_ops_image_NV12toRGB_8.html <br/>
https://docs.openvino.ai/latest/openvino_docs_ops_image_I420toBGR_8.html <br/>
https://docs.openvino.ai/latest/openvino_docs_ops_image_I420toRGB_8.html <br/>

3. **Normalization** : <br/>
https://docs.openvino.ai/latest/openvino_docs_ops_normalization_BatchNormInference_1.html

Limitations:
* NV12/I420 inputs can be single-plane or multi-plane. Currently only SINGLE_PLANE is supported (thus ColorConvert op is aligned with the other ops that are all single-input)
* For IE::InterpolateOp, just *shape_calculation_mode* = ‘sizes’ mode for output shape calculation (the mode used by Preprocessing API).

### Operation lowering

The above 3 ops are lowered as: <br/>
*ngraph*::NV12toRGB → *IE*::YuvToRgbOp → *VPU*::M2IColorConvertOp → *VPU*::M2ITaskOp → *VPUIP*::M2ITaskOp <br/>
*ngraph*::Interpolate → *IE*::InterpolateOp →*VPU*::M2IResizeOp → *VPU*::M2ITaskOp →  *VPUIP*::M2ITaskOp<br/>
*ngraph*::BatchNormInference → *IE*::BatchNormOp →*VPU*::M2INormOp → *VPU*::M2ITaskOp → *VPUIP*::M2ITaskOp<br/>

All  VPU M2i ops (ColorConvert, Resize, Norm) are converted to a general VPU::M2ITaskOp before going to VPUIP dialect.

### Single ops tests

* **Color Conversion:** <br/>
SP_NV12_8   → [csc] → PL_RGB24(u8) <br/>
SP_NV12_8   → [csc] → PL_BGR24(u8) <br/>
PL_YUV420_8 → [csc] → PL_RGB24(u8) <br/>
PL_YUV420_8 → [csc] → PL_BGR24(u8) <br/>

Note: YuvToRgb ColorConvert assumes input NV12/I420 and RGB/BGR interleaved output of same precision (e.g. ui8). OpenVINO op supports also fp16, M2I-HW does not support some IL_FP16_RGB output, nor NV12_FP16 input. So standalone color convert ops are limited to u8 input/output.

* **Resize:** <br/>
PL_RGB24(u8) → [resize] → PL_RGB24(u8) <br/>
PL_FP16_RGB → [resize] → PL_FP16_RGB24 <br/>
IL_RGB888(u8) → [resize] → IL_RGB888(u8) <br/>

* **BatchNormInference:** <br/>
PL_FP16_RGB → [resize] → PL_FP16_RGB24 <br/>

Note: This op is defined on any floating point type, which will be limited to fp16 by M2I-HW.

### Fusing multiple ops
Besides the individual operation support, some fuse-patterns can also be supported: <br/><br/>
SP_NV12_8   → [csc → convertU8F16 → resize → permute] → PL_FP16_RGB <br/>
SP_NV12_8   → [csc → convertU8F16 → resize → permute] → PL_FP16_BGR <br/>
PL_YUV420_8 → [csc → convertU8F16 → resize → permute] → PL_FP16_RGB <br/>
PL_YUV420_8 → [csc → convertU8F16 → resize → permute] → PL_FP16_BGR <br/>


SP_NV12_8   → [csc → resize → permute] → PL_RGB24(u8) <br/>
SP_NV12_8   → [csc → resize → permute] → PL_BGR24(u8) <br/>
PL_YUV420_8 → [csc → resize → permute] → PL_RGB24(u8) <br/>
PL_YUV420_8 → [csc → resize → permute] → PL_BGR24(u8) <br/>

SP_NV12_8   → [csc → resize] → IL_RGB888(u8) <br/>
SP_NV12_8   → [csc → resize] → IL_BGR888(u8) <br/>
PL_YUV420_8 → [csc → resize] → IL_RGB888(u8) <br/>
PL_YUV420_8 → [csc → resize] → IL_BGR888(u8) <br/>


PL_YUV420_8 → [csc → permute] → PL_RGB24(u8) <br/>
PL_YUV420_8 → [csc → permute] → PL_BGR24(u8) <br/>
SP_NV12_8   → [csc → permute] → PL_RGB24(u8) <br/>
SP_NV12_8   → [csc → permute] → PL_BGR24(u8) <br/>
(**Note:** csc, permute do not change precision, therefore ui8 in/out) <br/>

PL_YUV420_8 → [csc → convertU8F16 → permute] → PL_FP16_RGB <br/>
PL_YUV420_8 → [csc → convertU8F16 → permute] → PL_FP16_BGR <br/>
SP_NV12_8   → [csc → convertU8F16 → permute] → PL_FP16_RGB <br/>
SP_NV12_8   → [csc → convertU8F16 → permute] → PL_FP16_BGR <br/>
(**Note:** M2I does not support IL-fp16 output, thus just PL mode available) <br/>

All these subgraph configs are generated by using OpenVINO Preprocessing API: <br/>
https://docs.openvino.ai/2022.1/openvino_docs_OV_UG_Preprocessing_Overview.html#doxid-openvino-docs-o-v-u-g-preprocessing-overview

#### Normalization not fused !!!
Normalization done via OV Preprocessing API *mean(), scale()* is implemented via IE::Subtract and IE::Multiply (which later are converted into IE::ScaleShift. All these IE:: ops assume dynamic inputs, so cannot extract the coefs @ compile-time, and fill the A,B,C,D norm coefs.

On the other hand *ngraph::BatchNormInference* sets up constant norm coefs, which can be easily converted. If later Preprocessor API decides to rely on BatchNormInference, we could complete the norm fuse.

### BatchNormInference coefs mapping
BatchNormInference op does following type of normalization: <br/>
`out = [(in – mean) / sqrt(var+eps)] * gamma + beta` <br/>

Whereas M2I-HW usses following A,B,C,D coefficients formula: <br/>
`out = [(in - B) / C] * A + D` <br/>
Therefore the mapping of op attributes to A,B,C,D fp16 coefs is: <br/>
`A = gamma` <br/>
`B = mean` <br/>
`C = sqrt(var + eps)` <br/>
`D = beta` <br/>

### Running vpux-plugin tests
Single layer tests: <br/>
`/vpuxFuncTests --gtest_filter=*Color*M2I*` <br/>
`/vpuxFuncTests --gtest_filter=*Interpolate*M2I*` <br/>
`/vpuxFuncTests --gtest_filter=*BatchNorm*M2I*` <br/>

Subgraph tests: <br/>
`/vpuxFuncTests --gtest_filter=*smoke_PrePostProcess*M2I*` <br/>
