// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DEVICE_MVCNN_H_
#define FLATBUFFERS_GENERATED_DEVICE_MVCNN_H_

#include "flatbuffers/flatbuffers.h"

namespace MVCNN {

struct MemoryMapping;
struct MemoryMappingBuilder;
struct MemoryMappingT;

struct ProcessorMapping;
struct ProcessorMappingBuilder;
struct ProcessorMappingT;

struct MemoryRelationshipMapping;
struct MemoryRelationshipMappingBuilder;
struct MemoryRelationshipMappingT;

enum PhysicalProcessor {
  PhysicalProcessor_NULL = 0,
  PhysicalProcessor_LEON_RT = 1,
  PhysicalProcessor_UPA_SHV = 2,
  PhysicalProcessor_LEON_NN = 3,
  PhysicalProcessor_NN_SHV = 4,
  PhysicalProcessor_ARM = 5,
  PhysicalProcessor_NCE_Cluster = 6,
  PhysicalProcessor_NCE_PerClusterDPU = 7,
  PhysicalProcessor_MIN = PhysicalProcessor_NULL,
  PhysicalProcessor_MAX = PhysicalProcessor_NCE_PerClusterDPU
};

inline const PhysicalProcessor (&EnumValuesPhysicalProcessor())[8] {
  static const PhysicalProcessor values[] = {
    PhysicalProcessor_NULL,
    PhysicalProcessor_LEON_RT,
    PhysicalProcessor_UPA_SHV,
    PhysicalProcessor_LEON_NN,
    PhysicalProcessor_NN_SHV,
    PhysicalProcessor_ARM,
    PhysicalProcessor_NCE_Cluster,
    PhysicalProcessor_NCE_PerClusterDPU
  };
  return values;
}

inline const char * const *EnumNamesPhysicalProcessor() {
  static const char * const names[9] = {
    "NULL",
    "LEON_RT",
    "UPA_SHV",
    "LEON_NN",
    "NN_SHV",
    "ARM",
    "NCE_Cluster",
    "NCE_PerClusterDPU",
    nullptr
  };
  return names;
}

inline const char *EnumNamePhysicalProcessor(PhysicalProcessor e) {
  if (flatbuffers::IsOutRange(e, PhysicalProcessor_NULL, PhysicalProcessor_NCE_PerClusterDPU)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPhysicalProcessor()[index];
}

enum DMAEngine {
  DMAEngine_NULL = 0,
  DMAEngine_UPA = 1,
  DMAEngine_NN = 2,
  DMAEngine_MIN = DMAEngine_NULL,
  DMAEngine_MAX = DMAEngine_NN
};

inline const DMAEngine (&EnumValuesDMAEngine())[3] {
  static const DMAEngine values[] = {
    DMAEngine_NULL,
    DMAEngine_UPA,
    DMAEngine_NN
  };
  return values;
}

inline const char * const *EnumNamesDMAEngine() {
  static const char * const names[4] = {
    "NULL",
    "UPA",
    "NN",
    nullptr
  };
  return names;
}

inline const char *EnumNameDMAEngine(DMAEngine e) {
  if (flatbuffers::IsOutRange(e, DMAEngine_NULL, DMAEngine_NN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDMAEngine()[index];
}

enum PhysicalMem {
  PhysicalMem_NULL = 0,
  PhysicalMem_DDR = 1,
  PhysicalMem_UPA_CMX = 2,
  PhysicalMem_NN_CMX = 3,
  PhysicalMem_CSRAM = 4,
  PhysicalMem_MIN = PhysicalMem_NULL,
  PhysicalMem_MAX = PhysicalMem_CSRAM
};

inline const PhysicalMem (&EnumValuesPhysicalMem())[5] {
  static const PhysicalMem values[] = {
    PhysicalMem_NULL,
    PhysicalMem_DDR,
    PhysicalMem_UPA_CMX,
    PhysicalMem_NN_CMX,
    PhysicalMem_CSRAM
  };
  return values;
}

inline const char * const *EnumNamesPhysicalMem() {
  static const char * const names[6] = {
    "NULL",
    "DDR",
    "UPA_CMX",
    "NN_CMX",
    "CSRAM",
    nullptr
  };
  return names;
}

inline const char *EnumNamePhysicalMem(PhysicalMem e) {
  if (flatbuffers::IsOutRange(e, PhysicalMem_NULL, PhysicalMem_CSRAM)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPhysicalMem()[index];
}

struct MemoryMappingT : public flatbuffers::NativeTable {
  typedef MemoryMapping TableType;
  MVCNN::PhysicalMem item;
  double number;
  MemoryMappingT()
      : item(MVCNN::PhysicalMem_NULL),
        number(0.0) {
  }
};

struct MemoryMapping FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MemoryMappingT NativeTableType;
  typedef MemoryMappingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEM = 4,
    VT_NUMBER = 6
  };
  MVCNN::PhysicalMem item() const {
    return static_cast<MVCNN::PhysicalMem>(GetField<int8_t>(VT_ITEM, 0));
  }
  double number() const {
    return GetField<double>(VT_NUMBER, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ITEM) &&
           VerifyField<double>(verifier, VT_NUMBER) &&
           verifier.EndTable();
  }
  MemoryMappingT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MemoryMappingT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MemoryMapping> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MemoryMappingT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MemoryMappingBuilder {
  typedef MemoryMapping Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_item(MVCNN::PhysicalMem item) {
    fbb_.AddElement<int8_t>(MemoryMapping::VT_ITEM, static_cast<int8_t>(item), 0);
  }
  void add_number(double number) {
    fbb_.AddElement<double>(MemoryMapping::VT_NUMBER, number, 0.0);
  }
  explicit MemoryMappingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MemoryMappingBuilder &operator=(const MemoryMappingBuilder &);
  flatbuffers::Offset<MemoryMapping> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MemoryMapping>(end);
    return o;
  }
};

inline flatbuffers::Offset<MemoryMapping> CreateMemoryMapping(
    flatbuffers::FlatBufferBuilder &_fbb,
    MVCNN::PhysicalMem item = MVCNN::PhysicalMem_NULL,
    double number = 0.0) {
  MemoryMappingBuilder builder_(_fbb);
  builder_.add_number(number);
  builder_.add_item(item);
  return builder_.Finish();
}

flatbuffers::Offset<MemoryMapping> CreateMemoryMapping(flatbuffers::FlatBufferBuilder &_fbb, const MemoryMappingT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ProcessorMappingT : public flatbuffers::NativeTable {
  typedef ProcessorMapping TableType;
  MVCNN::PhysicalProcessor item;
  double number;
  bool is_bitmask;
  ProcessorMappingT()
      : item(MVCNN::PhysicalProcessor_NULL),
        number(0.0),
        is_bitmask(false) {
  }
};

struct ProcessorMapping FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProcessorMappingT NativeTableType;
  typedef ProcessorMappingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEM = 4,
    VT_NUMBER = 6,
    VT_IS_BITMASK = 8
  };
  MVCNN::PhysicalProcessor item() const {
    return static_cast<MVCNN::PhysicalProcessor>(GetField<int8_t>(VT_ITEM, 0));
  }
  double number() const {
    return GetField<double>(VT_NUMBER, 0.0);
  }
  bool is_bitmask() const {
    return GetField<uint8_t>(VT_IS_BITMASK, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ITEM) &&
           VerifyField<double>(verifier, VT_NUMBER) &&
           VerifyField<uint8_t>(verifier, VT_IS_BITMASK) &&
           verifier.EndTable();
  }
  ProcessorMappingT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ProcessorMappingT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ProcessorMapping> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProcessorMappingT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ProcessorMappingBuilder {
  typedef ProcessorMapping Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_item(MVCNN::PhysicalProcessor item) {
    fbb_.AddElement<int8_t>(ProcessorMapping::VT_ITEM, static_cast<int8_t>(item), 0);
  }
  void add_number(double number) {
    fbb_.AddElement<double>(ProcessorMapping::VT_NUMBER, number, 0.0);
  }
  void add_is_bitmask(bool is_bitmask) {
    fbb_.AddElement<uint8_t>(ProcessorMapping::VT_IS_BITMASK, static_cast<uint8_t>(is_bitmask), 0);
  }
  explicit ProcessorMappingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProcessorMappingBuilder &operator=(const ProcessorMappingBuilder &);
  flatbuffers::Offset<ProcessorMapping> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProcessorMapping>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProcessorMapping> CreateProcessorMapping(
    flatbuffers::FlatBufferBuilder &_fbb,
    MVCNN::PhysicalProcessor item = MVCNN::PhysicalProcessor_NULL,
    double number = 0.0,
    bool is_bitmask = false) {
  ProcessorMappingBuilder builder_(_fbb);
  builder_.add_number(number);
  builder_.add_is_bitmask(is_bitmask);
  builder_.add_item(item);
  return builder_.Finish();
}

flatbuffers::Offset<ProcessorMapping> CreateProcessorMapping(flatbuffers::FlatBufferBuilder &_fbb, const ProcessorMappingT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MemoryRelationshipMappingT : public flatbuffers::NativeTable {
  typedef MemoryRelationshipMapping TableType;
  MVCNN::PhysicalMem from_item;
  MVCNN::PhysicalMem to_item;
  double number;
  MemoryRelationshipMappingT()
      : from_item(MVCNN::PhysicalMem_NULL),
        to_item(MVCNN::PhysicalMem_NULL),
        number(0.0) {
  }
};

struct MemoryRelationshipMapping FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MemoryRelationshipMappingT NativeTableType;
  typedef MemoryRelationshipMappingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FROM_ITEM = 4,
    VT_TO_ITEM = 6,
    VT_NUMBER = 8
  };
  MVCNN::PhysicalMem from_item() const {
    return static_cast<MVCNN::PhysicalMem>(GetField<int8_t>(VT_FROM_ITEM, 0));
  }
  MVCNN::PhysicalMem to_item() const {
    return static_cast<MVCNN::PhysicalMem>(GetField<int8_t>(VT_TO_ITEM, 0));
  }
  double number() const {
    return GetField<double>(VT_NUMBER, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FROM_ITEM) &&
           VerifyField<int8_t>(verifier, VT_TO_ITEM) &&
           VerifyField<double>(verifier, VT_NUMBER) &&
           verifier.EndTable();
  }
  MemoryRelationshipMappingT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MemoryRelationshipMappingT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MemoryRelationshipMapping> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MemoryRelationshipMappingT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MemoryRelationshipMappingBuilder {
  typedef MemoryRelationshipMapping Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_from_item(MVCNN::PhysicalMem from_item) {
    fbb_.AddElement<int8_t>(MemoryRelationshipMapping::VT_FROM_ITEM, static_cast<int8_t>(from_item), 0);
  }
  void add_to_item(MVCNN::PhysicalMem to_item) {
    fbb_.AddElement<int8_t>(MemoryRelationshipMapping::VT_TO_ITEM, static_cast<int8_t>(to_item), 0);
  }
  void add_number(double number) {
    fbb_.AddElement<double>(MemoryRelationshipMapping::VT_NUMBER, number, 0.0);
  }
  explicit MemoryRelationshipMappingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MemoryRelationshipMappingBuilder &operator=(const MemoryRelationshipMappingBuilder &);
  flatbuffers::Offset<MemoryRelationshipMapping> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MemoryRelationshipMapping>(end);
    return o;
  }
};

inline flatbuffers::Offset<MemoryRelationshipMapping> CreateMemoryRelationshipMapping(
    flatbuffers::FlatBufferBuilder &_fbb,
    MVCNN::PhysicalMem from_item = MVCNN::PhysicalMem_NULL,
    MVCNN::PhysicalMem to_item = MVCNN::PhysicalMem_NULL,
    double number = 0.0) {
  MemoryRelationshipMappingBuilder builder_(_fbb);
  builder_.add_number(number);
  builder_.add_to_item(to_item);
  builder_.add_from_item(from_item);
  return builder_.Finish();
}

flatbuffers::Offset<MemoryRelationshipMapping> CreateMemoryRelationshipMapping(flatbuffers::FlatBufferBuilder &_fbb, const MemoryRelationshipMappingT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline MemoryMappingT *MemoryMapping::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MVCNN::MemoryMappingT> _o = std::unique_ptr<MVCNN::MemoryMappingT>(new MemoryMappingT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MemoryMapping::UnPackTo(MemoryMappingT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = item(); _o->item = _e; }
  { auto _e = number(); _o->number = _e; }
}

inline flatbuffers::Offset<MemoryMapping> MemoryMapping::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MemoryMappingT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMemoryMapping(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MemoryMapping> CreateMemoryMapping(flatbuffers::FlatBufferBuilder &_fbb, const MemoryMappingT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MemoryMappingT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _item = _o->item;
  auto _number = _o->number;
  return MVCNN::CreateMemoryMapping(
      _fbb,
      _item,
      _number);
}

inline ProcessorMappingT *ProcessorMapping::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MVCNN::ProcessorMappingT> _o = std::unique_ptr<MVCNN::ProcessorMappingT>(new ProcessorMappingT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ProcessorMapping::UnPackTo(ProcessorMappingT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = item(); _o->item = _e; }
  { auto _e = number(); _o->number = _e; }
  { auto _e = is_bitmask(); _o->is_bitmask = _e; }
}

inline flatbuffers::Offset<ProcessorMapping> ProcessorMapping::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProcessorMappingT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateProcessorMapping(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ProcessorMapping> CreateProcessorMapping(flatbuffers::FlatBufferBuilder &_fbb, const ProcessorMappingT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ProcessorMappingT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _item = _o->item;
  auto _number = _o->number;
  auto _is_bitmask = _o->is_bitmask;
  return MVCNN::CreateProcessorMapping(
      _fbb,
      _item,
      _number,
      _is_bitmask);
}

inline MemoryRelationshipMappingT *MemoryRelationshipMapping::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MVCNN::MemoryRelationshipMappingT> _o = std::unique_ptr<MVCNN::MemoryRelationshipMappingT>(new MemoryRelationshipMappingT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MemoryRelationshipMapping::UnPackTo(MemoryRelationshipMappingT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = from_item(); _o->from_item = _e; }
  { auto _e = to_item(); _o->to_item = _e; }
  { auto _e = number(); _o->number = _e; }
}

inline flatbuffers::Offset<MemoryRelationshipMapping> MemoryRelationshipMapping::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MemoryRelationshipMappingT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMemoryRelationshipMapping(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MemoryRelationshipMapping> CreateMemoryRelationshipMapping(flatbuffers::FlatBufferBuilder &_fbb, const MemoryRelationshipMappingT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MemoryRelationshipMappingT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _from_item = _o->from_item;
  auto _to_item = _o->to_item;
  auto _number = _o->number;
  return MVCNN::CreateMemoryRelationshipMapping(
      _fbb,
      _from_item,
      _to_item,
      _number);
}

}  // namespace MVCNN

#endif  // FLATBUFFERS_GENERATED_DEVICE_MVCNN_H_
