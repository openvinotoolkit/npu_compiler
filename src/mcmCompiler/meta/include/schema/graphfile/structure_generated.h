// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_STRUCTURE_MVCNN_H_
#define FLATBUFFERS_GENERATED_STRUCTURE_MVCNN_H_

#include "flatbuffers/flatbuffers.h"

#include "memoryManagement_generated.h"

namespace MVCNN {

struct SourceStructure;
struct SourceStructureBuilder;
struct SourceStructureT;

struct GraphNode;
struct GraphNodeBuilder;
struct GraphNodeT;

struct Barrier;
struct BarrierBuilder;
struct BarrierT;

struct BarrierReference;
struct BarrierReferenceBuilder;
struct BarrierReferenceT;

struct SourceStructureT : public flatbuffers::NativeTable {
  typedef SourceStructure TableType;
  std::vector<std::unique_ptr<MVCNN::GraphNodeT>> nodes;
  std::vector<uint32_t> first_ID;
  SourceStructureT() {
  }
};

struct SourceStructure FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SourceStructureT NativeTableType;
  typedef SourceStructureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODES = 4,
    VT_FIRST_ID = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<MVCNN::GraphNode>> *nodes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MVCNN::GraphNode>> *>(VT_NODES);
  }
  const flatbuffers::Vector<uint32_t> *first_ID() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_FIRST_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           VerifyOffset(verifier, VT_FIRST_ID) &&
           verifier.VerifyVector(first_ID()) &&
           verifier.EndTable();
  }
  SourceStructureT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SourceStructureT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SourceStructure> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SourceStructureT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SourceStructureBuilder {
  typedef SourceStructure Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MVCNN::GraphNode>>> nodes) {
    fbb_.AddOffset(SourceStructure::VT_NODES, nodes);
  }
  void add_first_ID(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> first_ID) {
    fbb_.AddOffset(SourceStructure::VT_FIRST_ID, first_ID);
  }
  explicit SourceStructureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SourceStructureBuilder &operator=(const SourceStructureBuilder &);
  flatbuffers::Offset<SourceStructure> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SourceStructure>(end);
    return o;
  }
};

inline flatbuffers::Offset<SourceStructure> CreateSourceStructure(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MVCNN::GraphNode>>> nodes = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> first_ID = 0) {
  SourceStructureBuilder builder_(_fbb);
  builder_.add_first_ID(first_ID);
  builder_.add_nodes(nodes);
  return builder_.Finish();
}

inline flatbuffers::Offset<SourceStructure> CreateSourceStructureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<MVCNN::GraphNode>> *nodes = nullptr,
    const std::vector<uint32_t> *first_ID = nullptr) {
  auto nodes__ = nodes ? _fbb.CreateVector<flatbuffers::Offset<MVCNN::GraphNode>>(*nodes) : 0;
  auto first_ID__ = first_ID ? _fbb.CreateVector<uint32_t>(*first_ID) : 0;
  return MVCNN::CreateSourceStructure(
      _fbb,
      nodes__,
      first_ID__);
}

flatbuffers::Offset<SourceStructure> CreateSourceStructure(flatbuffers::FlatBufferBuilder &_fbb, const SourceStructureT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GraphNodeT : public flatbuffers::NativeTable {
  typedef GraphNode TableType;
  uint32_t thisID;
  std::string name;
  std::vector<uint32_t> sourceID;
  std::vector<uint32_t> sinkID;
  GraphNodeT()
      : thisID(0) {
  }
};

struct GraphNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GraphNodeT NativeTableType;
  typedef GraphNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_THISID = 4,
    VT_NAME = 6,
    VT_SOURCEID = 8,
    VT_SINKID = 10
  };
  uint32_t thisID() const {
    return GetField<uint32_t>(VT_THISID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<uint32_t> *sourceID() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_SOURCEID);
  }
  const flatbuffers::Vector<uint32_t> *sinkID() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_SINKID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_THISID) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_SOURCEID) &&
           verifier.VerifyVector(sourceID()) &&
           VerifyOffset(verifier, VT_SINKID) &&
           verifier.VerifyVector(sinkID()) &&
           verifier.EndTable();
  }
  GraphNodeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GraphNodeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GraphNode> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GraphNodeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GraphNodeBuilder {
  typedef GraphNode Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_thisID(uint32_t thisID) {
    fbb_.AddElement<uint32_t>(GraphNode::VT_THISID, thisID, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(GraphNode::VT_NAME, name);
  }
  void add_sourceID(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> sourceID) {
    fbb_.AddOffset(GraphNode::VT_SOURCEID, sourceID);
  }
  void add_sinkID(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> sinkID) {
    fbb_.AddOffset(GraphNode::VT_SINKID, sinkID);
  }
  explicit GraphNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GraphNodeBuilder &operator=(const GraphNodeBuilder &);
  flatbuffers::Offset<GraphNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GraphNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<GraphNode> CreateGraphNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t thisID = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> sourceID = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> sinkID = 0) {
  GraphNodeBuilder builder_(_fbb);
  builder_.add_sinkID(sinkID);
  builder_.add_sourceID(sourceID);
  builder_.add_name(name);
  builder_.add_thisID(thisID);
  return builder_.Finish();
}

inline flatbuffers::Offset<GraphNode> CreateGraphNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t thisID = 0,
    const char *name = nullptr,
    const std::vector<uint32_t> *sourceID = nullptr,
    const std::vector<uint32_t> *sinkID = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto sourceID__ = sourceID ? _fbb.CreateVector<uint32_t>(*sourceID) : 0;
  auto sinkID__ = sinkID ? _fbb.CreateVector<uint32_t>(*sinkID) : 0;
  return MVCNN::CreateGraphNode(
      _fbb,
      thisID,
      name__,
      sourceID__,
      sinkID__);
}

flatbuffers::Offset<GraphNode> CreateGraphNode(flatbuffers::FlatBufferBuilder &_fbb, const GraphNodeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BarrierT : public flatbuffers::NativeTable {
  typedef Barrier TableType;
  int16_t barrier_id;
  int16_t consumer_count;
  int16_t producer_count;
  BarrierT()
      : barrier_id(0),
        consumer_count(0),
        producer_count(0) {
  }
};

struct Barrier FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BarrierT NativeTableType;
  typedef BarrierBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BARRIER_ID = 4,
    VT_CONSUMER_COUNT = 6,
    VT_PRODUCER_COUNT = 8
  };
  /// Overview:
  /// This object represents closely a Barrier in the device.
  /// Details of exact consumers and producers are delegated to those same
  /// producers and consumers.
  ///
  /// @field barrier_id - This is an optional field to force a barrier to use
  /// a specific barrier (note: a value given here only guarantees that any other
  /// barrier with that ID will run on the same unit, it does not guarantee a particular
  /// unit)
  int16_t barrier_id() const {
    return GetField<int16_t>(VT_BARRIER_ID, 0);
  }
  int16_t consumer_count() const {
    return GetField<int16_t>(VT_CONSUMER_COUNT, 0);
  }
  int16_t producer_count() const {
    return GetField<int16_t>(VT_PRODUCER_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_BARRIER_ID) &&
           VerifyField<int16_t>(verifier, VT_CONSUMER_COUNT) &&
           VerifyField<int16_t>(verifier, VT_PRODUCER_COUNT) &&
           verifier.EndTable();
  }
  BarrierT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BarrierT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Barrier> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BarrierT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BarrierBuilder {
  typedef Barrier Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_barrier_id(int16_t barrier_id) {
    fbb_.AddElement<int16_t>(Barrier::VT_BARRIER_ID, barrier_id, 0);
  }
  void add_consumer_count(int16_t consumer_count) {
    fbb_.AddElement<int16_t>(Barrier::VT_CONSUMER_COUNT, consumer_count, 0);
  }
  void add_producer_count(int16_t producer_count) {
    fbb_.AddElement<int16_t>(Barrier::VT_PRODUCER_COUNT, producer_count, 0);
  }
  explicit BarrierBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BarrierBuilder &operator=(const BarrierBuilder &);
  flatbuffers::Offset<Barrier> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Barrier>(end);
    return o;
  }
};

inline flatbuffers::Offset<Barrier> CreateBarrier(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t barrier_id = 0,
    int16_t consumer_count = 0,
    int16_t producer_count = 0) {
  BarrierBuilder builder_(_fbb);
  builder_.add_producer_count(producer_count);
  builder_.add_consumer_count(consumer_count);
  builder_.add_barrier_id(barrier_id);
  return builder_.Finish();
}

flatbuffers::Offset<Barrier> CreateBarrier(flatbuffers::FlatBufferBuilder &_fbb, const BarrierT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BarrierReferenceT : public flatbuffers::NativeTable {
  typedef BarrierReference TableType;
  std::vector<uint32_t> wait_barriers;
  std::vector<uint32_t> update_barriers;
  BarrierReferenceT() {
  }
};

struct BarrierReference FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BarrierReferenceT NativeTableType;
  typedef BarrierReferenceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WAIT_BARRIERS = 4,
    VT_UPDATE_BARRIERS = 6
  };
  /// Overview:
  /// A BarrierReference is a tasks' accessor into it's barrier
  /// dependency and influence.
  ///
  /// @field wait_barriers - Ids of barriers that will free this
  /// task to run. Generally, You should always only need to wait on one barrier
  /// as they support multiple references.
  /// An empty list indicates that this task has no blocking barriers and can 
  /// start immediately (for example at the start of a network)
  ///
  /// @field update_barriers - Ids of barriers that will be at least partially
  /// unlocked when this task is complete.
  /// An empty list indicates that no barriers are reliant on this task.
  ///
  const flatbuffers::Vector<uint32_t> *wait_barriers() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_WAIT_BARRIERS);
  }
  const flatbuffers::Vector<uint32_t> *update_barriers() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_UPDATE_BARRIERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WAIT_BARRIERS) &&
           verifier.VerifyVector(wait_barriers()) &&
           VerifyOffset(verifier, VT_UPDATE_BARRIERS) &&
           verifier.VerifyVector(update_barriers()) &&
           verifier.EndTable();
  }
  BarrierReferenceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BarrierReferenceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BarrierReference> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BarrierReferenceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BarrierReferenceBuilder {
  typedef BarrierReference Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_wait_barriers(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> wait_barriers) {
    fbb_.AddOffset(BarrierReference::VT_WAIT_BARRIERS, wait_barriers);
  }
  void add_update_barriers(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> update_barriers) {
    fbb_.AddOffset(BarrierReference::VT_UPDATE_BARRIERS, update_barriers);
  }
  explicit BarrierReferenceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BarrierReferenceBuilder &operator=(const BarrierReferenceBuilder &);
  flatbuffers::Offset<BarrierReference> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BarrierReference>(end);
    return o;
  }
};

inline flatbuffers::Offset<BarrierReference> CreateBarrierReference(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> wait_barriers = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> update_barriers = 0) {
  BarrierReferenceBuilder builder_(_fbb);
  builder_.add_update_barriers(update_barriers);
  builder_.add_wait_barriers(wait_barriers);
  return builder_.Finish();
}

inline flatbuffers::Offset<BarrierReference> CreateBarrierReferenceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *wait_barriers = nullptr,
    const std::vector<uint32_t> *update_barriers = nullptr) {
  auto wait_barriers__ = wait_barriers ? _fbb.CreateVector<uint32_t>(*wait_barriers) : 0;
  auto update_barriers__ = update_barriers ? _fbb.CreateVector<uint32_t>(*update_barriers) : 0;
  return MVCNN::CreateBarrierReference(
      _fbb,
      wait_barriers__,
      update_barriers__);
}

flatbuffers::Offset<BarrierReference> CreateBarrierReference(flatbuffers::FlatBufferBuilder &_fbb, const BarrierReferenceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline SourceStructureT *SourceStructure::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MVCNN::SourceStructureT> _o = std::unique_ptr<MVCNN::SourceStructureT>(new SourceStructureT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SourceStructure::UnPackTo(SourceStructureT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = nodes(); if (_e) { _o->nodes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->nodes[_i] = std::unique_ptr<MVCNN::GraphNodeT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = first_ID(); if (_e) { _o->first_ID.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->first_ID[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<SourceStructure> SourceStructure::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SourceStructureT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSourceStructure(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SourceStructure> CreateSourceStructure(flatbuffers::FlatBufferBuilder &_fbb, const SourceStructureT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SourceStructureT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _nodes = _fbb.CreateVector<flatbuffers::Offset<MVCNN::GraphNode>> (_o->nodes.size(), [](size_t i, _VectorArgs *__va) { return CreateGraphNode(*__va->__fbb, __va->__o->nodes[i].get(), __va->__rehasher); }, &_va );
  auto _first_ID = _fbb.CreateVector(_o->first_ID);
  return MVCNN::CreateSourceStructure(
      _fbb,
      _nodes,
      _first_ID);
}

inline GraphNodeT *GraphNode::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MVCNN::GraphNodeT> _o = std::unique_ptr<MVCNN::GraphNodeT>(new GraphNodeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GraphNode::UnPackTo(GraphNodeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = thisID(); _o->thisID = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = sourceID(); if (_e) { _o->sourceID.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->sourceID[_i] = _e->Get(_i); } } }
  { auto _e = sinkID(); if (_e) { _o->sinkID.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->sinkID[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<GraphNode> GraphNode::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GraphNodeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGraphNode(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GraphNode> CreateGraphNode(flatbuffers::FlatBufferBuilder &_fbb, const GraphNodeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GraphNodeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _thisID = _o->thisID;
  auto _name = _o->name.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->name);
  auto _sourceID = _fbb.CreateVector(_o->sourceID);
  auto _sinkID = _fbb.CreateVector(_o->sinkID);
  return MVCNN::CreateGraphNode(
      _fbb,
      _thisID,
      _name,
      _sourceID,
      _sinkID);
}

inline BarrierT *Barrier::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MVCNN::BarrierT> _o = std::unique_ptr<MVCNN::BarrierT>(new BarrierT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Barrier::UnPackTo(BarrierT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = barrier_id(); _o->barrier_id = _e; }
  { auto _e = consumer_count(); _o->consumer_count = _e; }
  { auto _e = producer_count(); _o->producer_count = _e; }
}

inline flatbuffers::Offset<Barrier> Barrier::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BarrierT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBarrier(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Barrier> CreateBarrier(flatbuffers::FlatBufferBuilder &_fbb, const BarrierT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BarrierT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _barrier_id = _o->barrier_id;
  auto _consumer_count = _o->consumer_count;
  auto _producer_count = _o->producer_count;
  return MVCNN::CreateBarrier(
      _fbb,
      _barrier_id,
      _consumer_count,
      _producer_count);
}

inline BarrierReferenceT *BarrierReference::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MVCNN::BarrierReferenceT> _o = std::unique_ptr<MVCNN::BarrierReferenceT>(new BarrierReferenceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BarrierReference::UnPackTo(BarrierReferenceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = wait_barriers(); if (_e) { _o->wait_barriers.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->wait_barriers[_i] = _e->Get(_i); } } }
  { auto _e = update_barriers(); if (_e) { _o->update_barriers.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->update_barriers[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<BarrierReference> BarrierReference::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BarrierReferenceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBarrierReference(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BarrierReference> CreateBarrierReference(flatbuffers::FlatBufferBuilder &_fbb, const BarrierReferenceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BarrierReferenceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _wait_barriers = _fbb.CreateVector(_o->wait_barriers);
  auto _update_barriers = _fbb.CreateVector(_o->update_barriers);
  return MVCNN::CreateBarrierReference(
      _fbb,
      _wait_barriers,
      _update_barriers);
}

}  // namespace MVCNN

#endif  // FLATBUFFERS_GENERATED_STRUCTURE_MVCNN_H_
